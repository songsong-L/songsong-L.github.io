<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-16x16-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"songsong.host","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="**以下内容转载自：***&#x2F;**">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring源码分析——BeanFactory体系">
<meta property="og:url" content="http://songsong.host/2020/03/31/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94BeanFactory%E4%BD%93%E7%B3%BB/index.html">
<meta property="og:site_name" content="songsong的垃圾堆">
<meta property="og:description" content="**以下内容转载自：***&#x2F;**">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020033122152054.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200331222517144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200331222848572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2020-03-30T16:00:00.000Z">
<meta property="article:modified_time" content="2022-03-26T12:34:12.735Z">
<meta property="article:author" content="songsong">
<meta property="article:tag" content="java">
<meta property="article:tag" content="spring">
<meta property="article:tag" content="ioc">
<meta property="article:tag" content="bean">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/2020033122152054.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="http://songsong.host/2020/03/31/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94BeanFactory%E4%BD%93%E7%B3%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Spring源码分析——BeanFactory体系 | songsong的垃圾堆</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?252cd4eb7b89c9ca642359b3afc2d527";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">songsong的垃圾堆</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">收废铜烂铁~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">59</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">80</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://songsong.host/2020/03/31/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94BeanFactory%E4%BD%93%E7%B3%BB/">
    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/face.jpg">
      <meta itemprop="name" content="songsong">
      <meta itemprop="description" content="我就是我，不一样的烟火">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="songsong的垃圾堆">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring源码分析——BeanFactory体系
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-31 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-31T00:00:00+08:00">2020-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-26 20:34:12" itemprop="dateModified" datetime="2022-03-26T20:34:12+08:00">2022-03-26</time>
              </span>

          
            <span class="post-meta-item" title="阅读" id="busuanzi_container_page_pv" style="">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/03/31/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94BeanFactory%E4%BD%93%E7%B3%BB/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/03/31/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94BeanFactory%E4%BD%93%E7%B3%BB/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:03</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://img-blog.csdnimg.cn/2020033122152054.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>**</strong>以下内容转载自：***<br>/**</p>
<ul>
<li>  <strong><em>————————如果觉得本博文还行，别忘了推荐一下哦，谢谢！</em></strong></li>
<li>  <strong><em>作者：钱书康</em></strong></li>
<li>  <strong><em>欢迎转载，请保留此段声明。</em></strong></li>
<li>  <strong><em>出处：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/zrtqsk/">http://www.cnblogs.com/zrtqsk/</a></em></strong></li>
<li>/***</li>
</ul>
<h1 id="一、BeanFactory的基本类体系结构（接口为主）："><a href="#一、BeanFactory的基本类体系结构（接口为主）：" class="headerlink" title="一、BeanFactory的基本类体系结构（接口为主）："></a>一、BeanFactory的基本类体系结构（接口为主）：</h1><p><img src="https://img-blog.csdnimg.cn/20200331222517144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　　具体：<br>　　1、BeanFactory作为一个主接口不继承任何接口，暂且称为一级接口。<br>　　2、有3个子接口继承了它，进行功能上的增强。这3个子接口称为二级接口。<br>　　3、ConfigurableBeanFactory可以被称为三级接口，对二级接口HierarchicalBeanFactory进行了再次增强，它还继承了另一个外来的接口SingletonBeanRegistry<br>　　4、ConfigurableListableBeanFactory是一个更强大的接口，继承了上述的所有接口，无所不包，称为四级接口。<br>　　（这4级接口是BeanFactory的基本接口体系。继续，下面是继承关系的2个抽象类和2个实现类：）<br>　　5、AbstractBeanFactory作为一个抽象类，实现了三级接口ConfigurableBeanFactory大部分功能。<br>　　6、AbstractAutowireCapableBeanFactory同样是抽象类，继承自AbstractBeanFactory，并额外实现了二级接口AutowireCapableBeanFactory<br>　　7、DefaultListableBeanFactory继承自AbstractAutowireCapableBeanFactory，实现了最强大的四级接口ConfigurableListableBeanFactory，并实现了一个外来接口BeanDefinitionRegistry，它并非抽象类。<br>　　8、最后是最强大的XmlBeanFactory，继承自DefaultListableBeanFactory，重写了一些功能，使自己更强大。<br>总结：BeanFactory的类体系结构看似繁杂混乱，实际上由上而下井井有条，非常容易理解。</p>
<h1 id="二、IOC的始祖——BeanFactory"><a href="#二、IOC的始祖——BeanFactory" class="headerlink" title="二、IOC的始祖——BeanFactory"></a>二、IOC的始祖——BeanFactory</h1><p>来看一下BeanFactory的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line">public interface BeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用来引用一个实例，或把它和工厂产生的Bean区分开，就是说，如果一个FactoryBean的名字为a，那么，&amp;a会得到那个Factory</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String FACTORY_BEAN_PREFIX &#x3D; &quot;&amp;&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 四个不同形式的getBean方法，获取实例</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object getBean(String name) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;</span><br><span class="line"></span><br><span class="line">    Object getBean(String name, Object... args) throws BeansException;</span><br><span class="line"></span><br><span class="line">    boolean containsBean(String name); &#x2F;&#x2F; 是否存在</span><br><span class="line"></span><br><span class="line">    boolean isSingleton(String name) throws NoSuchBeanDefinitionException;&#x2F;&#x2F; 是否为单实例</span><br><span class="line"></span><br><span class="line">    boolean isPrototype(String name) throws NoSuchBeanDefinitionException;&#x2F;&#x2F; 是否为原型（多实例）</span><br><span class="line"></span><br><span class="line">    boolean isTypeMatch(String name, Class&lt;?&gt; targetType)</span><br><span class="line">            throws NoSuchBeanDefinitionException;&#x2F;&#x2F; 名称、类型是否匹配</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; &#x2F;&#x2F; 获取类型</span><br><span class="line"></span><br><span class="line">    String[] getAliases(String name);&#x2F;&#x2F; 根据实例的名字获取实例的别名</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体：<br>　　1、4个获取实例的方法。getBean的重载方法。<br>　　2、4个判断的方法。判断是否存在，是否为单例、原型，名称类型是否匹配。<br>　　3、1个获取类型的方法、一个获取别名的方法。根据名称获取类型、根据名称获取别名。一目了然！<br>总结：<br>　　这10个方法，很明显，这是一个典型的工厂模式的工厂接口。</p>
<h1 id="三、可将Bean逐一列出的工厂——ListableBeanFactory"><a href="#三、可将Bean逐一列出的工厂——ListableBeanFactory" class="headerlink" title="三、可将Bean逐一列出的工厂——ListableBeanFactory"></a>三、可将Bean逐一列出的工厂——ListableBeanFactory</h1><p>源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public interface ListableBeanFactory extends BeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    boolean containsBeanDefinition(String beanName); &#x2F;&#x2F; 对于给定的名字是否含有BeanDefinition</span><br><span class="line"></span><br><span class="line">    int getBeanDefinitionCount(); &#x2F;&#x2F; 返回工厂的BeanDefinition总数</span><br><span class="line"></span><br><span class="line">    String[] getBeanDefinitionNames(); &#x2F;&#x2F; 返回工厂中所有Bean的名字</span><br><span class="line"></span><br><span class="line">    String[] getBeanNamesForType(Class&lt;?&gt; type); &#x2F;&#x2F; 返回对于指定类型Bean（包括子类）的所有名字</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 返回指定类型的名字 includeNonSingletons为false表示只取单例Bean，true则不是</span><br><span class="line">     * allowEagerInit为true表示立刻加载，false表示延迟加载。 注意：FactoryBeans都是立刻加载的。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String[] getBeanNamesForType(Class&lt;?&gt; type, boolean includeNonSingletons,</span><br><span class="line">            boolean allowEagerInit);</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(Class&lt;T&gt; type) throws BeansException; &#x2F;&#x2F; 根据类型（包括子类）返回指定Bean名和Bean的Map</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(Class&lt;T&gt; type,</span><br><span class="line">            boolean includeNonSingletons, boolean allowEagerInit)</span><br><span class="line">            throws BeansException;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; getBeansWithAnnotation(</span><br><span class="line">            Class&lt;? extends Annotation&gt; annotationType) throws BeansException; &#x2F;&#x2F; 根据注解类型，查找所有有这个注解的Bean名和Bean的Map</span><br><span class="line"></span><br><span class="line">    &lt;A extends Annotation&gt; A findAnnotationOnBean(String beanName,</span><br><span class="line">            Class&lt;A&gt; annotationType);&#x2F;&#x2F; 根据指定Bean名和注解类型查找指定的Bean</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>具体：<br>　　1、3个跟BeanDefinition有关的总体操作。包括BeanDefinition的总数、名字的集合、指定类型的名字的集合。<br>　　（这里指出，BeanDefinition是Spring中非常重要的一个类，每个BeanDefinition实例都包含一个类在Spring工厂中所有属性。）<br>　　2、2个getBeanNamesForType重载方法。根据指定类型（包括子类）获取其对应的所有Bean名字。<br>　　3、2个getBeansOfType重载方法。根据类型（包括子类）返回指定Bean名和Bean的Map。<br>　　4、2个跟注解查找有关的方法。根据注解类型，查找Bean名和Bean的Map。以及根据指定Bean名和注解类型查找指定的Bean。<br>总结：<br>　　正如这个工厂接口的名字所示，这个工厂接口最大的特点就是可以列出工厂可以生产的所有实例。当然，工厂并没有直接提供返回所有实例的方法，也没这个必要。它可以返回指定类型的所有的实例。而且你可以通过getBeanDefinitionNames()得到工厂所有bean的名字，然后根据这些名字得到所有的Bean。这个工厂接口扩展了BeanFactory的功能，作为上文指出的BeanFactory二级接口，有9个独有的方法，扩展了跟BeanDefinition的功能，提供了BeanDefinition、BeanName、注解有关的各种操作。它可以根据条件返回Bean的集合，这就是它名字的由来——ListableBeanFactory。</p>
<h1 id="四、分层的Bean工厂——HierarchicalBeanFactory"><a href="#四、分层的Bean工厂——HierarchicalBeanFactory" class="headerlink" title="四、分层的Bean工厂——HierarchicalBeanFactory"></a>四、分层的Bean工厂——HierarchicalBeanFactory</h1><p>源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface HierarchicalBeanFactory extends BeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    BeanFactory getParentBeanFactory();    &#x2F;&#x2F;  返回本Bean工厂的父工厂</span><br><span class="line"></span><br><span class="line">    boolean containsLocalBean(String name);    &#x2F;&#x2F;  本地工厂是否包含这个Bean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 具体：<br>　　1、第一个方法返回本Bean工厂的父工厂。这个方法实现了工厂的分层。<br>　　2、第二个方法判断本地工厂是否包含这个Bean（忽略其他所有父工厂）。这也是分层思想的体现。<br>总结：这个工厂接口非常简单，实现了Bean工厂的分层。这个工厂接口也是继承自BeanFacotory，也是一个二级接口，相对于父接口，它只扩展了一个重要的功能——工厂分层。</p>
<h1 id="五、自动装配的Bean工厂——AutowireCapableBeanFactory"><a href="#五、自动装配的Bean工厂——AutowireCapableBeanFactory" class="headerlink" title="五、自动装配的Bean工厂——AutowireCapableBeanFactory"></a>五、自动装配的Bean工厂——AutowireCapableBeanFactory</h1><p>源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public interface AutowireCapableBeanFactory extends BeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    int AUTOWIRE_NO &#x3D; 0;   &#x2F;&#x2F;  这个常量表明工厂没有自动装配的Bean</span><br><span class="line"></span><br><span class="line">    int AUTOWIRE_BY_NAME &#x3D; 1;  &#x2F;&#x2F;表明根据名称自动装配</span><br><span class="line"></span><br><span class="line">    int AUTOWIRE_BY_TYPE &#x3D; 2;  &#x2F;&#x2F;表明根据类型自动装配</span><br><span class="line"></span><br><span class="line">    int AUTOWIRE_CONSTRUCTOR &#x3D; 3;  &#x2F;&#x2F;表明根据构造方法快速装配</span><br><span class="line">    @Deprecated</span><br><span class="line">    int AUTOWIRE_AUTODETECT &#x3D; 4;   &#x2F;&#x2F;表明通过Bean的class的内部来自动装配（有没翻译错...）Spring3.0被弃用。</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T createBean(Class&lt;T&gt; beanClass) throws BeansException;    &#x2F;&#x2F;  根据指定Class创建一个全新的Bean实例</span><br><span class="line"></span><br><span class="line">    void autowireBean(Object existingBean) throws BeansException;  &#x2F;&#x2F;  给定对象，根据注释、后处理器等，进行自动装配</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 根据Bean名的BeanDefinition装配这个未加工的Object，执行回调和各种后处理器。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object configureBean(Object existingBean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 分解Bean在工厂中定义的这个指定的依赖descriptor</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object resolveDependency(DependencyDescriptor descriptor, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 根据给定的类型和指定的装配策略，创建一个新的Bean实例</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object createBean(Class&lt;?&gt; beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 与上面类似，不过稍有不同。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object autowire(Class&lt;?&gt; beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 根据名称或类型自动装配</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)</span><br><span class="line">            throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 也是自动装配</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 初始化一个Bean...</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object initializeBean(Object existingBean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 初始化之前执行BeanPostProcessors</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)</span><br><span class="line">            throws BeansException;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 初始化之后执行BeanPostProcessors</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)</span><br><span class="line">            throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 分解指定的依赖</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object resolveDependency(DependencyDescriptor descriptor, String beanName,</span><br><span class="line">            Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 具体：<br>　　1、总共5个静态不可变常量来指明装配策略，其中一个常量被Spring3.0废弃、一个常量表示没有自动装配，另外3个常量指明不同的装配策略——根据名称、根据类型、根据构造方法。<br>　　2、8个跟自动装配有关的方法，实在是繁杂，具体的意义我们研究类的时候再分辨吧。<br>　　3、2个执行BeanPostProcessors的方法。<br>　　4、2个分解指定依赖的方法<br>总结：这个工厂接口继承自BeanFacotory，它扩展了自动装配的功能，根据类定义BeanDefinition装配Bean、执行前、后处理器等。</p>
<h1 id="六、复杂的配置Bean工厂——ConfigurableBeanFactory"><a href="#六、复杂的配置Bean工厂——ConfigurableBeanFactory" class="headerlink" title="六、复杂的配置Bean工厂——ConfigurableBeanFactory"></a>六、复杂的配置Bean工厂——ConfigurableBeanFactory</h1><p>源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">public interface ConfigurableBeanFactory extends HierarchicalBeanFactory, SingletonBeanRegistry &#123;</span><br><span class="line"></span><br><span class="line">    String SCOPE_SINGLETON &#x3D; &quot;singleton&quot;;  &#x2F;&#x2F;  单例</span><br><span class="line">    String SCOPE_PROTOTYPE &#x3D; &quot;prototype&quot;;  &#x2F;&#x2F;  原型</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 搭配HierarchicalBeanFactory接口的getParentBeanFactory方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void setParentBeanFactory(BeanFactory parentBeanFactory) throws IllegalStateException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 设置、返回工厂的类加载器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void setBeanClassLoader(ClassLoader beanClassLoader);</span><br><span class="line"></span><br><span class="line">    ClassLoader getBeanClassLoader();</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 设置、返回一个临时的类加载器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void setTempClassLoader(ClassLoader tempClassLoader);</span><br><span class="line"></span><br><span class="line">    ClassLoader getTempClassLoader();</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 设置、是否缓存元数据，如果false，那么每次请求实例，都会从类加载器重新加载（热加载）</span><br><span class="line"></span><br><span class="line">     *&#x2F;</span><br><span class="line">    void setCacheBeanMetadata(boolean cacheBeanMetadata);</span><br><span class="line">    </span><br><span class="line">    boolean isCacheBeanMetadata();&#x2F;&#x2F;是否缓存元数据</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Bean表达式分解器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void setBeanExpressionResolver(BeanExpressionResolver resolver);</span><br><span class="line">    </span><br><span class="line">    BeanExpressionResolver getBeanExpressionResolver();</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 设置、返回一个转换服务</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void setConversionService(ConversionService conversionService);</span><br><span class="line"></span><br><span class="line">    ConversionService getConversionService();</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 设置属性编辑登记员...</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void addPropertyEditorRegistrar(PropertyEditorRegistrar registrar);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 注册常用属性编辑器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void registerCustomEditor(Class&lt;?&gt; requiredType, Class&lt;? extends PropertyEditor&gt; propertyEditorClass);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 用工厂中注册的通用的编辑器初始化指定的属性编辑注册器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void copyRegisteredEditorsTo(PropertyEditorRegistry registry);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 设置、得到一个类型转换器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void setTypeConverter(TypeConverter typeConverter);</span><br><span class="line"></span><br><span class="line">    TypeConverter getTypeConverter();</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 增加一个嵌入式的StringValueResolver</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void addEmbeddedValueResolver(StringValueResolver valueResolver);</span><br><span class="line"></span><br><span class="line">    String resolveEmbeddedValue(String value);&#x2F;&#x2F;分解指定的嵌入式的值</span><br><span class="line"></span><br><span class="line">    void addBeanPostProcessor(BeanPostProcessor beanPostProcessor);&#x2F;&#x2F;设置一个Bean后处理器</span><br><span class="line"></span><br><span class="line">    int getBeanPostProcessorCount();&#x2F;&#x2F;返回Bean后处理器的数量</span><br><span class="line"></span><br><span class="line">    void registerScope(String scopeName, Scope scope);&#x2F;&#x2F;注册范围</span><br><span class="line">    String[] getRegisteredScopeNames();&#x2F;&#x2F;返回注册的范围名</span><br><span class="line">    Scope getRegisteredScope(String scopeName);&#x2F;&#x2F;返回指定的范围</span><br><span class="line">    AccessControlContext getAccessControlContext();&#x2F;&#x2F;返回本工厂的一个安全访问上下文</span><br><span class="line"></span><br><span class="line">    void copyConfigurationFrom(ConfigurableBeanFactory otherFactory);&#x2F;&#x2F;从其他的工厂复制相关的所有配置</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 给指定的Bean注册别名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void registerAlias(String beanName, String alias) throws BeanDefinitionStoreException;</span><br><span class="line"></span><br><span class="line">    void resolveAliases(StringValueResolver valueResolver);&#x2F;&#x2F;根据指定的StringValueResolver移除所有的别名</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 返回指定Bean合并后的Bean定义</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BeanDefinition getMergedBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    boolean isFactoryBean(String name) throws NoSuchBeanDefinitionException;&#x2F;&#x2F;判断指定Bean是否为一个工厂Bean</span><br><span class="line"></span><br><span class="line">    void setCurrentlyInCreation(String beanName, boolean inCreation);&#x2F;&#x2F;设置一个Bean是否正在创建</span><br><span class="line"></span><br><span class="line">    boolean isCurrentlyInCreation(String beanName);&#x2F;&#x2F;返回指定Bean是否已经成功创建</span><br><span class="line"></span><br><span class="line">    void registerDependentBean(String beanName, String dependentBeanName);&#x2F;&#x2F;注册一个依赖于指定bean的Bean</span><br><span class="line">    String[] getDependentBeans(String beanName);&#x2F;&#x2F;返回依赖于指定Bean的所欲Bean名</span><br><span class="line">    String[] getDependenciesForBean(String beanName);&#x2F;&#x2F;返回指定Bean依赖的所有Bean名</span><br><span class="line"></span><br><span class="line">    void destroyBean(String beanName, Object beanInstance);&#x2F;&#x2F;销毁指定的Bean</span><br><span class="line"></span><br><span class="line">    void destroyScopedBean(String beanName);&#x2F;&#x2F;销毁指定的范围Bean</span><br><span class="line"></span><br><span class="line">    void destroySingletons();  &#x2F;&#x2F;销毁所有的单例类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在具体介绍之前，先看一下接口SingletonBeanRegistry的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface SingletonBeanRegistry &#123;</span><br><span class="line"></span><br><span class="line">    void registerSingleton(String beanName, Object singletonObject); &#x2F;&#x2F;在容器内注册一个单例类      </span><br><span class="line">    Object getSingleton(String beanName);&#x2F;&#x2F;返回给定名称对应的单例类</span><br><span class="line"></span><br><span class="line">    boolean containsSingleton(String beanName);&#x2F;&#x2F;给定名称是否对应单例类</span><br><span class="line">    String[] getSingletonNames();&#x2F;&#x2F;返回容器内所有单例类的名字</span><br><span class="line"></span><br><span class="line">    int getSingletonCount();&#x2F;&#x2F;返回容器内注册的单例类数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以看到，SingletonBeanRegistry这个接口非常简单，5个方法，实现了单例类注册的功能。<br>ConfigurableBeanFactory同时继承了HierarchicalBeanFactory 和 SingletonBeanRegistry 这两个接口，即同时继承了分层和单例类注册的功能。<br>具体：<br>　　1、2个静态不可变常量分别代表单例类和原型类。<br>　　2、1个设置父工厂的方法，跟HierarchicalBeanFactory接口的getParentBeanFactory方法互补。<br>　　3、4个跟类加载器有关的方法：get/set工厂类加载器和get/set临时类加载器。<br>　　4、2个设置、是否缓存元数据的方法（热加载开关）。<br>　　5、11个处理Bean注册、加载等细节的方法，包括：Bean表达式分解器、转换服务、属性编辑登记员、属性编辑器、属性编辑注册器、类型转换器、嵌入式的字符串分解器<br>　　6、2个处理Bean后处理器的方法。<br>　　7、3个跟注册范围相关的方法。<br>　　8、1个返回安全访问上下文的方法、1个从其他的工厂复制相关的所有配置的方法。<br>　　9、2个跟Bean别名相关的方法、1个返回合并后的Bean定义的方法。<br>　　10、1个判断是否为工厂Bean的方法、2个跟当前Bean创建时机相关的方法。<br>　　11、3个跟Bean依赖相关的方法、3个销毁Bean相关的方法。<br>总结：这个巨大的工厂接口，继承自HierarchicalBeanFactory 和 SingletonBeanRegistry 这两个接口，并额外独有37个方法！！！（看的我都快疯了…）这37个方法包含了工厂创建、注册一个Bean的众多细节。这个工厂名为ConfigurableBeanFactory，真是名不虚传！统计一下此时的ConfigurableBeanFactory的方法数吧。自有的37个方法、HierarchicalBeanFactory的2个方法、SingletonBeanRegistry的5个方法、爷爷接口BeanFactory的10个方法，共有54个方法！虽然方法繁多，还算井井有条！</p>
<h1 id="七、BeanFactory的集大成者——ConfigurableListableBeanFactory"><a href="#七、BeanFactory的集大成者——ConfigurableListableBeanFactory" class="headerlink" title="七、BeanFactory的集大成者——ConfigurableListableBeanFactory"></a>七、BeanFactory的集大成者——ConfigurableListableBeanFactory</h1><p>源码：　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public interface ConfigurableListableBeanFactory</span><br><span class="line">        extends ListableBeanFactory, AutowireCapableBeanFactory, ConfigurableBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    void ignoreDependencyType(Class&lt;?&gt; type);&#x2F;&#x2F;忽略自动装配的依赖类型</span><br><span class="line"></span><br><span class="line">    void ignoreDependencyInterface(Class&lt;?&gt; ifc);&#x2F;&#x2F;忽略自动装配的接口</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 注册一个可分解的依赖</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void registerResolvableDependency(Class&lt;?&gt; dependencyType, Object autowiredValue);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 判断指定的Bean是否有资格作为自动装配的候选者</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)</span><br><span class="line">            throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 返回注册的Bean定义</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    void freezeConfiguration();&#x2F;&#x2F;暂时冻结所有的Bean配置</span><br><span class="line"></span><br><span class="line">    boolean isConfigurationFrozen();&#x2F;&#x2F;判断本工厂配置是否被冻结</span><br><span class="line"></span><br><span class="line">    void preInstantiateSingletons() throws BeansException;&#x2F;&#x2F;使所有的非延迟加载的单例类都实例化。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 具体：<br>　　1、2个忽略自动装配的的方法。<br>　　2、1个注册一个可分解依赖的方法。<br>　　3、1个判断指定的Bean是否有资格作为自动装配的候选者的方法。<br>　　4、1个根据指定bean名，返回注册的Bean定义的方法。<br>　　5、2个冻结所有的Bean配置相关的方法。<br>　　6、1个使所有的非延迟加载的单例类都实例化的方法。<br>总结：工厂接口ConfigurableListableBeanFactory同时继承了3个接口，ListableBeanFactory、AutowireCapableBeanFactory 和 ConfigurableBeanFactory，扩展之后，加上自有的这8个方法，这个工厂接口总共有83个方法，实在是巨大到不行了。这个工厂接口的自有方法总体上只是对父类接口功能的补充，包含了BeanFactory体系目前的所有方法，可以说是接口的集大成者。</p>
<h1 id="八、额外的接口——BeanDefinitionRegistry"><a href="#八、额外的接口——BeanDefinitionRegistry" class="headerlink" title="八、额外的接口——BeanDefinitionRegistry"></a>八、额外的接口——BeanDefinitionRegistry</h1><p>这个接口基本用来操作定义在工厂内部的BeanDefinition的。我们先来看一下这个接口的父接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface AliasRegistry &#123;</span><br><span class="line"></span><br><span class="line">    void registerAlias(String name, String alias);&#x2F;&#x2F;对指定的名称注册别名</span><br><span class="line"></span><br><span class="line">    void removeAlias(String alias);&#x2F;&#x2F;从当前容器移除指定别名</span><br><span class="line"></span><br><span class="line">    boolean isAlias(String beanName);&#x2F;&#x2F;判断指定名称是否为别名</span><br><span class="line">    String[] getAliases(String name);&#x2F;&#x2F;返回指定名称的所有别名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以看到这4个方法都非常简单，都是用来操作别名的。<br>再来看一下BeanDefinitionRegistry的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanDefinitionRegistry extends AliasRegistry &#123;</span><br><span class="line"></span><br><span class="line">    void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">            throws BeanDefinitionStoreException;&#x2F;&#x2F;给定bean名称，注册一个新的bean定义</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 根据指定Bean名移除对应的Bean定义</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 根据指定bean名得到对应的Bean定义</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 查找，指定的Bean名是否包含Bean定义</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean containsBeanDefinition(String beanName);</span><br><span class="line"></span><br><span class="line">    String[] getBeanDefinitionNames();&#x2F;&#x2F;返回本容器内所有注册的Bean定义名称</span><br><span class="line"></span><br><span class="line">    int getBeanDefinitionCount();&#x2F;&#x2F;返回本容器内注册的Bean定义数目</span><br><span class="line"></span><br><span class="line">    boolean isBeanNameInUse(String beanName);&#x2F;&#x2F;指定Bean名是否被注册过。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这7个方法都是用来操作容器内的BeanDefinition的。</p>
<h1 id="一、BeanFactory的基本类体系结构（类为主）："><a href="#一、BeanFactory的基本类体系结构（类为主）：" class="headerlink" title="一、BeanFactory的基本类体系结构（类为主）："></a>一、BeanFactory的基本类体系结构（类为主）：</h1><p><img src="https://img-blog.csdnimg.cn/20200331222848572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　　上图可与 Spring源码分析——BeanFactory体系之接口详细分析 的图结合分析，一个以接口为主，一个以类为主（PS：Spring的体系结构要分析清楚，不得不曲线救国啊！不然27寸屏幕给我画估计都装不下。）。</p>
<p>具体：</p>
<p>　　1、7层的类体系继承。</p>
<p>　　2、AbstractBeanFactory实现了最重要的ConfigurableBeanFactory接口，DefaultSingletonBeanRegistry实现了SingletonBeanRegistry单例类注册接口，SimpleAliasRegistry实现了AliasRegistry别名注册接口。</p>
<p>　　3、祖先类SimpleAliasRegistry、DefaultSingletonBeanRegistry和子孙类XmlBeanFactory、DefaultListableBeanFactory是完整的类，而中间的类FactoryBeanRegistrySupport、AbstractBeanFactory、AbstractAutowireCapableBeanFactory都是抽象类。</p>
<p>总结：</p>
<p>　　具体上来说，XmlBeanFactory光是父类就有6个了，加上自身，总共7层了。实际上分析接口结构就会看到，作为IOC类工厂而言，XmlBeanFactory的类体系结构实际是从祖先AbstractBeanFactory这个类开始的，因为是它实现了BeanFactory的子接口ConfigurableBeanFactory，虽然它继承自FactoryBeanRegistrySupport，但可以说这只是工厂功能的扩充，扩展了对工厂Bean以及工厂所产生的Bean的操作。</p>
<h1 id="二、简单的别名注册器——SimpleAliasRegistry"><a href="#二、简单的别名注册器——SimpleAliasRegistry" class="headerlink" title="二、简单的别名注册器——SimpleAliasRegistry"></a>二、简单的别名注册器——SimpleAliasRegistry</h1><p>　　上篇已经讲过AliasRegistry，非常简单的4个方法，体现了对别名注册的支持，而SimpleAliasRegistry就是它的简单实现。</p>
<p>源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleAliasRegistry implements AliasRegistry &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     *用一个支持高并发的ConcurrentHashMap来放置所有的别名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final Map&lt;String, String&gt; aliasMap &#x3D; new ConcurrentHashMap&lt;String, String&gt;(</span><br><span class="line">            16);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; AliasRegistry的接口方法，注册别名。不允许重复注册。</span><br><span class="line">    public void registerAlias(String name, String alias) &#123;</span><br><span class="line">        Assert.hasText(name, &quot;&#39;name&#39; must not be empty&quot;);</span><br><span class="line">        Assert.hasText(alias, &quot;&#39;alias&#39; must not be empty&quot;);</span><br><span class="line">        if (alias.equals(name)) &#123;</span><br><span class="line">            this.aliasMap.remove(alias);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (!allowAliasOverriding()) &#123;</span><br><span class="line">                String registeredName &#x3D; this.aliasMap.get(alias);</span><br><span class="line">                if (registeredName !&#x3D; null &amp;&amp; !registeredName.equals(name)) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;Cannot register alias &#39;&quot;</span><br><span class="line">                            + alias + &quot;&#39; for name &#39;&quot; + name</span><br><span class="line">                            + &quot;&#39;: It is already registered for name &#39;&quot;</span><br><span class="line">                            + registeredName + &quot;&#39;.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            checkForAliasCircle(name, alias);&#x2F;&#x2F;alias不能等于name在map中最后的对应（详见checkForAliasCircle方法）</span><br><span class="line">            this.aliasMap.put(alias, name);&#x2F;&#x2F;alias是key,name是value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回是否允许Alias重写，默认为允许</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean allowAliasOverriding() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; AliasRegistry的接口方法，移除别名，如果别名未注册，则抛出异常</span><br><span class="line">    public void removeAlias(String alias) &#123;</span><br><span class="line">        String name &#x3D; this.aliasMap.remove(alias);</span><br><span class="line">        if (name &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;No alias &#39;&quot; + alias</span><br><span class="line">                    + &quot;&#39; registered&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; AliasRegistry的接口方法，给定名称判断是否为别名</span><br><span class="line">    public boolean isAlias(String name) &#123;</span><br><span class="line">        return this.aliasMap.containsKey(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; AliasRegistry的接口方法</span><br><span class="line">    public String[] getAliases(String name) &#123;</span><br><span class="line">        List&lt;String&gt; result &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        synchronized (this.aliasMap) &#123;</span><br><span class="line">            retrieveAliases(name, result);</span><br><span class="line">        &#125;</span><br><span class="line">        return StringUtils.toStringArray(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 找出名字说对应的所有别名。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void retrieveAliases(String name, List&lt;String&gt; result) &#123;</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : this.aliasMap.entrySet()) &#123;&#x2F;&#x2F;遍历aliasMap</span><br><span class="line">            String registeredName &#x3D; entry.getValue();&#x2F;&#x2F;取aliasMap的每个value</span><br><span class="line">            if (registeredName.equals(name)) &#123;&#x2F;&#x2F;如果value等于指定的这个name</span><br><span class="line">                String alias &#x3D; entry.getKey();&#x2F;&#x2F;取value对应的key</span><br><span class="line">                result.add(alias);&#x2F;&#x2F;将alias加入</span><br><span class="line">                retrieveAliases(alias, result);&#x2F;&#x2F;继续查看以alias为value的key</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 处理所有的别名，如果处理正确，把原来的用解析后的替换</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void resolveAliases(StringValueResolver valueResolver) &#123;</span><br><span class="line">        Assert.notNull(valueResolver, &quot;StringValueResolver must not be null&quot;);</span><br><span class="line">        synchronized (this.aliasMap) &#123;</span><br><span class="line">            Map&lt;String, String&gt; aliasCopy &#x3D; new HashMap&lt;String, String&gt;(</span><br><span class="line">                    this.aliasMap);</span><br><span class="line">            for (String alias : aliasCopy.keySet()) &#123;</span><br><span class="line">                String registeredName &#x3D; aliasCopy.get(alias);&#x2F;&#x2F;取出key对应的value</span><br><span class="line">                String resolvedAlias &#x3D; valueResolver.resolveStringValue(alias);&#x2F;&#x2F;解析后的key</span><br><span class="line">                String resolvedName &#x3D; valueResolver</span><br><span class="line">                        .resolveStringValue(registeredName);&#x2F;&#x2F;解析后的value</span><br><span class="line">                if (resolvedAlias.equals(resolvedName)) &#123;&#x2F;&#x2F;若解析后的key、name相等，就把它们从aliasMap中移除</span><br><span class="line">                    this.aliasMap.remove(alias);</span><br><span class="line">                &#125; else if (!resolvedAlias.equals(alias)) &#123;&#x2F;&#x2F;若解析后的key不等于原来的Key</span><br><span class="line">                    String existingName &#x3D; this.aliasMap.get(resolvedAlias);&#x2F;&#x2F;取出解析后的key对应的value</span><br><span class="line">                    if (existingName !&#x3D; null&#x2F;&#x2F;如果不为空且不等于解析后的value，就抛出异常</span><br><span class="line">                            &amp;&amp; !existingName.equals(resolvedName)) &#123;</span><br><span class="line">                        throw new IllegalStateException(</span><br><span class="line">                                &quot;Cannot register resolved alias &#39;&quot;</span><br><span class="line">                                        + resolvedAlias</span><br><span class="line">                                        + &quot;&#39; (original: &#39;&quot;</span><br><span class="line">                                        + alias</span><br><span class="line">                                        + &quot;&#39;) for name &#39;&quot;</span><br><span class="line">                                        + resolvedName</span><br><span class="line">                                        + &quot;&#39;: It is already registered for name &#39;&quot;</span><br><span class="line">                                        + registeredName + &quot;&#39;.&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    checkForAliasCircle(resolvedName, resolvedAlias);</span><br><span class="line">                    this.aliasMap.remove(alias);</span><br><span class="line">                    this.aliasMap.put(resolvedAlias, resolvedName);</span><br><span class="line">                &#125; else if (!registeredName.equals(resolvedName)) &#123;</span><br><span class="line">                    this.aliasMap.put(alias, resolvedName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 根据name这个Key，在aliasMap中不断循环的取对应的value，如果取得到，就继续根据这个value取值，不断循环继续。</span><br><span class="line">     * 直到取不到，就把这个在aliasMap中无对应值的key返回。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String canonicalName(String name) &#123;</span><br><span class="line">        String canonicalName &#x3D; name;    &#x2F;&#x2F;规范名</span><br><span class="line">        &#x2F;&#x2F; Handle aliasing...</span><br><span class="line">        String resolvedName;&#x2F;&#x2F;已解析名</span><br><span class="line">        do &#123;</span><br><span class="line">            resolvedName &#x3D; this.aliasMap.get(canonicalName);&#x2F;&#x2F;aliasMap中规范名对应的值赋值给已解析名</span><br><span class="line">            if (resolvedName !&#x3D; null) &#123;&#x2F;&#x2F;如果已解析名存在（即规范名在aliasMap中有对应的值）</span><br><span class="line">                canonicalName &#x3D; resolvedName;   &#x2F;&#x2F; 这个已解析名赋值给标准名</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (resolvedName !&#x3D; null);&#x2F;&#x2F;不断循环，直到已解析名不存在</span><br><span class="line">        return canonicalName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 如果别名alias等于canonicalName(name)就抛出异常</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void checkForAliasCircle(String name, String alias) &#123;</span><br><span class="line">        if (alias.equals(canonicalName(name))) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Cannot register alias &#39;&quot; + alias</span><br><span class="line">                    + &quot;&#39; for name &#39;&quot; + name + &quot;&#39;: Circular reference - &#39;&quot;</span><br><span class="line">                    + name + &quot;&#39; is a direct or indirect alias for &#39;&quot; + alias</span><br><span class="line">                    + &quot;&#39; already&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 具体：</p>
<p>　　1、1个支持高并发的ConcurrentHashMap来放置所有的别名，其中key是别名，value是真名。</p>
<p>　　2、4个方法实现了SimpleAliasRegistry。</p>
<p>　　3、3个用来辅助实现4个接口方法的方法。其中canonicalName(String name)的实现非常优雅，用来循环来回判断，把aliasMap中无对应值的key返回。</p>
<p>　　4、2个添加额外功能的方法 retrieveAliases 和 resolveAliases ，前者是找出名字对应的所有别名，后者是用一个StringValueResolver处理解析所有的别名-名称。</p>
<p>总结：</p>
<p>　　这是一个非常简单的别名注册器，一个简单的接口实现。不过其中包含了非常优雅的方法实现，值得一看！</p>
<h1 id="三、默认单例注册类——DefaultSingletonBeanRegistry"><a href="#三、默认单例注册类——DefaultSingletonBeanRegistry" class="headerlink" title="三、默认单例注册类——DefaultSingletonBeanRegistry"></a>三、默认单例注册类——DefaultSingletonBeanRegistry</h1><p>源码：　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry &#123;</span><br><span class="line"></span><br><span class="line">    protected static final Object NULL_OBJECT &#x3D; new Object();&#x2F;&#x2F;空object</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;** Logger available to subclasses *&#x2F;</span><br><span class="line">    protected final Log logger &#x3D; LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    &#x2F;** 单例缓存: bean name --&gt; bean instance *&#x2F;</span><br><span class="line">    private final Map&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;String, Object&gt;(64);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 单例工厂缓存: bean name --&gt; ObjectFactory *&#x2F;</span><br><span class="line">    private final Map&lt;String, ObjectFactory&gt; singletonFactories &#x3D; new HashMap&lt;String, ObjectFactory&gt;(16);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 早期单例对象缓存: bean name --&gt; bean instance *&#x2F;</span><br><span class="line">    private final Map&lt;String, Object&gt; earlySingletonObjects &#x3D; new HashMap&lt;String, Object&gt;(16);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 注册过的单例类（单例工厂） *&#x2F;</span><br><span class="line">    private final Set&lt;String&gt; registeredSingletons &#x3D; new LinkedHashSet&lt;String&gt;(64);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 即将创建的单例类 (using a ConcurrentHashMap as a Set) *&#x2F;</span><br><span class="line">    private final Map&lt;String, Boolean&gt; singletonsCurrentlyInCreation &#x3D; new ConcurrentHashMap&lt;String, Boolean&gt;(16);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 正在创建的单例类 (using a ConcurrentHashMap as a Set) *&#x2F;</span><br><span class="line">    private final Map&lt;String, Boolean&gt; inCreationCheckExclusions &#x3D; new ConcurrentHashMap&lt;String, Boolean&gt;(16);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 被压制的异常集合 *&#x2F;</span><br><span class="line">    private Set&lt;Exception&gt; suppressedExceptions;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 单例类是否真正被销毁 *&#x2F;</span><br><span class="line">    private boolean singletonsCurrentlyInDestruction &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Disposable接口的实例: bean name --&gt; disposable instance *&#x2F;</span><br><span class="line">    private final Map&lt;String, Object&gt;   &#x3D; new LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;** bean名称和bean所有包含的Bean的名称的map: bean name --&gt; Set of bean names that the bean contains *&#x2F;</span><br><span class="line">    private final Map&lt;String, Set&lt;String&gt;&gt; containedBeanMap &#x3D; new ConcurrentHashMap&lt;String, Set&lt;String&gt;&gt;(16);</span><br><span class="line"></span><br><span class="line">    &#x2F;** bean名称和所有依赖于Bean的名称的map: bean name --&gt; Set of dependent bean names *&#x2F;</span><br><span class="line">    private final Map&lt;String, Set&lt;String&gt;&gt; dependentBeanMap &#x3D; new ConcurrentHashMap&lt;String, Set&lt;String&gt;&gt;(64);</span><br><span class="line"></span><br><span class="line">    &#x2F;** bean名称和bean所依赖的所有名称的map --&gt; Set of bean names for the bean&#39;s dependencies *&#x2F;</span><br><span class="line">    private final Map&lt;String, Set&lt;String&gt;&gt; dependenciesForBeanMap &#x3D; new ConcurrentHashMap&lt;String, Set&lt;String&gt;&gt;(64);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;SingletonBeanRegistry接口的实现类————注册单例Bean，不能重复注册</span><br><span class="line">    public void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException &#123;</span><br><span class="line">        Assert.notNull(beanName, &quot;&#39;beanName&#39; must not be null&quot;);</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            Object oldObject &#x3D; this.singletonObjects.get(beanName);</span><br><span class="line">            if (oldObject !&#x3D; null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;Could not register object [&quot; + singletonObject +</span><br><span class="line">                        &quot;] under bean name &#39;&quot; + beanName + &quot;&#39;: there is already object [&quot; + oldObject + &quot;] bound&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            addSingleton(beanName, singletonObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;注册一个单例类，注册之后，从singletonFactories、earlySingletonObjects中删去</span><br><span class="line">    protected void addSingleton(String beanName, Object singletonObject) &#123;</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            this.singletonObjects.put(beanName, (singletonObject !&#x3D; null ? singletonObject : NULL_OBJECT));</span><br><span class="line">            this.singletonFactories.remove(beanName);</span><br><span class="line">            this.earlySingletonObjects.remove(beanName);&#x2F;&#x2F;</span><br><span class="line">            this.registeredSingletons.add(beanName);&#x2F;&#x2F;加入，注册过的单例类集合</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;注册一个单例工厂类，注册后从earlySingletonObjects移除</span><br><span class="line">    protected void addSingletonFactory(String beanName, ObjectFactory singletonFactory) &#123;</span><br><span class="line">        Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;);</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            if (!this.singletonObjects.containsKey(beanName)) &#123;    &#x2F;&#x2F;单例工厂类不能和单例类同名</span><br><span class="line">                this.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">                this.earlySingletonObjects.remove(beanName);</span><br><span class="line">                this.registeredSingletons.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;SingletonBeanRegistry接口的实现类</span><br><span class="line">    public Object getSingleton(String beanName) &#123;</span><br><span class="line">        return getSingleton(beanName, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据beanName返回单例类</span><br><span class="line">    protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">        Object singletonObject &#x3D; this.singletonObjects.get(beanName);</span><br><span class="line">        if (singletonObject &#x3D;&#x3D; null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;    &#x2F;&#x2F;    如果取不到，且该bean正在创建</span><br><span class="line">            synchronized (this.singletonObjects) &#123;</span><br><span class="line">                singletonObject &#x3D; this.earlySingletonObjects.get(beanName);</span><br><span class="line">                if (singletonObject &#x3D;&#x3D; null &amp;&amp; allowEarlyReference) &#123;    &#x2F;&#x2F;    如果从早期单例缓存中获取不到，且允许早期引用</span><br><span class="line">                    ObjectFactory singletonFactory &#x3D; this.singletonFactories.get(beanName);    &#x2F;&#x2F;    那么就从单例工厂缓存中获取单例工厂</span><br><span class="line">                    if (singletonFactory !&#x3D; null) &#123;    &#x2F;&#x2F;    如果还是获取不到，就创建一个单例工厂，并把它放进早期单例缓存中，并返回</span><br><span class="line">                        singletonObject &#x3D; singletonFactory.getObject();</span><br><span class="line">                        this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                        this.singletonFactories.remove(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (singletonObject !&#x3D; NULL_OBJECT ? singletonObject : null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取指定的单例Bean，如果取不到就调用指定的singletonFactory的getObject来返回</span><br><span class="line">    public Object getSingleton(String beanName, ObjectFactory singletonFactory) &#123;</span><br><span class="line">        Assert.notNull(beanName, &quot;&#39;beanName&#39; must not be null&quot;);</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            Object singletonObject &#x3D; this.singletonObjects.get(beanName);&#x2F;&#x2F;从单例缓存中获取</span><br><span class="line">            if (singletonObject &#x3D;&#x3D; null) &#123;</span><br><span class="line">                if (this.singletonsCurrentlyInDestruction) &#123;&#x2F;&#x2F;如果单例类正在被销毁，就抛出异常</span><br><span class="line">                    throw new BeanCreationNotAllowedException(beanName,</span><br><span class="line">                            &quot;Singleton bean creation not allowed while the singletons of this factory are in destruction &quot; +</span><br><span class="line">                            &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Creating shared instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;如果不在inCreationCheckExclusions中，且可以向singletonsCurrentlyInCreation中添加，就抛出异常</span><br><span class="line">                beforeSingletonCreation(beanName);</span><br><span class="line">                &#x2F;&#x2F;是否有记录被压制的异常</span><br><span class="line">                boolean recordSuppressedExceptions &#x3D; (this.suppressedExceptions &#x3D;&#x3D; null);</span><br><span class="line">                if (recordSuppressedExceptions) &#123;&#x2F;&#x2F;如果没有记录，即没有被压制的异常，就创建被压制的异常容器</span><br><span class="line">                    this.suppressedExceptions &#x3D; new LinkedHashSet&lt;Exception&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    singletonObject &#x3D; singletonFactory.getObject();&#x2F;&#x2F;以上都没有异常产生，那么就从指定的facgtory中取</span><br><span class="line">                &#125;</span><br><span class="line">                catch (BeanCreationException ex) &#123;</span><br><span class="line">                    if (recordSuppressedExceptions) &#123;</span><br><span class="line">                        for (Exception suppressedException : this.suppressedExceptions) &#123;</span><br><span class="line">                            ex.addRelatedCause(suppressedException);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    throw ex;</span><br><span class="line">                &#125;</span><br><span class="line">                finally &#123;</span><br><span class="line">                    if (recordSuppressedExceptions) &#123;</span><br><span class="line">                        this.suppressedExceptions &#x3D; null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    afterSingletonCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                addSingleton(beanName, singletonObject);&#x2F;&#x2F;取成功就放进singletonObjects中</span><br><span class="line">            &#125;</span><br><span class="line">            return (singletonObject !&#x3D; NULL_OBJECT ? singletonObject : null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加一个被压制的异常</span><br><span class="line">    protected void onSuppressedException(Exception ex) &#123;</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            if (this.suppressedExceptions !&#x3D; null) &#123;</span><br><span class="line">                this.suppressedExceptions.add(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据名称移除本容器中缓存的对应的单例Bean，把对应的单例从Bean集合、单例工厂集合、早期单例对象集合、注册过的单例集合都统统移除</span><br><span class="line">    protected void removeSingleton(String beanName) &#123;</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            this.singletonObjects.remove(beanName);</span><br><span class="line">            this.singletonFactories.remove(beanName);</span><br><span class="line">            this.earlySingletonObjects.remove(beanName);</span><br><span class="line">            this.registeredSingletons.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;SingletonBeanRegistry接口的实现类</span><br><span class="line">    public boolean containsSingleton(String beanName) &#123;</span><br><span class="line">        return (this.singletonObjects.containsKey(beanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;SingletonBeanRegistry接口的实现类</span><br><span class="line">    public String[] getSingletonNames() &#123;</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            return StringUtils.toStringArray(this.registeredSingletons);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;SingletonBeanRegistry接口的实现类</span><br><span class="line">    public int getSingletonCount() &#123;</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            return this.registeredSingletons.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置某个Bean是否正在创建</span><br><span class="line">    public void setCurrentlyInCreation(String beanName, boolean inCreation) &#123;</span><br><span class="line">        Assert.notNull(beanName, &quot;Bean name must not be null&quot;);</span><br><span class="line">        if (!inCreation) &#123;</span><br><span class="line">            this.inCreationCheckExclusions.put(beanName, Boolean.TRUE);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            this.inCreationCheckExclusions.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断某个Bean是否正在被创建</span><br><span class="line">    public boolean isCurrentlyInCreation(String beanName) &#123;</span><br><span class="line">        Assert.notNull(beanName, &quot;Bean name must not be null&quot;);</span><br><span class="line">        return (!this.inCreationCheckExclusions.containsKey(beanName) &amp;&amp; isActuallyInCreation(beanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected boolean isActuallyInCreation(String beanName) &#123;</span><br><span class="line">        return isSingletonCurrentlyInCreation(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;是否即将被创建</span><br><span class="line">    public boolean isSingletonCurrentlyInCreation(String beanName) &#123;</span><br><span class="line">        return this.singletonsCurrentlyInCreation.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;单例类创建开始之前调用</span><br><span class="line">    &#x2F;&#x2F;如果不在正在创建的单例类集合中，且可以向即将创建的单例类中添加，就抛出异常</span><br><span class="line">    protected void beforeSingletonCreation(String beanName) &#123;</span><br><span class="line">        if (!this.inCreationCheckExclusions.containsKey(beanName) &amp;&amp;</span><br><span class="line">                this.singletonsCurrentlyInCreation.put(beanName, Boolean.TRUE) !&#x3D; null) &#123;</span><br><span class="line">            throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;单例类创建之后调用</span><br><span class="line">    &#x2F;&#x2F;如果不在正在创建的单例类中，也不在即将创建的单例类中移除失败，就抛出异常</span><br><span class="line">    protected void afterSingletonCreation(String beanName) &#123;</span><br><span class="line">        if (!this.inCreationCheckExclusions.containsKey(beanName) &amp;&amp;</span><br><span class="line">                !this.singletonsCurrentlyInCreation.remove(beanName)) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Singleton &#39;&quot; + beanName + &quot;&#39; isn&#39;t currently in creation&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;往Disposable实例集合注册Disposable实例</span><br><span class="line">    public void registerDisposableBean(String beanName, DisposableBean bean) &#123;</span><br><span class="line">        synchronized (this.disposableBeans) &#123;</span><br><span class="line">            this.disposableBeans.put(beanName, bean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;注册一个被包含的Bean和一个包含它的Bean（子-&gt;父）</span><br><span class="line">    public void registerContainedBean(String containedBeanName, String containingBeanName) &#123;</span><br><span class="line">        synchronized (this.containedBeanMap) &#123;</span><br><span class="line">            Set&lt;String&gt; containedBeans &#x3D; this.containedBeanMap.get(containingBeanName);</span><br><span class="line">            if (containedBeans &#x3D;&#x3D; null) &#123;</span><br><span class="line">                containedBeans &#x3D; new LinkedHashSet&lt;String&gt;(8);&#x2F;&#x2F;containedBeans的初始容量为8</span><br><span class="line">                this.containedBeanMap.put(containingBeanName, containedBeans);&#x2F;&#x2F;注意！containedBeanMap的Key是父bean，value是其所包含的所有子Bean（父-&gt;子）</span><br><span class="line">            &#125;</span><br><span class="line">            containedBeans.add(containedBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        registerDependentBean(containedBeanName, containingBeanName);&#x2F;&#x2F;因为包含也是依赖的一种，所以此时也要注册在dependentBeanMap中</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;给指定的Bean注册一个其依赖的Bean</span><br><span class="line">    public void registerDependentBean(String beanName, String dependentBeanName) &#123;</span><br><span class="line">        String canonicalName &#x3D; canonicalName(beanName);&#x2F;&#x2F;在aliasMap中取规范名</span><br><span class="line">        synchronized (this.dependentBeanMap) &#123;    &#x2F;&#x2F;    这里是注册依赖BeanMap，key是bean的名称，value是依赖这个bean的所有bean的名称</span><br><span class="line">            Set&lt;String&gt; dependentBeans &#x3D; this.dependentBeanMap.get(canonicalName);</span><br><span class="line">            if (dependentBeans &#x3D;&#x3D; null) &#123;</span><br><span class="line">                dependentBeans &#x3D; new LinkedHashSet&lt;String&gt;(8);&#x2F;&#x2F;dependentBeans的初始容量也为8</span><br><span class="line">                this.dependentBeanMap.put(canonicalName, dependentBeans);&#x2F;&#x2F;dependentBeanMap中Key为beanName的规范名，value是依赖它的所有Bean的名称</span><br><span class="line">            &#125;</span><br><span class="line">            dependentBeans.add(dependentBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (this.dependenciesForBeanMap) &#123;    &#x2F;&#x2F;    这里相反，注册的是某个Bean和其所依赖的Bean的集合，key是这个beanName，value是这个Bean的依赖的所有Bean的Name</span><br><span class="line">            Set&lt;String&gt; dependenciesForBean &#x3D; this.dependenciesForBeanMap.get(dependentBeanName);</span><br><span class="line">            if (dependenciesForBean &#x3D;&#x3D; null) &#123;</span><br><span class="line">                dependenciesForBean &#x3D; new LinkedHashSet&lt;String&gt;(8);</span><br><span class="line">                this.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);</span><br><span class="line">            &#125;</span><br><span class="line">            dependenciesForBean.add(canonicalName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断某个Bean是否被其他Bean所依赖</span><br><span class="line">    protected boolean hasDependentBean(String beanName) &#123;</span><br><span class="line">        return this.dependentBeanMap.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回依赖于给定Bean的Bean名称的集合</span><br><span class="line">    public String[] getDependentBeans(String beanName) &#123;</span><br><span class="line">        Set&lt;String&gt; dependentBeans &#x3D; this.dependentBeanMap.get(beanName);</span><br><span class="line">        if (dependentBeans &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return new String[0];</span><br><span class="line">        &#125;</span><br><span class="line">        return StringUtils.toStringArray(dependentBeans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回某个Bean所依赖的所有Bean的名称</span><br><span class="line">    public String[] getDependenciesForBean(String beanName) &#123;</span><br><span class="line">        Set&lt;String&gt; dependenciesForBean &#x3D; this.dependenciesForBeanMap.get(beanName);</span><br><span class="line">        if (dependenciesForBean &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return new String[0];</span><br><span class="line">        &#125;</span><br><span class="line">        return dependenciesForBean.toArray(new String[dependenciesForBean.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;这个方法居然连注释都没有？太奇怪了！</span><br><span class="line">    public void destroySingletons() &#123;</span><br><span class="line">        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(&quot;Destroying singletons in &quot; + this);</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (this.singletonObjects) &#123;&#x2F;&#x2F;首先标记，所有的单例Bean正在被销毁，那么getSingleton就无法获得单例Bean了</span><br><span class="line">            this.singletonsCurrentlyInDestruction &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] disposableBeanNames;</span><br><span class="line">        synchronized (this.disposableBeans) &#123;&#x2F;&#x2F;然后把所有的disposableBean都放进数组，一个个按名称销毁</span><br><span class="line">            disposableBeanNames &#x3D; StringUtils.toStringArray(this.disposableBeans.keySet());</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; disposableBeanNames.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            destroySingleton(disposableBeanNames[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;    把本容器的所有的包含关系、依赖关系、被依赖关系的集合全部清空</span><br><span class="line">        this.containedBeanMap.clear();</span><br><span class="line">        this.dependentBeanMap.clear();</span><br><span class="line">        this.dependenciesForBeanMap.clear();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;然后把本容器的所有其他集合全部清空</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            this.singletonObjects.clear();</span><br><span class="line">            this.singletonFactories.clear();</span><br><span class="line">            this.earlySingletonObjects.clear();</span><br><span class="line">            this.registeredSingletons.clear();</span><br><span class="line">            this.singletonsCurrentlyInDestruction &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;销毁某个单例Bean</span><br><span class="line">    public void destroySingleton(String beanName) &#123;</span><br><span class="line">        &#x2F;&#x2F; Remove a registered singleton of the given name, if any.</span><br><span class="line">        removeSingleton(beanName);&#x2F;&#x2F;先把它销毁</span><br><span class="line"></span><br><span class="line">        DisposableBean disposableBean;&#x2F;&#x2F;它相应的DisposableBean实例</span><br><span class="line">        synchronized (this.disposableBeans) &#123;</span><br><span class="line">            disposableBean &#x3D; (DisposableBean) this.disposableBeans.remove(beanName);&#x2F;&#x2F;从disposableBeans移除这个实例</span><br><span class="line">        &#125;</span><br><span class="line">        destroyBean(beanName, disposableBean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 销毁指定名称的Bean，且销毁依赖于它的所有Bean</span><br><span class="line">    protected void destroyBean(String beanName, DisposableBean bean) &#123;</span><br><span class="line">        &#x2F;&#x2F; 首先销毁依赖它的所有Bean</span><br><span class="line">        Set&lt;String&gt; dependencies &#x3D; this.dependentBeanMap.remove(beanName);&#x2F;&#x2F;取依赖于指定Bean的所有Bean</span><br><span class="line">        if (dependencies !&#x3D; null) &#123;</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Retrieved dependent beans for bean &#39;&quot; + beanName + &quot;&#39;: &quot; + dependencies);</span><br><span class="line">            &#125;</span><br><span class="line">            for (String dependentBeanName : dependencies) &#123;</span><br><span class="line">                destroySingleton(dependentBeanName);&#x2F;&#x2F;一个个销毁</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 然后销毁它</span><br><span class="line">        if (bean !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                bean.destroy();</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">                logger.error(&quot;Destroy method on bean with name &#39;&quot; + beanName + &quot;&#39; threw an exception&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 然后销毁它所包含的Bean</span><br><span class="line">        Set&lt;String&gt; containedBeans &#x3D; this.containedBeanMap.remove(beanName);</span><br><span class="line">        if (containedBeans !&#x3D; null) &#123;</span><br><span class="line">            for (String containedBeanName : containedBeans) &#123;</span><br><span class="line">                destroySingleton(containedBeanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 然后把所有它依赖的Bean的依赖关系删除，首先删除dependentBeanMap中的依赖关系</span><br><span class="line">        synchronized (this.dependentBeanMap) &#123;</span><br><span class="line">            &#x2F;&#x2F;这样的for循环用法实在是经典</span><br><span class="line">            for (Iterator&lt;Map.Entry&lt;String, Set&lt;String&gt;&gt;&gt; it &#x3D; this.dependentBeanMap.entrySet().iterator(); it.hasNext();) &#123;</span><br><span class="line">                Map.Entry&lt;String, Set&lt;String&gt;&gt; entry &#x3D; it.next();</span><br><span class="line">                Set&lt;String&gt; dependenciesToClean &#x3D; entry.getValue();</span><br><span class="line">                dependenciesToClean.remove(beanName);</span><br><span class="line">                if (dependenciesToClean.isEmpty()) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 然后删除dependenciesForBeanMap中的依赖关系</span><br><span class="line">        this.dependenciesForBeanMap.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Expose the singleton mutex to subclasses.</span><br><span class="line">     * &lt;p&gt;Subclasses should synchronize on the given Object if they perform</span><br><span class="line">     * any sort of extended singleton creation phase. In particular, subclasses</span><br><span class="line">     * should &lt;i&gt;not&lt;&#x2F;i&gt; have their own mutexes involved in singleton creation,</span><br><span class="line">     * to avoid the potential for deadlocks in lazy-init situations.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;返回子类单例类的互斥体？这个暂且放着。</span><br><span class="line">    protected final Object getSingletonMutex() &#123;</span><br><span class="line">        return this.singletonObjects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体：</p>
<p>　　1、一个静态不可变的空对象NULL_OBJECT、一个简单的日志对象。</p>
<p>　　2、本类有如下集合：</p>
<p>　　　　（1）、一个单例缓存集合——singletonObjects</p>
<p>　　　　（2）、一个单例工厂缓存集合——singletonFactories</p>
<p>　　　　（3）、一个早期单例对象缓存集合——earlySingletonObjects</p>
<p>　　　　（4）、一个注册过的单例类（单例工厂）集合——registeredSingletons</p>
<p>　　　　（5）、一个即将创建的单例类集合——singletonsCurrentlyInCreation</p>
<p>　　　　（6）、一个正在创建的单例类集合——inCreationCheckExclusions</p>
<p>　　　　（7）、一个被压制的异常集合——suppressedExceptions（这种设计模式实在是经典！）</p>
<p>　　　　（8）、一个判断所有单例类是否马上被销毁的标记——singletonsCurrentlyInDestruction</p>
<p>　　　　（9）、一个Disposable接口（即可以自定义回收资源的接口）实例的集合——disposableBeans</p>
<p>　　　　（10）、一个bean名称和bean所有包含的Bean的名称的集合——containedBeanMap</p>
<p>　　　　（11）、bean名称和所有依赖于Bean的名称的集合——dependentBeanMap</p>
<p>　　　　（12）、bean名称和bean所依赖的所有名称的集合——dependenciesForBeanMap</p>
<p>　　3、2个注册单例方法，实际是暴露在外的SingletonBeanRegistry接口的实现方法registerSingleton加锁后调用另一个addSingleton方法。</p>
<p>　　4、1个注册单例工厂的方法。单例工厂类不能和单例类同名。</p>
<p>　　5、3个获取单例类的方法。一种是从单例类集合中获取，如果获取不到，boolean控制要么返回空对象，要么返回一个单例工厂。另一种是从单例集合中获取，如果取不到，就从指定的工厂中获取。还有一种？呵，就是暴露在外的SingletonBeanRegistry接口方法呗，直接调用第一种。</p>
<p>　　6、1个添加被压制的异常集合中添加异常的方法，我觉得这个设计非常经典。但需要记录异常，却不想处理的时候，可以采用这种设计模式。</p>
<p>　　7、1个移除单例的方法、1个判断是否包含单例的方法、1个返回所有单例名数组的方法、1个返回单例总数目的方法。</p>
<p>　　8、1个设置某个Bean是否正在创建的方法、1个判断某个Bean是否正在被创建的方法、2个判断某个Bean是否即将被创建的方法（一个调用另一个，用于重写）。</p>
<p>　　9、1个单例类创建开始之前调用的方法、1个单单例类创建之后调用的方法</p>
<p>　　10、1个往Disposable实例集合注册Disposable实例的方法，这个是Bean销毁前的准备。</p>
<p>　　11、1个注册一个被包含的Bean和一个包含的Bean的名称到containedBeanMap集合的方法。这个方法设置了Bean之间的包含关系。</p>
<p>　　12、1个给指定的Bean注册一个其依赖的Bean的方法。这个方法设置了Bean自己的依赖关系。</p>
<p>　　13、1个判断是否被依赖的方法、1个返回给定Bean名称的所有依赖的数组的方法、1个返回依赖于给定Bean的所有Bean名的数组的方法。</p>
<p>　　14、1个销毁所有单例类的方法（这个方法居然完全没有注释，有没搞错！）、1个销毁某个单例的方法、1个// 销毁指定名称的Bean，且销毁依赖于它的所有Bean的方法。</p>
<p>　　15、1个返回子类单例类的互斥体的方法。这个暂且待下一篇分析子类再看。</p>
<p>总结：</p>
<p>　　类如其名，默认的单例注册器。这个工厂的写法实在功能丰富，为了监控到一个单例类构建过程中的方方面面，简直就是不择手段啊，居然准备了12个集合，除了一个一个被压制的异常集合，其余全是跟单例类有直接关系的。可以说，这个单例注册器监听、实现了Spring单例注册的各个过程，具体的解读分析，在上面的源代码中可以看到，读者阅读我注释过的源代码应该会很轻松。</p>
<h1 id="一、工厂Bean注册支持——FactoryBeanRegistrySupport"><a href="#一、工厂Bean注册支持——FactoryBeanRegistrySupport" class="headerlink" title="一、工厂Bean注册支持——FactoryBeanRegistrySupport"></a>一、工厂Bean注册支持——FactoryBeanRegistrySupport</h1><p>废话不多说，直接看我注释的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Copyright 2002-2012 the original author or authors.</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"> * you may not use this file except in compliance with the License.</span><br><span class="line"> * You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *      http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">package org.springframework.beans.factory.support;</span><br><span class="line"></span><br><span class="line">import java.security.AccessControlContext;</span><br><span class="line">import java.security.AccessController;</span><br><span class="line">import java.security.PrivilegedAction;</span><br><span class="line">import java.security.PrivilegedActionException;</span><br><span class="line">import java.security.PrivilegedExceptionAction;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.factory.BeanCreationException;</span><br><span class="line">import org.springframework.beans.factory.BeanCurrentlyInCreationException;</span><br><span class="line">import org.springframework.beans.factory.FactoryBean;</span><br><span class="line">import org.springframework.beans.factory.FactoryBeanNotInitializedException;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Support base class for singleton registries which need to handle</span><br><span class="line"> * &#123;@link org.springframework.beans.factory.FactoryBean&#125; instances,</span><br><span class="line"> * integrated with &#123;@link DefaultSingletonBeanRegistry&#125;&#39;s singleton management.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Serves as base class for &#123;@link AbstractBeanFactory&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @author Juergen Hoeller</span><br><span class="line"> * @since 2.5.1</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract class FactoryBeanRegistrySupport extends DefaultSingletonBeanRegistry &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 工厂Bean生产的单例的集合: FactoryBean name --&gt; object *&#x2F;</span><br><span class="line">    private final Map&lt;String, Object&gt; factoryBeanObjectCache &#x3D; new ConcurrentHashMap&lt;String, Object&gt;(16);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回指定FactoryBean的类型</span><br><span class="line">    protected Class getTypeForFactoryBean(final FactoryBean factoryBean) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (System.getSecurityManager() !&#x3D; null) &#123;&#x2F;&#x2F;如果当前系统存在安全管理器</span><br><span class="line">                return AccessController.doPrivileged(new PrivilegedAction&lt;Class&gt;() &#123;&#x2F;&#x2F;那么返回factoryBean的类型这个操作不做权限检查，直接调用</span><br><span class="line">                    public Class run() &#123;</span><br><span class="line">                        return factoryBean.getObjectType();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;&#x2F;&#x2F;不存在安全管理器，就直接调用！</span><br><span class="line">                return factoryBean.getObjectType();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            logger.warn(&quot;FactoryBean threw exception from getObjectType, despite the contract saying &quot; +</span><br><span class="line">                    &quot;that it should return null if the type of its object cannot be determined yet&quot;, ex);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据FactoryBean名，返回其生产的Object，从缓存中取</span><br><span class="line">    protected Object getCachedObjectForFactoryBean(String beanName) &#123;</span><br><span class="line">        Object object &#x3D; this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">        return (object !&#x3D; NULL_OBJECT ? object : null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;从工厂Bean中取实例，实际调用下面的doGetObjectFromFactoryBean方法。</span><br><span class="line">    protected Object getObjectFromFactoryBean(FactoryBean factory, String beanName, boolean shouldPostProcess) &#123;</span><br><span class="line">        if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;&#x2F;&#x2F;若工厂是单例，且本容器包含beanName对应的单例类</span><br><span class="line">            synchronized (getSingletonMutex()) &#123;&#x2F;&#x2F;以所有的单例集合为锁</span><br><span class="line">                Object object &#x3D; this.factoryBeanObjectCache.get(beanName);&#x2F;&#x2F;根据beanName从factoryBeanObjectCache中取</span><br><span class="line">                if (object &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;若取不到</span><br><span class="line">                    object &#x3D; doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);</span><br><span class="line">                    this.factoryBeanObjectCache.put(beanName, (object !&#x3D; null ? object : NULL_OBJECT));&#x2F;&#x2F;放进factoryBeanObjectCache</span><br><span class="line">                &#125;</span><br><span class="line">                return (object !&#x3D; NULL_OBJECT ? object : null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;&#x2F;&#x2F;否则，直接</span><br><span class="line">            return doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;从工厂Bean中取实例</span><br><span class="line">    private Object doGetObjectFromFactoryBean(</span><br><span class="line">            final FactoryBean factory, final String beanName, final boolean shouldPostProcess)</span><br><span class="line">            throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">        Object object;</span><br><span class="line">        &#x2F;&#x2F;跟getTypeForFactoryBean的实现一样。</span><br><span class="line">        try &#123;</span><br><span class="line">            if (System.getSecurityManager() !&#x3D; null) &#123;&#x2F;&#x2F;若系统存在安全管理器</span><br><span class="line">                AccessControlContext acc &#x3D; getAccessControlContext();&#x2F;&#x2F;得到当前容器的安全访问上下文</span><br><span class="line">                try &#123;&#x2F;&#x2F;返回factoryBean的类型这个操作不做权限检查，直接调用</span><br><span class="line">                    object &#x3D; AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                        public Object run() throws Exception &#123;</span><br><span class="line">                                return factory.getObject();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, acc);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                    throw pae.getException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;&#x2F;&#x2F;否则直接取</span><br><span class="line">                object &#x3D; factory.getObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">            throw new BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            throw new BeanCreationException(beanName, &quot;FactoryBean threw exception on object creation&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果从beanFactory取不到，且这个实例即将被创建，抛出异常</span><br><span class="line">        if (object &#x3D;&#x3D; null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            throw new BeanCurrentlyInCreationException(</span><br><span class="line">                    beanName, &quot;FactoryBean which is currently in creation returned null from getObject&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;若取不到，且这个实例允许前处理</span><br><span class="line">        if (object !&#x3D; null &amp;&amp; shouldPostProcess) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                object &#x3D; postProcessObjectFromFactoryBean(object, beanName);&#x2F;&#x2F;这里简单返回，前处理的功能留给子类重写</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">                throw new BeanCreationException(beanName, &quot;Post-processing of the FactoryBean&#39;s object failed&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;这里简单返回Object，留给子类重写</span><br><span class="line">    protected Object postProcessObjectFromFactoryBean(Object object, String beanName) throws BeansException &#123;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果这个Object是FactoryBean类型，就转换成FactoryBean返回</span><br><span class="line">    protected FactoryBean getFactoryBean(String beanName, Object beanInstance) throws BeansException &#123;</span><br><span class="line">        if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">            throw new BeanCreationException(beanName,</span><br><span class="line">                    &quot;Bean instance of type [&quot; + beanInstance.getClass() + &quot;] is not a FactoryBean&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return (FactoryBean) beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;移除单例类这个方法重写，父类的移除之外，还要移除factoryBeanObjectCache中的。</span><br><span class="line">    @Override</span><br><span class="line">    protected void removeSingleton(String beanName) &#123;</span><br><span class="line">        super.removeSingleton(beanName);</span><br><span class="line">        this.factoryBeanObjectCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回当前容器的安全访问上下文</span><br><span class="line">    protected AccessControlContext getAccessControlContext() &#123;</span><br><span class="line">        return AccessController.getContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体：</p>
<p>　　1、1个不可变的实例属性ConcurrentHashMap来存放工厂Bean生产的单例的集合：FactoryBean name –&gt; object。</p>
<p>　　2、1个方法返回指定FactoryBean的类型的方法。</p>
<p>　　3、1个根据FactoryBean名，返回其生产的Object的方法。</p>
<p>　　4、2个从工厂Bean中取实例的方法。实际是一个方法调用另一个，取不到则返回空。</p>
<p>　　5、1个postProcessObjectFromFactoryBean的方法，留给子类重写。</p>
<p>　　6、1个取工厂Bean的方法——如果这个Object是FactoryBean类型，就转换成FactoryBean返回</p>
<p>　　7、1个重写父类的removeSingleton方法，移除单例的时候，父类的移除之外，还要移除factoryBeanObjectCache中的。</p>
<p>　　8、1个返回当前容器的安全访问上下文的方法。</p>
<p>总结：</p>
<p>　　这个类FactoryBeanRegistrySupport，类如其名，实现了对工厂Bean注册的支持。值得注意的是，这个类有较多类似如下的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (System.getSecurityManager() !&#x3D; null) &#123;&#x2F;&#x2F;如果当前系统存在安全管理器</span><br><span class="line">                return AccessController.doPrivileged(new PrivilegedAction&lt;Class&gt;() &#123;</span><br><span class="line">                    public Class run() &#123;</span><br><span class="line">                        &#x2F;&#x2F;实际处理</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;&#x2F;&#x2F;不存在安全管理器，就直接调用！</span><br><span class="line">                &#x2F;&#x2F;实际处理</span><br><span class="line">            &#125;     </span><br></pre></td></tr></table></figure>

<p>　　这个方法的意思是，如果当前系统存在安全管理器，那么接下来的操作不做权限检查，直接调用。而如果不存在，OK，那当然是直接调用了。这是JDK层面的一个系统安全管理工具，某些情况下，可以避免系统进行安全检查。这里稍作了解即可。在学习JVM的时候可仔细了解原理。</p>
<p>　　除此之外，这里可以了解一下这个类比较重要的方法doGetObjectFromFactoryBean，是从工厂Bean中取实例的方法，源码已经给出，这里重点指出一下：</p>
<p>//从工厂Bean中取实例，shouldPostProcess指的是是否允许提前处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private Object doGetObjectFromFactoryBean(</span><br><span class="line">            final FactoryBean factory, final String beanName, final boolean shouldPostProcess)</span><br><span class="line">            throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">        Object object;</span><br><span class="line">        &#x2F;&#x2F;跟getTypeForFactoryBean的实现一样。</span><br><span class="line">        try &#123;</span><br><span class="line">            if (System.getSecurityManager() !&#x3D; null) &#123;&#x2F;&#x2F;若系统存在安全管理器</span><br><span class="line">                AccessControlContext acc &#x3D; getAccessControlContext();&#x2F;&#x2F;得到当前容器的安全访问上下文</span><br><span class="line">                try &#123;&#x2F;&#x2F;返回factoryBean的类型这个操作不做权限检查，直接调用</span><br><span class="line">                    object &#x3D; AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                        public Object run() throws Exception &#123;</span><br><span class="line">                                return factory.getObject();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, acc);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                    throw pae.getException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;&#x2F;&#x2F;否则直接取</span><br><span class="line">                object &#x3D; factory.getObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">            throw new BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            throw new BeanCreationException(beanName, &quot;FactoryBean threw exception on object creation&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果从beanFactory取不到，且这个实例即将被创建，抛出异常</span><br><span class="line">        if (object &#x3D;&#x3D; null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            throw new BeanCurrentlyInCreationException(</span><br><span class="line">                    beanName, &quot;FactoryBean which is currently in creation returned null from getObject&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;若取不到，并非即将创建、且这个实例允许前处理</span><br><span class="line">        if (object !&#x3D; null &amp;&amp; shouldPostProcess) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                object &#x3D; postProcessObjectFromFactoryBean(object, beanName);&#x2F;&#x2F;这里简单返回，前处理的功能留给子类重写</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">                throw new BeanCreationException(beanName, &quot;Post-processing of the FactoryBean&#39;s object failed&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>　　相信上面已经解释的很清楚了。</p>
<p>二、最重要的抽象类——AbstractBeanFactory</p>
<p>　　（PS：这个类的方法实在是多的骇人，看得我实在是头都大了。不多看到后面，发现很多方法其实也就是那么回事。源码注释了大部分，且看看咯！）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;父工厂的引用</span><br><span class="line">    private BeanFactory parentBeanFactory;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;类加载器</span><br><span class="line">    private ClassLoader beanClassLoader &#x3D; ClassUtils.getDefaultClassLoader();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;临时类加载器</span><br><span class="line">    private ClassLoader tempClassLoader;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Whether to cache bean metadata or rather reobtain it for every access *&#x2F;</span><br><span class="line">    private boolean cacheBeanMetadata &#x3D; true;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Bean表达式分解器，用来分解Bean定义中的表达式</span><br><span class="line">    private BeanExpressionResolver beanExpressionResolver;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;转换服务，用来替代属性编辑器的</span><br><span class="line">    private ConversionService conversionService;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;属性编辑登记员集合，容量为4的LinkedHashSet</span><br><span class="line">    private final Set&lt;PropertyEditorRegistrar&gt; propertyEditorRegistrars &#x3D;</span><br><span class="line">            new LinkedHashSet&lt;PropertyEditorRegistrar&gt;(4);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通用的类型转换器，重写了默认的属相编辑器机制</span><br><span class="line">    private TypeConverter typeConverter;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;默认的属性编辑器集合</span><br><span class="line">    private final Map&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; customEditors &#x3D;</span><br><span class="line">            new HashMap&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt;(4);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;嵌入值转换器集合</span><br><span class="line">    private final List&lt;StringValueResolver&gt; embeddedValueResolvers &#x3D; new LinkedList&lt;StringValueResolver&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;BeanPostProcessor处理器集合</span><br><span class="line">    private final List&lt;BeanPostProcessor&gt; beanPostProcessors &#x3D; new ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;标记是否有InstantiationAwareBeanPostProcessors实例被注册</span><br><span class="line">    private boolean hasInstantiationAwareBeanPostProcessors;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;标记是否有DestructionAwareBeanPostProcessors实例被注册</span><br><span class="line">    private boolean hasDestructionAwareBeanPostProcessors;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;范围标识符和Scope实例的对应的Map</span><br><span class="line">    private final Map&lt;String, Scope&gt; scopes &#x3D; new HashMap&lt;String, Scope&gt;(8);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;安全上下文Provider，可以得到安全管理器的安全上下文</span><br><span class="line">    private SecurityContextProvider securityContextProvider;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;合并后的Bean根定义的集合</span><br><span class="line">    private final Map&lt;String, RootBeanDefinition&gt; mergedBeanDefinitions &#x3D;</span><br><span class="line">            new ConcurrentHashMap&lt;String, RootBeanDefinition&gt;(64);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;至少被创建过一次的Bean的集合</span><br><span class="line">    private final Map&lt;String, Boolean&gt; alreadyCreated &#x3D; new ConcurrentHashMap&lt;String, Boolean&gt;(64);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当前正在创建的原型，当前线程相关</span><br><span class="line">    private final ThreadLocal&lt;Object&gt; prototypesCurrentlyInCreation &#x3D;</span><br><span class="line">            new NamedThreadLocal&lt;Object&gt;(&quot;Prototype beans currently in creation&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;空构造方法</span><br><span class="line">    public AbstractBeanFactory() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;指定父Bean工厂的构造方法</span><br><span class="line">    public AbstractBeanFactory(BeanFactory parentBeanFactory) &#123;</span><br><span class="line">        this.parentBeanFactory &#x3D; parentBeanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line">    &#x2F;&#x2F; 3个getBean，BeanFactory接口的实现方法，实质是在调用doGetBean</span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    public Object getBean(String name) throws BeansException &#123;</span><br><span class="line">        return doGetBean(name, null, null, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException &#123;</span><br><span class="line">        return doGetBean(name, requiredType, null, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getBean(String name, Object... args) throws BeansException &#123;</span><br><span class="line">        return doGetBean(name, null, args, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;    提供创建时需要参数列表的getBean</span><br><span class="line">    public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType, Object... args) throws BeansException &#123;</span><br><span class="line">        return doGetBean(name, requiredType, args, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;从容器中获取bean的基本方法。</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    protected &lt;T&gt; T doGetBean(</span><br><span class="line">            final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</span><br><span class="line">            throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">        final String beanName &#x3D; transformedBeanName(name);&#x2F;&#x2F;在aliasMap中取得的标准名</span><br><span class="line">        Object bean;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Eagerly check singleton cache for manually registered singletons.</span><br><span class="line">        Object sharedInstance &#x3D; getSingleton(beanName);&#x2F;&#x2F;首先在单例集合中取</span><br><span class="line">        if (sharedInstance !&#x3D; null &amp;&amp; args &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;如果取得到，没有指定参数</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;&#x2F;&#x2F;若Log允许调试</span><br><span class="line">                if (isSingletonCurrentlyInCreation(beanName)) &#123;&#x2F;&#x2F;若正准备创建，输出日志</span><br><span class="line">                    logger.debug(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +</span><br><span class="line">                            &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;&#x2F;&#x2F;根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例</span><br><span class="line">            bean &#x3D; getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line">            if (isPrototypeCurrentlyInCreation(beanName)) &#123;&#x2F;&#x2F;如果正在被创建，就抛出异常</span><br><span class="line">                throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();&#x2F;&#x2F;取本容器的父容器</span><br><span class="line">            if (parentBeanFactory !&#x3D; null &amp;&amp; !containsBeanDefinition(beanName)) &#123;&#x2F;&#x2F;若存在父容器，且本容器不存在对应的Bean定义</span><br><span class="line">                String nameToLookup &#x3D; originalBeanName(name);&#x2F;&#x2F;取原始的Bean名</span><br><span class="line">                if (args !&#x3D; null) &#123;&#x2F;&#x2F;若参数列表存在</span><br><span class="line">                    &#x2F;&#x2F; 那么用父容器根据原始Bean名和参数列表返回</span><br><span class="line">                    return (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 参数列表不要求，那就直接根据原始名称和要求的类型返回</span><br><span class="line">                    return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果不需要类型检查，标记其已经被创建</span><br><span class="line">            if (!typeCheckOnly) &#123;</span><br><span class="line">                markBeanAsCreated(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;根据beanName取其根Bean定义</span><br><span class="line">            final RootBeanDefinition mbd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            String[] dependsOn &#x3D; mbd.getDependsOn();&#x2F;&#x2F;得到这个根定义的所有依赖</span><br><span class="line">            if (dependsOn !&#x3D; null) &#123;</span><br><span class="line">                for (String dependsOnBean : dependsOn) &#123;</span><br><span class="line">                    getBean(dependsOnBean);&#x2F;&#x2F;注册这个Bean</span><br><span class="line">                    &#x2F;&#x2F;注册一个Bean和依赖于它的Bean（后参数依赖前参数）</span><br><span class="line">                    registerDependentBean(dependsOnBean, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果Bean定义是单例，就在返回单例</span><br><span class="line">            if (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance &#x3D; getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                    public Object getObject() throws BeansException &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            return createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        catch (BeansException ex) &#123;</span><br><span class="line">                            destroySingleton(beanName);</span><br><span class="line">                            throw ex;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                &#x2F;&#x2F;根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例</span><br><span class="line">                bean &#x3D; getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果是原型</span><br><span class="line">            else if (mbd.isPrototype()) &#123;</span><br><span class="line">                &#x2F;&#x2F; It&#39;s a prototype -&gt; create a new instance.</span><br><span class="line">                Object prototypeInstance &#x3D; null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);&#x2F;&#x2F;原型创建前，与当前线程绑定</span><br><span class="line">                    prototypeInstance &#x3D; createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                finally &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);&#x2F;&#x2F;原型创建后，与当前线程解除绑定</span><br><span class="line">                &#125;</span><br><span class="line">                bean &#x3D; getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            else &#123;&#x2F;&#x2F;既不是单例又不是原型的情况</span><br><span class="line">                String scopeName &#x3D; mbd.getScope();</span><br><span class="line">                final Scope scope &#x3D; this.scopes.get(scopeName);&#x2F;&#x2F;得到范围</span><br><span class="line">                if (scope &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;No Scope registered for scope &#39;&quot; + scopeName + &quot;&#39;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;&#x2F;&#x2F;根据范围创建实例</span><br><span class="line">                    Object scopedInstance &#x3D; scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                        public Object getObject() throws BeansException &#123;</span><br><span class="line">                            beforePrototypeCreation(beanName);</span><br><span class="line">                            try &#123;</span><br><span class="line">                                return createBean(beanName, mbd, args);&#x2F;&#x2F;原型创建前，与当前线程绑定</span><br><span class="line">                            &#125;</span><br><span class="line">                            finally &#123;</span><br><span class="line">                                &#x2F;&#x2F;&#x2F;&#x2F;原型创建后，与当前线程解除绑定</span><br><span class="line">                                afterPrototypeCreation(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    &#x2F;&#x2F;根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例</span><br><span class="line">                    bean &#x3D; getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (IllegalStateException ex) &#123;</span><br><span class="line">                    throw new BeanCreationException(beanName,</span><br><span class="line">                            &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; &quot; +</span><br><span class="line">                            &quot;consider defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,</span><br><span class="line">                            ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断要求的类型是否和Bean实例的类型正在匹配</span><br><span class="line">        if (requiredType !&#x3D; null &amp;&amp; bean !&#x3D; null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return getTypeConverter().convertIfNecessary(bean, requiredType);&#x2F;&#x2F;转换类型，不抛出异常就说明类型匹配</span><br><span class="line">            &#125;</span><br><span class="line">            catch (TypeMismatchException ex) &#123;</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type [&quot; +</span><br><span class="line">                            ClassUtils.getQualifiedName(requiredType) + &quot;]&quot;, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (T) bean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;判断本容器是否包含指定bean</span><br><span class="line">    public boolean containsBean(String name) &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line">        &#x2F;&#x2F;    （如果是否包含单例 或 包含Bean定义）且 （为工厂Bean的产物 或 本身就是工厂bean），就返回true</span><br><span class="line">        if (containsSingleton(beanName) || containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            return (!BeanFactoryUtils.isFactoryDereference(name) || isFactoryBean(name));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果不包含单例且不包含Bean定义，就从父类去查找</span><br><span class="line">        BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();</span><br><span class="line">        return (parentBeanFactory !&#x3D; null &amp;&amp; parentBeanFactory.containsBean(originalBeanName(name)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断指定Bean是否为单例</span><br><span class="line">    public boolean isSingleton(String name) throws NoSuchBeanDefinitionException &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">        Object beanInstance &#x3D; getSingleton(beanName, false);&#x2F;&#x2F;首先从单例集合中取</span><br><span class="line">        if (beanInstance !&#x3D; null) &#123;&#x2F;&#x2F;取不到，就判断它是不是FactoryBean的实例</span><br><span class="line">            if (beanInstance instanceof FactoryBean) &#123;    &#x2F;&#x2F;    如果是，要求它是工厂Bean产生的实例或这个工厂bean是单例</span><br><span class="line">                return (BeanFactoryUtils.isFactoryDereference(name) || ((FactoryBean&lt;?&gt;) beanInstance).isSingleton());</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;&#x2F;&#x2F;    如果不是，要求它不是工厂Bean产生的实例</span><br><span class="line">                return !BeanFactoryUtils.isFactoryDereference(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#x2F;&#x2F;若虽然取不到，但是单例集合中包含它的名字，说明它是单例</span><br><span class="line">        else if (containsSingleton(beanName)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F;从父工厂中去查询Bean定义</span><br><span class="line">            BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();</span><br><span class="line">            if (parentBeanFactory !&#x3D; null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                &#x2F;&#x2F;父工厂找不到Bean定义，那就在父工厂根据原始名去查是否为单例</span><br><span class="line">                return parentBeanFactory.isSingleton(originalBeanName(name));</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;返回一个合并后的根Bean定义</span><br><span class="line">            RootBeanDefinition mbd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; In case of FactoryBean, return singleton status of created object if not a dereference.</span><br><span class="line">            &#x2F;&#x2F;若该根定义是单例</span><br><span class="line">            if (mbd.isSingleton()) &#123;</span><br><span class="line">                if (isFactoryBean(beanName, mbd)) &#123;    &#x2F;&#x2F;若该根定义为工厂Bean</span><br><span class="line">                    if (BeanFactoryUtils.isFactoryDereference(name)) &#123;&#x2F;&#x2F;判断是否为工厂产生的实例</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;取对应的工厂，判断该工厂Bean是否为单例</span><br><span class="line">                    FactoryBean&lt;?&gt; factoryBean &#x3D; (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                    return factoryBean.isSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;    &#x2F;&#x2F;    是否不为工厂Bean产生的实例（此时，即，该根定义不为工厂Bean，且不为工厂Bean产生的实例的时候，由于根定义是单例，那么它就是单例）</span><br><span class="line">                    return !BeanFactoryUtils.isFactoryDereference(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断是否为原型</span><br><span class="line">    public boolean isPrototype(String name) throws NoSuchBeanDefinitionException &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">        BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();&#x2F;&#x2F;得到父工厂</span><br><span class="line">        &#x2F;&#x2F;若父工厂中的定义为原型，就为原型</span><br><span class="line">        if (parentBeanFactory !&#x3D; null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            return parentBeanFactory.isPrototype(originalBeanName(name));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;若合并后的根定义为原型，且不是工厂Bean产生的实例、或本身是工厂Bean，那么就为原型</span><br><span class="line">        RootBeanDefinition mbd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        if (mbd.isPrototype()) &#123;</span><br><span class="line">            return (!BeanFactoryUtils.isFactoryDereference(name) || isFactoryBean(beanName, mbd));</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (BeanFactoryUtils.isFactoryDereference(name)) &#123;&#x2F;&#x2F;若为工厂Bean产生的实例</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (isFactoryBean(beanName, mbd)) &#123;&#x2F;&#x2F;若为工厂Bean，取它产生的Bean，判断SmartFactoryBean</span><br><span class="line">                final FactoryBean&lt;?&gt; factoryBean &#x3D; (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                if (System.getSecurityManager() !&#x3D; null) &#123;</span><br><span class="line">                    return AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                        public Boolean run() &#123;</span><br><span class="line">                            return ((factoryBean instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factoryBean).isPrototype()) ||</span><br><span class="line">                                    !factoryBean.isSingleton());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, getAccessControlContext());</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    return ((factoryBean instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factoryBean).isPrototype()) ||</span><br><span class="line">                            !factoryBean.isSingleton());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断类型是否匹配</span><br><span class="line">    public boolean isTypeMatch(String name, Class&lt;?&gt; targetType) throws NoSuchBeanDefinitionException &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line">        Class&lt;?&gt; typeToMatch &#x3D; (targetType !&#x3D; null ? targetType : Object.class);</span><br><span class="line"></span><br><span class="line">        Object beanInstance &#x3D; getSingleton(beanName, false);&#x2F;&#x2F;取name对应的单例</span><br><span class="line">        if (beanInstance !&#x3D; null) &#123;</span><br><span class="line">            if (beanInstance instanceof FactoryBean) &#123;&#x2F;&#x2F;若为工厂Bean</span><br><span class="line">                &#x2F;&#x2F;若不是工厂Bean产生的实例</span><br><span class="line">                if (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">                    &#x2F;&#x2F;取工厂Bean的类型与targetType进行对比</span><br><span class="line">                    Class&lt;?&gt; type &#x3D; getTypeForFactoryBean((FactoryBean&lt;?&gt;) beanInstance);</span><br><span class="line">                    return (type !&#x3D; null &amp;&amp; ClassUtils.isAssignable(typeToMatch, type));</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    return ClassUtils.isAssignableValue(typeToMatch, beanInstance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;不是工厂Bean，那就直接判断</span><br><span class="line">            else &#123;</span><br><span class="line">                return !BeanFactoryUtils.isFactoryDereference(name) &amp;&amp;</span><br><span class="line">                        ClassUtils.isAssignableValue(typeToMatch, beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;单例表中，对应的Key没有值，也不包含Bean定义，说明没有注册，返回false</span><br><span class="line">        else if (containsSingleton(beanName) &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;以下是包含Bean定义的情况</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F;先查父类的Bean定义</span><br><span class="line">            BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();</span><br><span class="line">            if (parentBeanFactory !&#x3D; null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                &#x2F;&#x2F; No bean definition found in this factory -&gt; delegate to parent.</span><br><span class="line">                return parentBeanFactory.isTypeMatch(originalBeanName(name), targetType);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;直接查合并后的根定义</span><br><span class="line">            RootBeanDefinition mbd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;构建类型数组</span><br><span class="line">            Class[] typesToMatch &#x3D; (FactoryBean.class.equals(typeToMatch) ?</span><br><span class="line">                    new Class[] &#123;typeToMatch&#125; : new Class[] &#123;FactoryBean.class, typeToMatch&#125;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check decorated bean definition, if any: We assume it&#39;ll be easier</span><br><span class="line">            &#x2F;&#x2F; to determine the decorated bean&#39;s type than the proxy&#39;s type.</span><br><span class="line">            &#x2F;&#x2F;得到Bean定义的持有者</span><br><span class="line">            BeanDefinitionHolder dbd &#x3D; mbd.getDecoratedDefinition();</span><br><span class="line">            if (dbd !&#x3D; null &amp;&amp; !BeanFactoryUtils.isFactoryDereference(name)) &#123;&#x2F;&#x2F;若为Bean工厂生成的实例，先得到根定义</span><br><span class="line">                RootBeanDefinition tbd &#x3D; getMergedBeanDefinition(dbd.getBeanName(), dbd.getBeanDefinition(), mbd);</span><br><span class="line">                Class&lt;?&gt; targetClass &#x3D; predictBeanType(dbd.getBeanName(), tbd, typesToMatch);&#x2F;&#x2F;得到预测的根定义</span><br><span class="line">                if (targetClass !&#x3D; null &amp;&amp; !FactoryBean.class.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">                    return typeToMatch.isAssignableFrom(targetClass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; beanType &#x3D; predictBeanType(beanName, mbd, typesToMatch);&#x2F;&#x2F;预测后的类型</span><br><span class="line">            if (beanType &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (FactoryBean.class.isAssignableFrom(beanType)) &#123;&#x2F;&#x2F;BeanFactory是否为其子类</span><br><span class="line">                if (!BeanFactoryUtils.isFactoryDereference(name)) &#123;&#x2F;&#x2F;若不为工厂Bean的产物</span><br><span class="line">                    &#x2F;&#x2F; If it&#39;s a FactoryBean, we want to look at what it creates, not the factory class.</span><br><span class="line">                    beanType &#x3D; getTypeForFactoryBean(beanName, mbd);</span><br><span class="line">                    if (beanType &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (BeanFactoryUtils.isFactoryDereference(name)) &#123;&#x2F;&#x2F;若为工厂类Bean的产物</span><br><span class="line">                beanType &#x3D; predictBeanType(beanName, mbd, FactoryBean.class);&#x2F;&#x2F;预测类型</span><br><span class="line">                if (beanType &#x3D;&#x3D; null || !FactoryBean.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return typeToMatch.isAssignableFrom(beanType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回类型</span><br><span class="line">    public Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Check manually registered singletons.</span><br><span class="line">        Object beanInstance &#x3D; getSingleton(beanName, false);</span><br><span class="line">        if (beanInstance !&#x3D; null) &#123;</span><br><span class="line">            if (beanInstance instanceof FactoryBean &amp;&amp; !BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">                return getTypeForFactoryBean((FactoryBean&lt;?&gt;) beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return beanInstance.getClass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (containsSingleton(beanName) &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            &#x2F;&#x2F; null instance registered</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; No singleton instance found -&gt; check bean definition.</span><br><span class="line">            BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();</span><br><span class="line">            if (parentBeanFactory !&#x3D; null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                &#x2F;&#x2F; No bean definition found in this factory -&gt; delegate to parent.</span><br><span class="line">                return parentBeanFactory.getType(originalBeanName(name));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RootBeanDefinition mbd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check decorated bean definition, if any: We assume it&#39;ll be easier</span><br><span class="line">            &#x2F;&#x2F; to determine the decorated bean&#39;s type than the proxy&#39;s type.</span><br><span class="line">            BeanDefinitionHolder dbd &#x3D; mbd.getDecoratedDefinition();</span><br><span class="line">            if (dbd !&#x3D; null &amp;&amp; !BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">                RootBeanDefinition tbd &#x3D; getMergedBeanDefinition(dbd.getBeanName(), dbd.getBeanDefinition(), mbd);</span><br><span class="line">                Class&lt;?&gt; targetClass &#x3D; predictBeanType(dbd.getBeanName(), tbd);</span><br><span class="line">                if (targetClass !&#x3D; null &amp;&amp; !FactoryBean.class.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">                    return targetClass;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; beanClass &#x3D; predictBeanType(beanName, mbd);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check bean class whether we&#39;re dealing with a FactoryBean.</span><br><span class="line">            if (beanClass !&#x3D; null &amp;&amp; FactoryBean.class.isAssignableFrom(beanClass)) &#123;</span><br><span class="line">                if (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; If it&#39;s a FactoryBean, we want to look at what it creates, not at the factory class.</span><br><span class="line">                    return getTypeForFactoryBean(beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    return beanClass;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return (!BeanFactoryUtils.isFactoryDereference(name) ? beanClass : null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重写了，得到别名的方法。</span><br><span class="line">    @Override</span><br><span class="line">    public String[] getAliases(String name) &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line">        List&lt;String&gt; aliases &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        boolean factoryPrefix &#x3D; name.startsWith(FACTORY_BEAN_PREFIX);</span><br><span class="line">        String fullBeanName &#x3D; beanName;</span><br><span class="line">        if (factoryPrefix) &#123;</span><br><span class="line">            fullBeanName &#x3D; FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!fullBeanName.equals(name)) &#123;</span><br><span class="line">            aliases.add(fullBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] retrievedAliases &#x3D; super.getAliases(beanName);</span><br><span class="line">        for (String retrievedAlias : retrievedAliases) &#123;</span><br><span class="line">            String alias &#x3D; (factoryPrefix ? FACTORY_BEAN_PREFIX : &quot;&quot;) + retrievedAlias;</span><br><span class="line">            if (!alias.equals(name)) &#123;</span><br><span class="line">                aliases.add(alias);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!containsSingleton(beanName) &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();</span><br><span class="line">            if (parentBeanFactory !&#x3D; null) &#123;</span><br><span class="line">                aliases.addAll(Arrays.asList(parentBeanFactory.getAliases(fullBeanName)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return StringUtils.toStringArray(aliases);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line">    &#x2F;&#x2F; Implementation of HierarchicalBeanFactory interface</span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回本Bean工厂的父Bean工厂</span><br><span class="line">    public BeanFactory getParentBeanFactory() &#123;</span><br><span class="line">        return this.parentBeanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;是否在本容器中（就是说，并不是工厂bean生产出来的）</span><br><span class="line">    public boolean containsLocalBean(String name) &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);    &#x2F;&#x2F;    转换后的名字</span><br><span class="line">        &#x2F;&#x2F;（是否为单例或有对应的Bean定义） 且（不是工厂Bean生产出来的 或 本身就是工厂bean）</span><br><span class="line">        return ((containsSingleton(beanName) || containsBeanDefinition(beanName)) &amp;&amp;</span><br><span class="line">                (!BeanFactoryUtils.isFactoryDereference(name) || isFactoryBean(beanName)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line">    &#x2F;&#x2F; Implementation of ConfigurableBeanFactory interface</span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    public void setParentBeanFactory(BeanFactory parentBeanFactory) &#123;</span><br><span class="line">        if (this.parentBeanFactory !&#x3D; null &amp;&amp; this.parentBeanFactory !&#x3D; parentBeanFactory) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Already associated with parent BeanFactory: &quot; + this.parentBeanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        this.parentBeanFactory &#x3D; parentBeanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBeanClassLoader(ClassLoader beanClassLoader) &#123;</span><br><span class="line">        this.beanClassLoader &#x3D; (beanClassLoader !&#x3D; null ? beanClassLoader : ClassUtils.getDefaultClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ClassLoader getBeanClassLoader() &#123;</span><br><span class="line">        return this.beanClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTempClassLoader(ClassLoader tempClassLoader) &#123;</span><br><span class="line">        this.tempClassLoader &#x3D; tempClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ClassLoader getTempClassLoader() &#123;</span><br><span class="line">        return this.tempClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCacheBeanMetadata(boolean cacheBeanMetadata) &#123;</span><br><span class="line">        this.cacheBeanMetadata &#x3D; cacheBeanMetadata;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isCacheBeanMetadata() &#123;</span><br><span class="line">        return this.cacheBeanMetadata;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBeanExpressionResolver(BeanExpressionResolver resolver) &#123;</span><br><span class="line">        this.beanExpressionResolver &#x3D; resolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BeanExpressionResolver getBeanExpressionResolver() &#123;</span><br><span class="line">        return this.beanExpressionResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setConversionService(ConversionService conversionService) &#123;</span><br><span class="line">        this.conversionService &#x3D; conversionService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ConversionService getConversionService() &#123;</span><br><span class="line">        return this.conversionService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addPropertyEditorRegistrar(PropertyEditorRegistrar registrar) &#123;</span><br><span class="line">        Assert.notNull(registrar, &quot;PropertyEditorRegistrar must not be null&quot;);</span><br><span class="line">        this.propertyEditorRegistrars.add(registrar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the set of PropertyEditorRegistrars.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Set&lt;PropertyEditorRegistrar&gt; getPropertyEditorRegistrars() &#123;</span><br><span class="line">        return this.propertyEditorRegistrars;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void registerCustomEditor(Class&lt;?&gt; requiredType, Class&lt;? extends PropertyEditor&gt; propertyEditorClass) &#123;</span><br><span class="line">        Assert.notNull(requiredType, &quot;Required type must not be null&quot;);</span><br><span class="line">        Assert.isAssignable(PropertyEditor.class, propertyEditorClass);</span><br><span class="line">        this.customEditors.put(requiredType, propertyEditorClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void copyRegisteredEditorsTo(PropertyEditorRegistry registry) &#123;</span><br><span class="line">        registerCustomEditors(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the map of custom editors, with Classes as keys and PropertyEditor classes as values.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Map&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; getCustomEditors() &#123;</span><br><span class="line">        return this.customEditors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTypeConverter(TypeConverter typeConverter) &#123;</span><br><span class="line">        this.typeConverter &#x3D; typeConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;得到通用的类型转换器</span><br><span class="line">    protected TypeConverter getCustomTypeConverter() &#123;</span><br><span class="line">        return this.typeConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;得到类型转换器</span><br><span class="line">    public TypeConverter getTypeConverter() &#123;</span><br><span class="line">        TypeConverter customConverter &#x3D; getCustomTypeConverter();</span><br><span class="line">        if (customConverter !&#x3D; null) &#123;</span><br><span class="line">            return customConverter;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;&#x2F;&#x2F;若本容器未注册类型转换器，就创建一个简单的类型转换器</span><br><span class="line">            SimpleTypeConverter typeConverter &#x3D; new SimpleTypeConverter();</span><br><span class="line">            typeConverter.setConversionService(getConversionService());</span><br><span class="line">            registerCustomEditors(typeConverter);</span><br><span class="line">            return typeConverter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addEmbeddedValueResolver(StringValueResolver valueResolver) &#123;</span><br><span class="line">        Assert.notNull(valueResolver, &quot;StringValueResolver must not be null&quot;);</span><br><span class="line">        this.embeddedValueResolvers.add(valueResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String resolveEmbeddedValue(String value) &#123;</span><br><span class="line">        String result &#x3D; value;</span><br><span class="line">        for (StringValueResolver resolver : this.embeddedValueResolvers) &#123;</span><br><span class="line">            if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            result &#x3D; resolver.resolveStringValue(result);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) &#123;</span><br><span class="line">        Assert.notNull(beanPostProcessor, &quot;BeanPostProcessor must not be null&quot;);</span><br><span class="line">        this.beanPostProcessors.remove(beanPostProcessor);</span><br><span class="line">        this.beanPostProcessors.add(beanPostProcessor);</span><br><span class="line">        if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            this.hasInstantiationAwareBeanPostProcessors &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) &#123;</span><br><span class="line">            this.hasDestructionAwareBeanPostProcessors &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getBeanPostProcessorCount() &#123;</span><br><span class="line">        return this.beanPostProcessors.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the list of BeanPostProcessors that will get applied</span><br><span class="line">     * to beans created with this factory.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public List&lt;BeanPostProcessor&gt; getBeanPostProcessors() &#123;</span><br><span class="line">        return this.beanPostProcessors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return whether this factory holds a InstantiationAwareBeanPostProcessor</span><br><span class="line">     * that will get applied to singleton beans on shutdown.</span><br><span class="line">     * @see #addBeanPostProcessor</span><br><span class="line">     * @see org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean hasInstantiationAwareBeanPostProcessors() &#123;</span><br><span class="line">        return this.hasInstantiationAwareBeanPostProcessors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return whether this factory holds a DestructionAwareBeanPostProcessor</span><br><span class="line">     * that will get applied to singleton beans on shutdown.</span><br><span class="line">     * @see #addBeanPostProcessor</span><br><span class="line">     * @see org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean hasDestructionAwareBeanPostProcessors() &#123;</span><br><span class="line">        return this.hasDestructionAwareBeanPostProcessors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void registerScope(String scopeName, Scope scope) &#123;</span><br><span class="line">        Assert.notNull(scopeName, &quot;Scope identifier must not be null&quot;);</span><br><span class="line">        Assert.notNull(scope, &quot;Scope must not be null&quot;);</span><br><span class="line">        if (SCOPE_SINGLETON.equals(scopeName) || SCOPE_PROTOTYPE.equals(scopeName)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Cannot replace existing scopes &#39;singleton&#39; and &#39;prototype&#39;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.scopes.put(scopeName, scope);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getRegisteredScopeNames() &#123;</span><br><span class="line">        return StringUtils.toStringArray(this.scopes.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Scope getRegisteredScope(String scopeName) &#123;</span><br><span class="line">        Assert.notNull(scopeName, &quot;Scope identifier must not be null&quot;);</span><br><span class="line">        return this.scopes.get(scopeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Set the security context provider for this bean factory. If a security manager</span><br><span class="line">     * is set, interaction with the user code will be executed using the privileged</span><br><span class="line">     * of the provided security context.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void setSecurityContextProvider(SecurityContextProvider securityProvider) &#123;</span><br><span class="line">        this.securityContextProvider &#x3D; securityProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Delegate the creation of the access control context to the</span><br><span class="line">     * &#123;@link #setSecurityContextProvider SecurityContextProvider&#125;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public AccessControlContext getAccessControlContext() &#123;</span><br><span class="line">        return (this.securityContextProvider !&#x3D; null ?</span><br><span class="line">                this.securityContextProvider.getAccessControlContext() :</span><br><span class="line">                AccessController.getContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void copyConfigurationFrom(ConfigurableBeanFactory otherFactory) &#123;</span><br><span class="line">        Assert.notNull(otherFactory, &quot;BeanFactory must not be null&quot;);</span><br><span class="line">        setBeanClassLoader(otherFactory.getBeanClassLoader());</span><br><span class="line">        setCacheBeanMetadata(otherFactory.isCacheBeanMetadata());</span><br><span class="line">        setBeanExpressionResolver(otherFactory.getBeanExpressionResolver());</span><br><span class="line">        if (otherFactory instanceof AbstractBeanFactory) &#123;</span><br><span class="line">            AbstractBeanFactory otherAbstractFactory &#x3D; (AbstractBeanFactory) otherFactory;</span><br><span class="line">            this.customEditors.putAll(otherAbstractFactory.customEditors);</span><br><span class="line">            this.propertyEditorRegistrars.addAll(otherAbstractFactory.propertyEditorRegistrars);</span><br><span class="line">            this.beanPostProcessors.addAll(otherAbstractFactory.beanPostProcessors);</span><br><span class="line">            this.hasInstantiationAwareBeanPostProcessors &#x3D; this.hasInstantiationAwareBeanPostProcessors ||</span><br><span class="line">                    otherAbstractFactory.hasInstantiationAwareBeanPostProcessors;</span><br><span class="line">            this.hasDestructionAwareBeanPostProcessors &#x3D; this.hasDestructionAwareBeanPostProcessors ||</span><br><span class="line">                    otherAbstractFactory.hasDestructionAwareBeanPostProcessors;</span><br><span class="line">            this.scopes.putAll(otherAbstractFactory.scopes);</span><br><span class="line">            this.securityContextProvider &#x3D; otherAbstractFactory.securityContextProvider;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            setTypeConverter(otherFactory.getTypeConverter());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回合并后的bean定义（父Bean定义和子Bean定义合并）</span><br><span class="line">    public BeanDefinition getMergedBeanDefinition(String name) throws BeansException &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Efficiently check whether bean definition exists in this factory.</span><br><span class="line">        &#x2F;&#x2F;若Bean定义不存在，且本容器父工厂为ConfigurableBeanFactory的实例，让父工厂来调用这个方法</span><br><span class="line">        if (!containsBeanDefinition(beanName) &amp;&amp; getParentBeanFactory() instanceof ConfigurableBeanFactory) &#123;</span><br><span class="line">            return ((ConfigurableBeanFactory) getParentBeanFactory()).getMergedBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;否则直接从本地合并后的Bean定义中取</span><br><span class="line">        return getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isFactoryBean(String name) throws NoSuchBeanDefinitionException &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">        Object beanInstance &#x3D; getSingleton(beanName, false);</span><br><span class="line">        if (beanInstance !&#x3D; null) &#123;</span><br><span class="line">            return (beanInstance instanceof FactoryBean);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (containsSingleton(beanName)) &#123;</span><br><span class="line">            &#x2F;&#x2F; null instance registered</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; No singleton instance found -&gt; check bean definition.</span><br><span class="line">        if (!containsBeanDefinition(beanName) &amp;&amp; getParentBeanFactory() instanceof ConfigurableBeanFactory) &#123;</span><br><span class="line">            &#x2F;&#x2F; No bean definition found in this factory -&gt; delegate to parent.</span><br><span class="line">            return ((ConfigurableBeanFactory) getParentBeanFactory()).isFactoryBean(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return isFactoryBean(beanName, getMergedLocalBeanDefinition(beanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isActuallyInCreation(String beanName) &#123;</span><br><span class="line">        return isSingletonCurrentlyInCreation(beanName) || isPrototypeCurrentlyInCreation(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;    判断指定的原型是否正在被创建</span><br><span class="line">    protected boolean isPrototypeCurrentlyInCreation(String beanName) &#123;</span><br><span class="line">        Object curVal &#x3D; this.prototypesCurrentlyInCreation.get();</span><br><span class="line">        return (curVal !&#x3D; null &amp;&amp;</span><br><span class="line">                (curVal.equals(beanName) || (curVal instanceof Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;原型创建前回调，需要子类重写</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    protected void beforePrototypeCreation(String beanName) &#123;</span><br><span class="line">        Object curVal &#x3D; this.prototypesCurrentlyInCreation.get();</span><br><span class="line">        if (curVal &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;原型创建状态与当前线程绑定</span><br><span class="line">            this.prototypesCurrentlyInCreation.set(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (curVal instanceof String) &#123;</span><br><span class="line">            Set&lt;String&gt; beanNameSet &#x3D; new HashSet&lt;String&gt;(2);</span><br><span class="line">            beanNameSet.add((String) curVal);</span><br><span class="line">            beanNameSet.add(beanName);</span><br><span class="line">            this.prototypesCurrentlyInCreation.set(beanNameSet);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;这里多余了。。。</span><br><span class="line">        else &#123;</span><br><span class="line">            Set&lt;String&gt; beanNameSet &#x3D; (Set&lt;String&gt;) curVal;</span><br><span class="line">            beanNameSet.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建原型后，从当前线程解除绑定</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    protected void afterPrototypeCreation(String beanName) &#123;</span><br><span class="line">        Object curVal &#x3D; this.prototypesCurrentlyInCreation.get();</span><br><span class="line">        if (curVal instanceof String) &#123;</span><br><span class="line">            this.prototypesCurrentlyInCreation.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (curVal instanceof Set) &#123;</span><br><span class="line">            Set&lt;String&gt; beanNameSet &#x3D; (Set&lt;String&gt;) curVal;</span><br><span class="line">            beanNameSet.remove(beanName);</span><br><span class="line">            if (beanNameSet.isEmpty()) &#123;</span><br><span class="line">                this.prototypesCurrentlyInCreation.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroyBean(String beanName, Object beanInstance) &#123;</span><br><span class="line">        destroyBean(beanName, beanInstance, getMergedLocalBeanDefinition(beanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Destroy the given bean instance (usually a prototype instance</span><br><span class="line">     * obtained from this factory) according to the given bean definition.</span><br><span class="line">     * @param beanName the name of the bean definition</span><br><span class="line">     * @param beanInstance the bean instance to destroy</span><br><span class="line">     * @param mbd the merged bean definition</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void destroyBean(String beanName, Object beanInstance, RootBeanDefinition mbd) &#123;</span><br><span class="line">        new DisposableBeanAdapter(beanInstance, beanName, mbd, getBeanPostProcessors(), getAccessControlContext()).destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroyScopedBean(String beanName) &#123;</span><br><span class="line">        RootBeanDefinition mbd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        if (mbd.isSingleton() || mbd.isPrototype()) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;Bean name &#39;&quot; + beanName + &quot;&#39; does not correspond to an object in a mutable scope&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        String scopeName &#x3D; mbd.getScope();</span><br><span class="line">        Scope scope &#x3D; this.scopes.get(scopeName);</span><br><span class="line">        if (scope &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;No Scope SPI registered for scope &#39;&quot; + scopeName + &quot;&#39;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Object bean &#x3D; scope.remove(beanName);</span><br><span class="line">        if (bean !&#x3D; null) &#123;</span><br><span class="line">            destroyBean(beanName, bean, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line">    &#x2F;&#x2F; Implementation methods</span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;变换后的Bean名称（先去掉BeanFactory前缀，然后在aliasMap中取标准名）</span><br><span class="line">    protected String transformedBeanName(String name) &#123;</span><br><span class="line">        return canonicalName(BeanFactoryUtils.transformedBeanName(name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回原始的Bean名</span><br><span class="line">    protected String originalBeanName(String name) &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line">        if (name.startsWith(FACTORY_BEAN_PREFIX)) &#123;</span><br><span class="line">            beanName &#x3D; FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">        &#125;</span><br><span class="line">        return beanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Initialize the given BeanWrapper with the custom editors registered</span><br><span class="line">     * with this factory. To be called for BeanWrappers that will create</span><br><span class="line">     * and populate bean instances.</span><br><span class="line">     * &lt;p&gt;The default implementation delegates to &#123;@link #registerCustomEditors&#125;.</span><br><span class="line">     * Can be overridden in subclasses.</span><br><span class="line">     * @param bw the BeanWrapper to initialize</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void initBeanWrapper(BeanWrapper bw) &#123;</span><br><span class="line">        bw.setConversionService(getConversionService());</span><br><span class="line">        registerCustomEditors(bw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Initialize the given PropertyEditorRegistry with the custom editors</span><br><span class="line">     * that have been registered with this BeanFactory.</span><br><span class="line">     * &lt;p&gt;To be called for BeanWrappers that will create and populate bean</span><br><span class="line">     * instances, and for SimpleTypeConverter used for constructor argument</span><br><span class="line">     * and factory method type conversion.</span><br><span class="line">     * @param registry the PropertyEditorRegistry to initialize</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void registerCustomEditors(PropertyEditorRegistry registry) &#123;</span><br><span class="line">        PropertyEditorRegistrySupport registrySupport &#x3D;</span><br><span class="line">                (registry instanceof PropertyEditorRegistrySupport ? (PropertyEditorRegistrySupport) registry : null);</span><br><span class="line">        if (registrySupport !&#x3D; null) &#123;</span><br><span class="line">            registrySupport.useConfigValueEditors();</span><br><span class="line">        &#125;</span><br><span class="line">        if (!this.propertyEditorRegistrars.isEmpty()) &#123;</span><br><span class="line">            for (PropertyEditorRegistrar registrar : this.propertyEditorRegistrars) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    registrar.registerCustomEditors(registry);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (BeanCreationException ex) &#123;</span><br><span class="line">                    Throwable rootCause &#x3D; ex.getMostSpecificCause();</span><br><span class="line">                    if (rootCause instanceof BeanCurrentlyInCreationException) &#123;</span><br><span class="line">                        BeanCreationException bce &#x3D; (BeanCreationException) rootCause;</span><br><span class="line">                        if (isCurrentlyInCreation(bce.getBeanName())) &#123;</span><br><span class="line">                            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                                logger.debug(&quot;PropertyEditorRegistrar [&quot; + registrar.getClass().getName() +</span><br><span class="line">                                        &quot;] failed because it tried to obtain currently created bean &#39;&quot; +</span><br><span class="line">                                        ex.getBeanName() + &quot;&#39;: &quot; + ex.getMessage());</span><br><span class="line">                            &#125;</span><br><span class="line">                            onSuppressedException(ex);</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    throw ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!this.customEditors.isEmpty()) &#123;</span><br><span class="line">            for (Map.Entry&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; entry : this.customEditors.entrySet()) &#123;</span><br><span class="line">                Class&lt;?&gt; requiredType &#x3D; entry.getKey();</span><br><span class="line">                Class&lt;? extends PropertyEditor&gt; editorClass &#x3D; entry.getValue();</span><br><span class="line">                registry.registerCustomEditor(requiredType, BeanUtils.instantiateClass(editorClass));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回一个合并后的根Bean定义（父Bean定义和子Bean定义合并）（从当前容器取）</span><br><span class="line">    protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException &#123;</span><br><span class="line">        &#x2F;&#x2F; Quick check on the concurrent map first, with minimal locking.</span><br><span class="line">        RootBeanDefinition mbd &#x3D; this.mergedBeanDefinitions.get(beanName);&#x2F;&#x2F;首先直接从合并根定义集合中取</span><br><span class="line">        if (mbd !&#x3D; null) &#123;</span><br><span class="line">            return mbd;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;根据bean名和其对应的Bean定义，取其根Bean根定义</span><br><span class="line">        return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据Bean名和Bean定义取其Bean根定义</span><br><span class="line">    protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd)</span><br><span class="line">            throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">        return getMergedBeanDefinition(beanName, bd, null);&#x2F;&#x2F;调用重载方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据Bean名称返回根定义（若给定的Bean定义为子Bean定义，那么合并它的父Bean定义）</span><br><span class="line">    protected RootBeanDefinition getMergedBeanDefinition(</span><br><span class="line">            String beanName, BeanDefinition bd, BeanDefinition containingBd)</span><br><span class="line">            throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">        synchronized (this.mergedBeanDefinitions) &#123;</span><br><span class="line">            RootBeanDefinition mbd &#x3D; null;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;若给定的Bean定义并没有包含子Bean定义，那么直接根据Bean名取根定义</span><br><span class="line">            if (containingBd &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mbd &#x3D; this.mergedBeanDefinitions.get(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mbd &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;若取不到</span><br><span class="line">                if (bd.getParentName() &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;若Bean定义没有父类，就很简单了</span><br><span class="line">                    if (bd instanceof RootBeanDefinition) &#123;&#x2F;&#x2F;若Bean定义是RootBeanDefinition的实例，克隆、强转后返回</span><br><span class="line">                        mbd &#x3D; ((RootBeanDefinition) bd).cloneBeanDefinition();</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;&#x2F;&#x2F;否则，根据Bean定义，来构造一个根Bean定义</span><br><span class="line">                        mbd &#x3D; new RootBeanDefinition(bd);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;&#x2F;&#x2F;若Bean定义有父类</span><br><span class="line">                    &#x2F;&#x2F; Child bean definition: needs to be merged with parent.</span><br><span class="line">                    BeanDefinition pbd;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        String parentBeanName &#x3D; transformedBeanName(bd.getParentName());&#x2F;&#x2F;取其父Bean定义的名字</span><br><span class="line">                        if (!beanName.equals(parentBeanName)) &#123;&#x2F;&#x2F;若Bean名字并不是bd的父Bean的名字</span><br><span class="line">                            pbd &#x3D; getMergedBeanDefinition(parentBeanName);&#x2F;&#x2F;根据父Bean定义名称来返回合并后的bean定义</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;&#x2F;&#x2F;如果beanName对应的Bean就是bd的父Bean</span><br><span class="line">                            if (getParentBeanFactory() instanceof ConfigurableBeanFactory) &#123;&#x2F;&#x2F;若父Bean工厂为ConfigurableBeanFactory的实例</span><br><span class="line">                                &#x2F;&#x2F;    那么强转成ConfigurableBeanFactory后再调用合并方法</span><br><span class="line">                                pbd &#x3D; ((ConfigurableBeanFactory) getParentBeanFactory()).getMergedBeanDefinition(parentBeanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;&#x2F;&#x2F;若父Bean工厂不是ConfigurableBeanFactory的实例，就抛出异常</span><br><span class="line">                                throw new NoSuchBeanDefinitionException(bd.getParentName(),</span><br><span class="line">                                        &quot;Parent name &#39;&quot; + bd.getParentName() + &quot;&#39; is equal to bean name &#39;&quot; + beanName +</span><br><span class="line">                                        &quot;&#39;: cannot be resolved without an AbstractBeanFactory parent&quot;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                        throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName,</span><br><span class="line">                                &quot;Could not resolve parent bean definition &#39;&quot; + bd.getParentName() + &quot;&#39;&quot;, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 深度复制</span><br><span class="line">                    mbd &#x3D; new RootBeanDefinition(pbd);&#x2F;&#x2F;根据Bean定义生成一个根Bean定义</span><br><span class="line">                    mbd.overrideFrom(bd);&#x2F;&#x2F;将Bean定义的属性复制进自己的定义（根Bean定义）中</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!StringUtils.hasLength(mbd.getScope())) &#123;&#x2F;&#x2F;如果根Bean定义未设置范围</span><br><span class="line">                    mbd.setScope(RootBeanDefinition.SCOPE_SINGLETON);&#x2F;&#x2F;那么设置其范围为单例</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;    若本根Bean定义包含Bean定义、本根Bean定义为单例且包含的Bean定义并不是单例</span><br><span class="line">                if (containingBd !&#x3D; null &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;</span><br><span class="line">                    mbd.setScope(containingBd.getScope());&#x2F;&#x2F;    那么将本根Bean定义的范围设置为包含的Bean定义的范围</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;若本根Bean定义不包含Bean定义，且是缓存Bean元数据（重写前均为true）且Bean定义是否有资格缓存（默认实现是，这个Bean已经创建便有资格）</span><br><span class="line">                if (containingBd &#x3D;&#x3D; null &amp;&amp; isCacheBeanMetadata() &amp;&amp; isBeanEligibleForMetadataCaching(beanName)) &#123;</span><br><span class="line">                    this.mergedBeanDefinitions.put(beanName, mbd);&#x2F;&#x2F;放进mergedBeanDefinitions中</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return mbd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;检查Bean定义，抛出异常</span><br><span class="line">    protected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, Object[] args)</span><br><span class="line">            throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">        if (mbd.isAbstract()) &#123;</span><br><span class="line">            throw new BeanIsAbstractException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (args !&#x3D; null &amp;&amp; !mbd.isPrototype()) &#123;</span><br><span class="line">            throw new BeanDefinitionStoreException(</span><br><span class="line">                    &quot;Can only specify arguments for the getBean method when referring to a prototype bean definition&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Remove the merged bean definition for the specified bean,</span><br><span class="line">     * recreating it on next access.</span><br><span class="line">     * @param beanName the bean name to clear the merged definition for</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void clearMergedBeanDefinition(String beanName) &#123;</span><br><span class="line">        this.mergedBeanDefinitions.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;解析类型，处理异常</span><br><span class="line">    protected Class&lt;?&gt; resolveBeanClass(final RootBeanDefinition mbd, String beanName, final Class&lt;?&gt;... typesToMatch)</span><br><span class="line">            throws CannotLoadBeanClassException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (mbd.hasBeanClass()) &#123;</span><br><span class="line">                return mbd.getBeanClass();</span><br><span class="line">            &#125;</span><br><span class="line">            if (System.getSecurityManager() !&#x3D; null) &#123;</span><br><span class="line">                return AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                    public Class&lt;?&gt; run() throws Exception &#123;</span><br><span class="line">                        return doResolveBeanClass(mbd, typesToMatch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return doResolveBeanClass(mbd, typesToMatch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (PrivilegedActionException pae) &#123;</span><br><span class="line">            ClassNotFoundException ex &#x3D; (ClassNotFoundException) pae.getException();</span><br><span class="line">            throw new CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (ClassNotFoundException ex) &#123;</span><br><span class="line">            throw new CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (LinkageError err) &#123;</span><br><span class="line">            throw new CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 真正的解析类型</span><br><span class="line">    private Class&lt;?&gt; doResolveBeanClass(RootBeanDefinition mbd, Class&lt;?&gt;... typesToMatch) throws ClassNotFoundException &#123;</span><br><span class="line">        if (!ObjectUtils.isEmpty(typesToMatch)) &#123;</span><br><span class="line">            ClassLoader tempClassLoader &#x3D; getTempClassLoader();&#x2F;&#x2F;找到临时的类加载器</span><br><span class="line">            if (tempClassLoader !&#x3D; null) &#123;</span><br><span class="line">                if (tempClassLoader instanceof DecoratingClassLoader) &#123;&#x2F;&#x2F;若为装饰类加载器</span><br><span class="line">                    DecoratingClassLoader dcl &#x3D; (DecoratingClassLoader) tempClassLoader;</span><br><span class="line">                    for (Class&lt;?&gt; typeToMatch : typesToMatch) &#123;</span><br><span class="line">                        dcl.excludeClass(typeToMatch.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                String className &#x3D; mbd.getBeanClassName();</span><br><span class="line">                return (className !&#x3D; null ? ClassUtils.forName(className, tempClassLoader) : null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mbd.resolveBeanClass(getBeanClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Evaluate the given String as contained in a bean definition,</span><br><span class="line">     * potentially resolving it as an expression.</span><br><span class="line">     * @param value the value to check</span><br><span class="line">     * @param beanDefinition the bean definition that the value comes from</span><br><span class="line">     * @return the resolved value</span><br><span class="line">     * @see #setBeanExpressionResolver</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected Object evaluateBeanDefinitionString(String value, BeanDefinition beanDefinition) &#123;</span><br><span class="line">        if (this.beanExpressionResolver &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">        Scope scope &#x3D; (beanDefinition !&#x3D; null ? getRegisteredScope(beanDefinition.getScope()) : null);</span><br><span class="line">        return this.beanExpressionResolver.evaluate(value, new BeanExpressionContext(this, scope));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;预测类型</span><br><span class="line">    protected Class&lt;?&gt; predictBeanType(String beanName, RootBeanDefinition mbd, Class&lt;?&gt;... typesToMatch) &#123;</span><br><span class="line">        &#x2F;&#x2F;若根Bena定义的工厂方法名存在，说明它是工厂Bean创建的，无法预测类型？</span><br><span class="line">        if (mbd.getFactoryMethodName() !&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;否则，解析Bean的Class</span><br><span class="line">        return resolveBeanClass(mbd, beanName, typesToMatch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Check whether the given bean is defined as a &#123;@link FactoryBean&#125;.</span><br><span class="line">     * @param beanName the name of the bean</span><br><span class="line">     * @param mbd the corresponding bean definition</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean isFactoryBean(String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line">        Class&lt;?&gt; beanType &#x3D; predictBeanType(beanName, mbd, FactoryBean.class);</span><br><span class="line">        return (beanType !&#x3D; null &amp;&amp; FactoryBean.class.isAssignableFrom(beanType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回工厂Bean的类型</span><br><span class="line">    protected Class&lt;?&gt; getTypeForFactoryBean(String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line">        if (!mbd.isSingleton()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            FactoryBean&lt;?&gt; factoryBean &#x3D; doGetBean(FACTORY_BEAN_PREFIX + beanName, FactoryBean.class, null, true);</span><br><span class="line">            return getTypeForFactoryBean(factoryBean);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (BeanCreationException ex) &#123;</span><br><span class="line">            &#x2F;&#x2F; Can only happen when getting a FactoryBean.</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Ignoring bean creation exception on FactoryBean type check: &quot; + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            onSuppressedException(ex);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;标记这个Bean已经被创建</span><br><span class="line">    protected void markBeanAsCreated(String beanName) &#123;</span><br><span class="line">        this.alreadyCreated.put(beanName, Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Determine whether the specified bean is eligible for having</span><br><span class="line">     * its bean definition metadata cached.</span><br><span class="line">     * @param beanName the name of the bean</span><br><span class="line">     * @return &#123;@code true&#125; if the bean&#39;s metadata may be cached</span><br><span class="line">     * at this point already</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;若本根Bean定义包含Bean元定义作为缓存，这个方法应被之类覆盖，这里仅判断Bean是否已经被创建</span><br><span class="line">    protected boolean isBeanEligibleForMetadataCaching(String beanName) &#123;</span><br><span class="line">        return this.alreadyCreated.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Remove the singleton instance (if any) for the given bean name,</span><br><span class="line">     * but only if it hasn&#39;t been used for other purposes than type checking.</span><br><span class="line">     * @param beanName the name of the bean</span><br><span class="line">     * @return &#123;@code true&#125; if actually removed, &#123;@code false&#125; otherwise</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean removeSingletonIfCreatedForTypeCheckOnly(String beanName) &#123;</span><br><span class="line">        if (!this.alreadyCreated.containsKey(beanName)) &#123;</span><br><span class="line">            removeSingleton(beanName);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例</span><br><span class="line">    protected Object getObjectForBeanInstance(</span><br><span class="line">            Object beanInstance, String name, String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果这个Bean是工厂Bean创建的 且 这个Bean实例并不是FactoryBean实例，抛异常</span><br><span class="line">        if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">            throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果这个Bean实例并不是FactoryBean实例 或 这个Bean是工厂Bean创建的，直接返回</span><br><span class="line">        if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">            return beanInstance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;——————————以下都是 这个Bean实例是FactoryBean实例的情况</span><br><span class="line">        Object object &#x3D; null;</span><br><span class="line">        if (mbd &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;若根Bean定义为空，取这个BeanFactory所生产的实例</span><br><span class="line">            object &#x3D; getCachedObjectForFactoryBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        if (object &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;若取不到，那么手动取</span><br><span class="line">            FactoryBean&lt;?&gt; factory &#x3D; (FactoryBean&lt;?&gt;) beanInstance;&#x2F;&#x2F;把这个实例转化成一个FactoryBean</span><br><span class="line">            &#x2F;&#x2F; Caches object obtained from FactoryBean if it is a singleton.</span><br><span class="line">            if (mbd &#x3D;&#x3D; null &amp;&amp; containsBeanDefinition(beanName)) &#123;&#x2F;&#x2F;若根Bean定义为空，但是容器内有Bean定义</span><br><span class="line">                mbd &#x3D; getMergedLocalBeanDefinition(beanName);&#x2F;&#x2F;返回合并后的Bean定义</span><br><span class="line">            &#125;</span><br><span class="line">            boolean synthetic &#x3D; (mbd !&#x3D; null &amp;&amp; mbd.isSynthetic());&#x2F;&#x2F;标记这个Bean定义是合并的</span><br><span class="line">            object &#x3D; getObjectFromFactoryBean(factory, beanName, !synthetic);&#x2F;&#x2F;从工厂Bean中取</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断给定的Bean是否被使用过</span><br><span class="line">    public boolean isBeanNameInUse(String beanName) &#123;</span><br><span class="line">        &#x2F;&#x2F;若是别名 或 并非工厂bean生产出来的 或 被其他某个bean所依赖，那么判断其被使用过</span><br><span class="line">        return isAlias(beanName) || containsLocalBean(beanName) || hasDependentBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Determine whether the given bean requires destruction on shutdown.</span><br><span class="line">     * &lt;p&gt;The default implementation checks the DisposableBean interface as well as</span><br><span class="line">     * a specified destroy method and registered DestructionAwareBeanPostProcessors.</span><br><span class="line">     * @param bean the bean instance to check</span><br><span class="line">     * @param mbd the corresponding bean definition</span><br><span class="line">     * @see org.springframework.beans.factory.DisposableBean</span><br><span class="line">     * @see AbstractBeanDefinition#getDestroyMethodName()</span><br><span class="line">     * @see org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean requiresDestruction(Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">        return (bean !&#x3D; null &amp;&amp;</span><br><span class="line">                (DisposableBeanAdapter.hasDestroyMethod(bean, mbd) || hasDestructionAwareBeanPostProcessors()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Add the given bean to the list of disposable beans in this factory,</span><br><span class="line">     * registering its DisposableBean interface and&#x2F;or the given destroy method</span><br><span class="line">     * to be called on factory shutdown (if applicable). Only applies to singletons.</span><br><span class="line">     * @param beanName the name of the bean</span><br><span class="line">     * @param bean the bean instance</span><br><span class="line">     * @param mbd the bean definition for the bean</span><br><span class="line">     * @see RootBeanDefinition#isSingleton</span><br><span class="line">     * @see RootBeanDefinition#getDependsOn</span><br><span class="line">     * @see #registerDisposableBean</span><br><span class="line">     * @see #registerDependentBean</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">        AccessControlContext acc &#x3D; (System.getSecurityManager() !&#x3D; null ? getAccessControlContext() : null);</span><br><span class="line">        if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) &#123;</span><br><span class="line">            if (mbd.isSingleton()) &#123;</span><br><span class="line">                &#x2F;&#x2F; Register a DisposableBean implementation that performs all destruction</span><br><span class="line">                &#x2F;&#x2F; work for the given bean: DestructionAwareBeanPostProcessors,</span><br><span class="line">                &#x2F;&#x2F; DisposableBean interface, custom destroy method.</span><br><span class="line">                registerDisposableBean(beanName,</span><br><span class="line">                        new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                &#x2F;&#x2F; A bean with a custom scope...</span><br><span class="line">                Scope scope &#x3D; this.scopes.get(mbd.getScope());</span><br><span class="line">                if (scope &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;No Scope registered for scope &#39;&quot; + mbd.getScope() + &quot;&#39;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                scope.registerDestructionCallback(beanName,</span><br><span class="line">                        new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line">    &#x2F;&#x2F; Abstract methods to be implemented by subclasses</span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;标记是否包含Bean定义的方法</span><br><span class="line">    protected abstract boolean containsBeanDefinition(String beanName);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据Bean名返回其BeanDefinition</span><br><span class="line">    protected abstract BeanDefinition getBeanDefinition(String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据指定的bean定义和bean名、参数，创建对象</span><br><span class="line">    protected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args)</span><br><span class="line">            throws BeanCreationException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>FactoryBeanRegistrySupport，并且实现了BeanFactory重要的第三级接口——ConfigurableBeanFactory。需要具体了解这个接口，可以去看我之前的接口分析——Spring源码分析——BeanFactory体系之接口详细分析 。ConfigurableBeanFactory是一个非常复杂的接口，继承了HierarchicalBeanFactory和SingletonBeanRegistry，主要实现了工厂创建、注册Bean、单例类注册等各种功能。</p>
<p>　　AbstractBeanFactory实现了ConfigurableBeanFactory接口的绝大多数方法，实现了Bean工厂的许多重要功能，如BeanDefinition、RootBeanDefinition、原型、单例相关的各种操作。</p>
<p>　　下面列出一些主要方法实现，其他的方法说明，可具体参照上文我贴出的大部分注释过的源码。</p>
<p>（1）、从容器中获取bean的方法——doGetBean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    protected &lt;T&gt; T doGetBean(</span><br><span class="line">            final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</span><br><span class="line">            throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">        final String beanName &#x3D; transformedBeanName(name);&#x2F;&#x2F;在aliasMap中取得的标准名</span><br><span class="line">        Object bean;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Eagerly check singleton cache for manually registered singletons.</span><br><span class="line">        Object sharedInstance &#x3D; getSingleton(beanName);&#x2F;&#x2F;首先在单例集合中取</span><br><span class="line">        if (sharedInstance !&#x3D; null &amp;&amp; args &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;如果取得到，没有指定参数</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;&#x2F;&#x2F;若Log允许调试</span><br><span class="line">                if (isSingletonCurrentlyInCreation(beanName)) &#123;&#x2F;&#x2F;若正准备创建，输出日志</span><br><span class="line">                    logger.debug(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +</span><br><span class="line">                            &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;&#x2F;&#x2F;根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例</span><br><span class="line">            bean &#x3D; getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line">            if (isPrototypeCurrentlyInCreation(beanName)) &#123;&#x2F;&#x2F;如果正在被创建，就抛出异常</span><br><span class="line">                throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();&#x2F;&#x2F;取本容器的父容器</span><br><span class="line">            if (parentBeanFactory !&#x3D; null &amp;&amp; !containsBeanDefinition(beanName)) &#123;&#x2F;&#x2F;若存在父容器，且本容器不存在对应的Bean定义</span><br><span class="line">                String nameToLookup &#x3D; originalBeanName(name);&#x2F;&#x2F;取原始的Bean名</span><br><span class="line">                if (args !&#x3D; null) &#123;&#x2F;&#x2F;若参数列表存在</span><br><span class="line">                    &#x2F;&#x2F; 那么用父容器根据原始Bean名和参数列表返回</span><br><span class="line">                    return (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 参数列表不要求，那就直接根据原始名称和要求的类型返回</span><br><span class="line">                    return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果不需要类型检查，标记其已经被创建</span><br><span class="line">            if (!typeCheckOnly) &#123;</span><br><span class="line">                markBeanAsCreated(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;根据beanName取其根Bean定义</span><br><span class="line">            final RootBeanDefinition mbd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            String[] dependsOn &#x3D; mbd.getDependsOn();&#x2F;&#x2F;得到这个根定义的所有依赖</span><br><span class="line">            if (dependsOn !&#x3D; null) &#123;</span><br><span class="line">                for (String dependsOnBean : dependsOn) &#123;</span><br><span class="line">                    getBean(dependsOnBean);&#x2F;&#x2F;注册这个Bean</span><br><span class="line">                    &#x2F;&#x2F;注册一个Bean和依赖于它的Bean（后参数依赖前参数）</span><br><span class="line">                    registerDependentBean(dependsOnBean, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果Bean定义是单例，就在返回单例</span><br><span class="line">            if (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance &#x3D; getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                    public Object getObject() throws BeansException &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            return createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        catch (BeansException ex) &#123;</span><br><span class="line">                            destroySingleton(beanName);</span><br><span class="line">                            throw ex;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                &#x2F;&#x2F;根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例</span><br><span class="line">                bean &#x3D; getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果是原型</span><br><span class="line">            else if (mbd.isPrototype()) &#123;</span><br><span class="line">                &#x2F;&#x2F; It&#39;s a prototype -&gt; create a new instance.</span><br><span class="line">                Object prototypeInstance &#x3D; null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);&#x2F;&#x2F;原型创建前，与当前线程绑定</span><br><span class="line">                    prototypeInstance &#x3D; createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                finally &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);&#x2F;&#x2F;原型创建后，与当前线程解除绑定</span><br><span class="line">                &#125;</span><br><span class="line">                bean &#x3D; getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            else &#123;&#x2F;&#x2F;既不是单例又不是原型的情况</span><br><span class="line">                String scopeName &#x3D; mbd.getScope();</span><br><span class="line">                final Scope scope &#x3D; this.scopes.get(scopeName);&#x2F;&#x2F;得到范围</span><br><span class="line">                if (scope &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;No Scope registered for scope &#39;&quot; + scopeName + &quot;&#39;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;&#x2F;&#x2F;根据范围创建实例</span><br><span class="line">                    Object scopedInstance &#x3D; scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                        public Object getObject() throws BeansException &#123;</span><br><span class="line">                            beforePrototypeCreation(beanName);</span><br><span class="line">                            try &#123;</span><br><span class="line">                                return createBean(beanName, mbd, args);&#x2F;&#x2F;原型创建前，与当前线程绑定</span><br><span class="line">                            &#125;</span><br><span class="line">                            finally &#123;</span><br><span class="line">                                &#x2F;&#x2F;&#x2F;&#x2F;原型创建后，与当前线程解除绑定</span><br><span class="line">                                afterPrototypeCreation(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    &#x2F;&#x2F;根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例</span><br><span class="line">                    bean &#x3D; getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (IllegalStateException ex) &#123;</span><br><span class="line">                    throw new BeanCreationException(beanName,</span><br><span class="line">                            &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; &quot; +</span><br><span class="line">                            &quot;consider defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,</span><br><span class="line">                            ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断要求的类型是否和Bean实例的类型正在匹配</span><br><span class="line">        if (requiredType !&#x3D; null &amp;&amp; bean !&#x3D; null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return getTypeConverter().convertIfNecessary(bean, requiredType);&#x2F;&#x2F;转换类型，不抛出异常就说明类型匹配</span><br><span class="line">            &#125;</span><br><span class="line">            catch (TypeMismatchException ex) &#123;</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type [&quot; +</span><br><span class="line">                            ClassUtils.getQualifiedName(requiredType) + &quot;]&quot;, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (T) bean;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面对这个方法进行简要的解释：</p>
<p>　　&lt;1&gt;、这个方法形参为final String name, final Class<T> requiredType, final Object[] args, boolean typeCheckOnly，分别表示Bean的名称、要求返回的Bean的类型、取Bean时提供的参数数组 以及 是否需要类型检查。哦</p>
<p>　　&lt;2&gt;、final String beanName = transformedBeanName(name); 这个方法是从aliasMap中取得对应的标准名。方法实现是，首先去掉name的 FACTORY_BEAN_PREFIX 前缀（如果是工厂Bean本身，那么Bean名有这个前缀），然后调用SimpleAliasRegistry的canonicalName方法。上篇博客已经介绍过SimpleAliasRegistry了，这里贴一下这个方法的源码：</p>
<p>/*<br>     * 根据name这个Key，在aliasMap中不断循环的取对应的value，如果取得到，就继续根据这个value取值，不断循环继续。<br>     * 直到取不到，就把这个在aliasMap中无对应值的key返回。这个动作，叫规范名<br>     */</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String canonicalName(String name) &#123;</span><br><span class="line">    String canonicalName &#x3D; name;    &#x2F;&#x2F;规范名</span><br><span class="line">    &#x2F;&#x2F; Handle aliasing...</span><br><span class="line">    String resolvedName;&#x2F;&#x2F;已解析名</span><br><span class="line">    do &#123;</span><br><span class="line">        resolvedName &#x3D; this.aliasMap.get(canonicalName);&#x2F;&#x2F;aliasMap中规范名对应的值赋值给已解析名</span><br><span class="line">        if (resolvedName !&#x3D; null) &#123;&#x2F;&#x2F;如果已解析名存在（即规范名在aliasMap中有对应的值）</span><br><span class="line">            canonicalName &#x3D; resolvedName;   &#x2F;&#x2F; 这个已解析名赋值给标准名</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (resolvedName !&#x3D; null);&#x2F;&#x2F;不断循环，直到已解析名不存在</span><br><span class="line">    return canonicalName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　&lt;3&gt;、首先根据标准名beanName，在单例缓存中取对应的Bean：Object sharedInstance = getSingleton(beanName);</p>
<p>　　&lt;4&gt;、如果取得到，且args为空，根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例：bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);然后结束整个方法。这个方法源码如下：</p>
<p>//根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">protected Object getObjectForBeanInstance(</span><br><span class="line">            Object beanInstance, String name, String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果这个Bean是工厂Bean创建的 且 这个Bean实例并不是FactoryBean实例，抛异常</span><br><span class="line">        if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">            throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果这个Bean实例并不是FactoryBean实例 或 这个Bean是工厂Bean创建的，直接返回</span><br><span class="line">        if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">            return beanInstance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;——————————以下都是 这个Bean实例是FactoryBean实例的情况</span><br><span class="line">        Object object &#x3D; null;</span><br><span class="line">        if (mbd &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;若根Bean定义为空，取这个BeanFactory所生产的实例</span><br><span class="line">            object &#x3D; getCachedObjectForFactoryBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        if (object &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;若取不到，那么手动取</span><br><span class="line">            FactoryBean&lt;?&gt; factory &#x3D; (FactoryBean&lt;?&gt;) beanInstance;&#x2F;&#x2F;把这个实例转化成一个FactoryBean</span><br><span class="line">            &#x2F;&#x2F; Caches object obtained from FactoryBean if it is a singleton.</span><br><span class="line">            if (mbd &#x3D;&#x3D; null &amp;&amp; containsBeanDefinition(beanName)) &#123;&#x2F;&#x2F;若根Bean定义为空，但是容器内有Bean定义</span><br><span class="line">                mbd &#x3D; getMergedLocalBeanDefinition(beanName);&#x2F;&#x2F;返回合并后的Bean定义</span><br><span class="line">            &#125;</span><br><span class="line">            boolean synthetic &#x3D; (mbd !&#x3D; null &amp;&amp; mbd.isSynthetic());&#x2F;&#x2F;标记这个Bean定义是合并的</span><br><span class="line">            object &#x3D; getObjectFromFactoryBean(factory, beanName, !synthetic);&#x2F;&#x2F;从工厂Bean中取</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>　　&lt;5&gt;、如果取不到、或 args 不为空（下面都是基于这个条件）：</p>
<p>（如果对应的Bean正在被创建，就抛出异常）首先用父容器（如果本容器有的话）根据给出的形参取对应的Bean。</p>
<p>　　&lt;6&gt;、此时，判断，如果不需要类型检查，标记其已经被创建。</p>
<p>　　&lt;7&gt;、根据beanName取本地合并后的RootBeanDefinition（这个方法getMergedLocalBeanDefinition涉及到多层BeanDefinition相关的调用），然后检查一下。然后根据这个RootBeanDefinition，注册这个Bean和它的所有依赖。</p>
<p>　　&lt;8&gt;、如果这个RootBeanDefinition是单例，先根据beanName从单例缓存中取，取不到就创建一个匿名内部Bean工厂，创建一个单例，直接结束方法。</p>
<p>　　&lt;9&gt;、如果这个RootBeanDefinition是原型，就直接创建一个Bean返回，并在创建前把beanName与当前线程绑定，创建后解绑。</p>
<p>　　&lt;10&gt;、如果这个RootBeanDefinition既不是单例，又不是原型，那么根据这个RootBeanDefinition定义的范围Scope，直接创建一个scopedInstance。</p>
<p>　　&lt;11&gt;、若这个scopedInstance为工厂Bean，就得到它创建的实例，否则得到它自身。</p>
<p>　　&lt;12&gt;、对&lt;9&gt;或&lt;11&gt;中最后产生的Bean就进行一次检查，要求这个产生的Bean的类型是否和Bean实例的类型匹配，不匹配就抛出异常。</p>
<p>　　以上就是这个doGetBean方法了。</p>

    </div>

    
    
    <!-- 文章末尾分割线 -->
    <div style="text-align:center;color: #ccc;font-size:14px;">
        -------------
        <i class="fa fa-paw"></i>Thank you for reading<i class="fa fa-paw"></i>
        -------------
    </div>
<div>
    <hr/>
</div>



      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/spring/" rel="tag"># spring</a>
              <a href="/tags/ioc/" rel="tag"># ioc</a>
              <a href="/tags/bean/" rel="tag"># bean</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/25/java%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%A1%AB%E5%85%85/" rel="prev" title="java数组的复制与填充">
      <i class="fa fa-chevron-left"></i> java数组的复制与填充
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/22/%E6%A8%A1%E6%8B%9F%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85/" rel="next" title="模拟微信抢红包">
      模拟微信抢红包 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    

  </article>
  
  
  


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

	

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81BeanFactory%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E6%8E%A5%E5%8F%A3%E4%B8%BA%E4%B8%BB%EF%BC%89%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">一、BeanFactory的基本类体系结构（接口为主）：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81IOC%E7%9A%84%E5%A7%8B%E7%A5%96%E2%80%94%E2%80%94BeanFactory"><span class="nav-number">2.</span> <span class="nav-text">二、IOC的始祖——BeanFactory</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%8F%AF%E5%B0%86Bean%E9%80%90%E4%B8%80%E5%88%97%E5%87%BA%E7%9A%84%E5%B7%A5%E5%8E%82%E2%80%94%E2%80%94ListableBeanFactory"><span class="nav-number">3.</span> <span class="nav-text">三、可将Bean逐一列出的工厂——ListableBeanFactory</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%88%86%E5%B1%82%E7%9A%84Bean%E5%B7%A5%E5%8E%82%E2%80%94%E2%80%94HierarchicalBeanFactory"><span class="nav-number">4.</span> <span class="nav-text">四、分层的Bean工厂——HierarchicalBeanFactory</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84Bean%E5%B7%A5%E5%8E%82%E2%80%94%E2%80%94AutowireCapableBeanFactory"><span class="nav-number">5.</span> <span class="nav-text">五、自动装配的Bean工厂——AutowireCapableBeanFactory</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%A4%8D%E6%9D%82%E7%9A%84%E9%85%8D%E7%BD%AEBean%E5%B7%A5%E5%8E%82%E2%80%94%E2%80%94ConfigurableBeanFactory"><span class="nav-number">6.</span> <span class="nav-text">六、复杂的配置Bean工厂——ConfigurableBeanFactory</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81BeanFactory%E7%9A%84%E9%9B%86%E5%A4%A7%E6%88%90%E8%80%85%E2%80%94%E2%80%94ConfigurableListableBeanFactory"><span class="nav-number">7.</span> <span class="nav-text">七、BeanFactory的集大成者——ConfigurableListableBeanFactory</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E9%A2%9D%E5%A4%96%E7%9A%84%E6%8E%A5%E5%8F%A3%E2%80%94%E2%80%94BeanDefinitionRegistry"><span class="nav-number">8.</span> <span class="nav-text">八、额外的接口——BeanDefinitionRegistry</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81BeanFactory%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%88%E7%B1%BB%E4%B8%BA%E4%B8%BB%EF%BC%89%EF%BC%9A"><span class="nav-number">9.</span> <span class="nav-text">一、BeanFactory的基本类体系结构（类为主）：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%AB%E5%90%8D%E6%B3%A8%E5%86%8C%E5%99%A8%E2%80%94%E2%80%94SimpleAliasRegistry"><span class="nav-number">10.</span> <span class="nav-text">二、简单的别名注册器——SimpleAliasRegistry</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%BB%98%E8%AE%A4%E5%8D%95%E4%BE%8B%E6%B3%A8%E5%86%8C%E7%B1%BB%E2%80%94%E2%80%94DefaultSingletonBeanRegistry"><span class="nav-number">11.</span> <span class="nav-text">三、默认单例注册类——DefaultSingletonBeanRegistry</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%B7%A5%E5%8E%82Bean%E6%B3%A8%E5%86%8C%E6%94%AF%E6%8C%81%E2%80%94%E2%80%94FactoryBeanRegistrySupport"><span class="nav-number">12.</span> <span class="nav-text">一、工厂Bean注册支持——FactoryBeanRegistrySupport</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="songsong"
      src="/images/face.jpg">
  <p class="site-author-name" itemprop="name">songsong</p>
  <div class="site-description" itemprop="description">我就是我，不一样的烟火</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:songsong@whut.edu.cn" title="E-Mail → mailto:songsong@whut.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/15287480608" title="WeChat → 15287480608"><i class="fab fa-wechat fa-fw"></i>WeChat</a>
      </span>
  </div>


      </div>
 <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=2611717571&auto=1&height=66"></iframe>
<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
<div class="widget-wrap">
    <div id="myCanvasContainer" class="widget tagcloud">
        <canvas width="200" height="200" id="resCanvas" style="width=100%">
            <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BDD/" rel="tag">BDD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BugBash/" rel="tag">BugBash</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CodingPages/" rel="tag">CodingPages</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GithubPages/" rel="tag">GithubPages</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Next/" rel="tag">Next</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OWASP/" rel="tag">OWASP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEO/" rel="tag">SEO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TED/" rel="tag">TED</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life/" rel="tag">life</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%A6%E5%8D%95/" rel="tag">书单</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%BA%E7%94%9F/" rel="tag">人生</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%BA%E7%94%9F%E8%A7%84%E5%88%92/" rel="tag">人生规划</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%91%8A%E5%88%AB%E6%8B%96%E5%BB%B6/" rel="tag">告别拖延</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%8F%E6%8D%B7%E6%B5%8B%E8%AF%95/" rel="tag">敏捷开发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%85%E8%A1%8C/" rel="tag">旅行</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%AA%E6%9D%A5/" rel="tag">未来</a><span 
        </canvas>
    </div>
</div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="" style="text-align:center;">
        

        

<div class="copyright" color="#fff">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">songsong</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">109k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">6:35</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













      

      

<style>
.comments {
  opacity: 1; 
  display: block;
  background-color: rgba(255, 255, 255, 0.9);
}
 .v {
  opacity: 1; 
  display: block;
  background-color: rgba(255, 255, 255, 0.9);
}

.vpower{
  display: none;
}
 .txt-right {
  display: none;
}
</style>
<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'pNwyIX9xDf3XglQVPG38RGQj-gzGzoHsz',
      appKey     : 'Ie0iqVSpNsVRau5BDLh7jbvn',
      placeholder: "说点什么。。。",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<div id="QPlayer">
			<div id="pContent">
				<div id="player">
					<span class="cover"></span>
					<div class="ctrl">
						<div class="musicTag marquee">
							<strong>Title</strong>
							 <span> - </span>
							<span class="artist">Artist</span>
						</div>
						<div class="progress">
							<div class="timer left">0:00</div>
							<div class="contr">
								<div class="rewind icon"></div>
								<div class="playback icon"></div>
								<div class="fastforward icon"></div>
							</div>
							<div class="right">
								<div class="liebiao icon"></div>
							</div>
						</div>
					</div>
				</div>
				<div class="ssBtn">
					
					<div class="adf">
						
					</div>
				</div>
			</div>
			<ol id="playlist"></ol>
		</div>
		<script>
		  var playlist = [];

  playlist.push({title:'&#x8FD8;&#x6709;&#x6211;',artist:'&#x5411;&#x6587;&#x6D9B;',mp3:'https://music.163.com/song/media/outer/url?id=1403774242.mp3',cover:'http://p1.music.126.net/IcXlFwqDL127QI3oHvyeRg==/109951164489393810.jpg'})
		  
		  playlist.push({title:'&#x5982;&#x613F;',artist:'&#x8471;&#x9999;&#x79D1;&#x5B66;&#x5BB6;',mp3:'https://music.163.com/song/media/outer/url?id=1922701695.mp3',cover:'http://p1.music.126.net/3quyghcGASgwNjjXZfqqhg==/109951167081686500.jpg'})
		  
		  playlist.push({title:'&#x5982;&#x679C;&#x8FD9;&#x5C31;&#x662F;&#x7231;&#x60C5;',artist:'&#x5F20;&#x9753;&#x9896;',mp3:'https://music.163.com/song/media/outer/url?id=1444086303.mp3',cover:'https://p1.music.126.net/GK7EB01AIEE9-qHkBi-3vg==/89060441862562.jpg'})
		  
		  playlist.push({title:'&#x5343;&#x79A7;',artist:'&#x5F90;&#x79C9;&#x9F99;',mp3:'https://music.163.com/song/media/outer/url?id=522510615.mp3',cover:'https://y.gtimg.cn/music/photo_new/T002R300x300M000004UOSJ5117bcd.jpg'})
		  
		  playlist.push({title:'&#x5E74;&#x5EA6;&#x4E4B;&#x6B4C;',artist:'&#x8C22;&#x5B89;&#x742A;',mp3:'https://music.163.com/song/media/outer/url?id=308169.mp3',cover:'http://p1.music.126.net/SkSda5laDTH73h_a9ZYEig==/109951164146248533.jpg'})
		  
		  playlist.push({title:'&#x8FB9;&#x8D70;&#x8FB9;&#x5531;',artist:'&#x674E;&#x8363;&#x6D69;',mp3:'https://music.163.com/song/media/outer/url?id=31134197.mp3',cover:'https://p1.music.126.net/4Pu7M0q88fVVoo1ZFS_nmw==/3408486047237011.jpg'})
		
		  var isRotate = true;
		  var autoplay = false;
		</script>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":200,"height":300},"mobile":{"show":false},"react":{"opacityDefault":1,"opacityOnHover":1},"log":false,"tagMode":false});</script></body>
</html>
		<script src="/js/jquery-1.11.0.min.js"></script>
		<script src="/js/player.js"></script>
<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>