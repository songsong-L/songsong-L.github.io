<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>知识图谱</title>
    <url>/2021/05/06/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    <content><![CDATA[<h2 id="如何从零开始搭建知识图谱？"><a href="#如何从零开始搭建知识图谱？" class="headerlink" title="如何从零开始搭建知识图谱？"></a>如何从零开始搭建知识图谱？</h2><p>发布时间: 18-07-0223:43</p>
<p>\1. 概论</p>
<p>随着移动互联网的发展，万物互联成为了可能，这种互联所产生的数据也在爆发式地增长，而且这些数据恰好可以作为分析关系的有效原料。如果说以往的智能分析专注在每一个个体上，在移动互联网时代则除了个体，这种个体之间的关系也必然成为我们需要深入分析的很重要一部分。 在一项任务中，只要有关系分析的需求，知识图谱就“有可能”派的上用场。<br><img src="http://t12.baidu.com/it/u=3463516904,1082940717&fm=173&app=25&f=JPEG?w=640&h=278&s=88B4ED12D7F16D921269A4CB0200C0B3" alt="img"></p>
<p>\2. 知识抽取</p>
<p>知识图谱的构建是后续应用的基础，而且构建的前提是需要把数据从不同的数据源中抽取出来。对于垂直领域的知识图谱来说，<strong>它们的数据源主要来自两种渠道：一种是业务本身的数据，这部分数据通常包含在公司内的数据库表并以结构化的方式存储；另一种是网络上公开、抓取的数据，这些数据通常是以网页的形式存在所以是非结构化的数据。</strong></p>
<p>前者一般只需要简单预处理即可以作为后续 AI 系统的输入，但后者一般需要借助于自然语言处理等技术来提取出结构化信息。比如在上面的搜索例子里，Bill Gates 和 Malinda Gate 的关系就可以从非结构化数据中提炼出来，比如维基百科等数据源。</p>
<p><img src="http://t10.baidu.com/it/u=3524701362,4051137342&fm=173&app=25&f=JPEG?w=640&h=331&s=05B0EC32552245090070A459020040F3" alt="img"></p>
<p>信息抽取的难点在于处理非结构化数据。在下面的图中，我们给出了一个实例。左边是一段非结构化的英文文本，右边是从这些文本中抽取出来的实体和关系。在构建类似的图谱过程当中，主要涉及以下几个方面的自然语言处理技术：</p>
<p>a. 实体命名识别（Name Entity Recognition）b. 关系抽取（Relation Extraction）c. 实体统一（Entity Resolution）d. 指代消解（Coreference Resolution）</p>
<p>下面针对每一项技术解决的问题做简单的描述，以至于这些是具体怎么实现的，不在这里一一展开。</p>
<p><img src="http://t10.baidu.com/it/u=3848596317,2706783691&fm=173&app=25&f=JPEG?w=640&h=275&s=CC90E81A9FE144824AE598C2020070B3" alt="img"></p>
<p>首先是实体命名识别，就是从文本里提取出实体并对每个实体做分类 / 打标签：比如从上述文本里，我们可以提取出实体 -“NYC”，并标记实体类型为 “Location”；我们也可以从中提取出“Virgil’s BBQ”，并标记实体类型为“Restarant”。这种过程称之为实体命名识别，这是一项相对比较成熟的技术，有一些现成的工具可以用来做这件事情。其次，我们可以通过关系抽取技术，把实体间的关系从文本中提取出来，比如实体“hotel”和“Hilton property”之间的关系为“in”；“hotel”和“Time Square”的关系为“near”等等。</p>
<p><img src="http://t11.baidu.com/it/u=2261386009,2555456406&fm=173&app=25&f=JPEG?w=640&h=262&s=0C40FC128BF074821CE900DA0200D0B2" alt="img"></p>
<p>另外，在实体命名识别和关系抽取过程中，有两个比较棘手的问题：一个是实体统一，也就是说有些实体写法上不一样，但其实是指向同一个实体。比如“NYC”和“New York”表面上是不同的字符串，但其实指的都是纽约这个城市，需要合并。实体统一不仅可以减少实体的种类，也可以降低图谱的稀疏性（Sparsity）；另一个问题是指代消解，也是文本中出现的“it”, “he”, “she”这些词到底指向哪个实体，比如在本文里两个被标记出来的“it”都指向“hotel”这个实体。</p>
<p><img src="http://t12.baidu.com/it/u=2616873605,1175169232&fm=173&app=25&f=JPEG?w=640&h=233&s=CC90E81ADFD548C20070F0CA010010B2" alt="img"></p>
<p>实体统一和指代消解问题相对于前两个问题更具有挑战性。</p>
<p>\3. 知识图谱的存储</p>
<p><strong>知识图谱主要有两种存储方式：一种是基于 RDF 的存储；另一种是基于图数据库的存储。</strong>它们之间的区别如下图所示。RDF 一个重要的设计原则是数据的易发布以及共享，图数据库则把重点放在了高效的图查询和搜索上。其次，RDF 以三元组的方式来存储数据而且不包含属性信息，但图数据库一般以属性图为基本的表示形式，所以实体和关系可以包含属性，这就意味着更容易表达现实的业务场景。</p>
<p><img src="http://t12.baidu.com/it/u=712907711,4221552733&fm=173&app=25&f=JPEG?w=639&h=242&s=0AAE7C2287846D435ADD35CA0000C0B1" alt="img"></p>
<p>根据最新的统计（2018 年上半年），图数据库仍然是增长最快的存储系统。相反，关系型数据库的增长基本保持在一个稳定的水平。同时，我们也列出了常用的图数据库系统以及他们最新使用情况的排名。 其中 Neo4j 系统目前仍是使用率最高的图数据库，它拥有活跃的社区，而且系统本身的查询效率高，但唯一的不足就是不支持准分布式。相反，OrientDB 和 JanusGraph（原 Titan）支持分布式，但这些系统相对较新，社区不如 Neo4j 活跃，这也就意味着使用过程当中不可避免地会遇到一些刺手的问题。如果选择使用 RDF 的存储系统，Jena 或许一个比较不错的选择。</p>
<p><img src="http://t11.baidu.com/it/u=626952808,2562026971&fm=173&app=25&f=JPEG?w=639&h=227&s=0470E432BDB04C035450E4D8000060B3" alt="img"></p>
<p>\4. 金融知识图谱的搭建</p>
<p>接下来我们看一个实际的具体案例，讲解怎么一步步搭建可落地的金融风控领域的知识图谱系统。 首先需要说明的一点是，有可能不少人认为搭建一个知识图谱系统的重点在于算法和开发。但事实并不是想象中的那样，<strong>其实最重要的核心在于对业务的理解以及对知识图谱本身的设计</strong>，这就类似于对于一个业务系统，数据库表的设计尤其关键，而且这种设计绝对离不开对业务的深入理解以及对未来业务场景变化的预估。 当然，在这里我们先不讨论数据的重要性。</p>
<p><img src="http://t11.baidu.com/it/u=1461973663,1466794736&fm=173&app=25&f=JPEG?w=639&h=184&s=6AAE3C624B6249321EFDB4CA000080B1" alt="img"></p>
<p>一个完整的知识图谱的构建包含以下几个步骤：<strong>1. 定义具体的业务问题 2. 数据的收集 &amp; 预处理 3. 知识图谱的设计 4. 把数据存入知识图谱 5. 上层应用的开发，以及系统的评估。</strong>下面我们就按照这个流程来讲一下每个步骤所需要做的事情以及需要思考的问题。</p>
<p>4.1 定义具体的业务问题</p>
<p>在 P2P 网贷环境下，最核心的问题是风控，也就是怎么去评估一个借款人的风险。在线上的环境下，欺诈风险尤其为严重，而且很多这种风险隐藏在复杂的关系网络之中，而且知识图谱正好是为这类问题所设计的，所以我们“有可能”期待它能在欺诈，这个问题上带来一些价值。</p>
<p><img src="http://t10.baidu.com/it/u=4101688044,1856892679&fm=173&app=25&f=JPEG?w=640&h=289&s=C006DC1A85C46D43095554CA020050B2" alt="img"></p>
<p>在进入下一个话题的讨论之前，<strong>要明确的一点是，对于自身的业务问题到底需不需要知识图谱系统的支持。</strong>因为在很多的实际场景，即使对关系的分析有一定的需求，实际上也可以利用传统数据库来完成分析的。所以为了避免使用知识图谱而选择知识图谱，以及更好的技术选型，以下给出了几点总结，供参考。</p>
<p><img src="http://t12.baidu.com/it/u=1965742121,2969045495&fm=173&app=25&f=JPEG?w=639&h=219&s=0AAA7E228B8049431A7DB4CA0000E0B1" alt="img"></p>
<p>4.2 数据收集 &amp; 预处理</p>
<p>下一步就是要确定数据源以及做必要的数据预处理。针对于数据源，我们需要考虑以下几点：1. 我们已经有哪些数据？ 2. 虽然现在没有，但有可能拿到哪些数据？ 3. 其中哪部分数据可以用来降低风险？ 4. 哪部分数据可以用来构建知识图谱？在这里需要说明的一点是，并不是所有跟反欺诈相关的数据都必须要进入知识图谱，对于这部分的一些决策原则在接下来的部分会有比较详细的介绍。</p>
<p>对于反欺诈，有几个数据源是我们很容易想得到的，包括用户的基本信息、行为数据、运营商数据、网络上的公开信息等等。假设我们已经有了一个数据源的列表清单，则下一步就要看哪些数据需要进一步的处理，比如对于非结构化数据我们或多或少都需要用到跟自然语言处理相关的技术。 用户填写的基本信息基本上会存储在业务表里，除了个别字段需要进一步处理，很多字段则直接可以用于建模或者添加到知识图谱系统里。对于行为数据来说，我们则需要通过一些简单的处理，并从中提取有效的信息比如“用户在某个页面停留时长”等等。 对于网络上公开的网页数据，则需要一些信息抽取相关的技术。</p>
<p>举个例子，对于用户的基本信息，我们很可能需要如下的操作。一方面，用户信息比如姓名、年龄、学历等字段可以直接从结构化数据库中提取并使用。但另一方面，对于填写的公司名来说，我们有可能需要做进一步的处理。比如部分用户填写“北京贪心科技有限公司”，另外一部分用户填写“北京望京贪心科技有限公司”，其实指向的都是同一家公司。所以，这时候我们需要做公司名的对齐，用到的技术细节可以参考前面讲到的实体对齐技术。</p>
<p><img src="http://t10.baidu.com/it/u=2903476509,3457739770&fm=173&app=25&f=JPEG?w=639&h=272&s=8DB0EC128F904CC054516C56020080F2" alt="img"></p>
<p>4.3 知识图谱的设计</p>
<p>图谱的设计是一门艺术，不仅要对业务有很深的理解、也需要对未来业务可能的变化有一定预估，从而设计出最贴近现状并且性能高效的系统。在知识图谱设计的问题上，我们肯定会面临以下几个常见的问题：<strong>1. 需要哪些实体、关系和属性？ 2. 哪些属性可以做为实体，哪些实体可以作为属性？ 3. 哪些信息不需要放在知识图谱中？</strong></p>
<p>基于这些常见的问题，我们从以往的设计经验中抽象出了一系列的设计原则。这些设计原则就类似于传统数据库设计中的范式，来引导相关人员设计出更合理的知识图谱系统，同时保证系统的高效性。</p>
<p><img src="http://t12.baidu.com/it/u=33644744,766651579&fm=173&app=25&f=JPEG?w=640&h=250&s=4AAC3C628FD04CC25C7505DE000080B1" alt="img"></p>
<p>接下来，我们举几个简单的例子来说明其中的一些原则。 首先是，业务原则（Business Principle），它的含义是 “<strong>一切要从业务逻辑出发，并且通过观察知识图谱的设计也很容易推测其背后业务的逻辑，而且设计时也要想好未来业务可能的变化</strong>”。</p>
<p>举个例子，可以观察一下下面这个图谱，并试问自己背后的业务逻辑是什么。通过一番观察，其实也很难看出到底业务流程是什么样的。做个简单的解释，这里的实体 -“申请”意思就是 application，如果对这个领域有所了解，其实就是进件实体。在下面的图中，申请和电话实体之间的“has_phone”，“parent phone”是什么意思呢？</p>
<p><img src="http://t11.baidu.com/it/u=1843334557,961909614&fm=173&app=25&f=JPEG?w=640&h=272&s=25B2EC32CB604C0348C070D80000D0B2" alt="img"></p>
<p>接下来再看一下下面的图，跟之前的区别在于我们把申请人从原有的属性中抽取出来并设置成了一个单独的实体。在这种情况下，整个业务逻辑就变得很清晰，我们很容易看出张三申请了两个贷款，而且张三拥有两个手机号，在申请其中一个贷款的时候他填写了父母的电话号。总而言之，一个好的设计很容易让人看到业务本身的逻辑。</p>
<p><img src="http://t12.baidu.com/it/u=2571953264,527713124&fm=173&app=25&f=JPEG?w=639&h=328&s=4D803C72137061824840F8C8020030F3" alt="img"></p>
<p>接下来再看一个原则叫做效率原则（Efficiency Principle）。<strong>效率原则让知识图谱尽量轻量化、并决定哪些数据放在知识图谱，哪些数据不需要放在知识图谱</strong>。在这里举一个简单的类比，在经典的计算机存储系统中，我们经常会谈论到内存和硬盘，内存作为高效的访问载体，作为所有程序运行的关键。这种存储上的层次结构设计源于数据的局部性 -“locality”，也就是说经常被访问到的数据集中在某一个区块上，所以这部分数据可以放到内存中来提升访问的效率。 类似的逻辑也可以应用到知识图谱的设计上：我们把常用的信息存放在知识图谱中，把那些访问频率不高，对关系分析无关紧要的信息放在传统的关系型数据库当中。 <strong>效率原则的核心在于把知识图谱设计成小而轻的存储载体。</strong></p>
<p><img src="http://t12.baidu.com/it/u=226327970,1562893738&fm=173&app=25&f=JPEG?w=640&h=318&s=CDA0AC520530F42949E80D52020040F2" alt="img"></p>
<p>比如在下面的知识图谱中，我们完全可以把一些信息比如“年龄”，“家乡”放到传统的关系型数据库当中，因为这些数据对于：a. 分析关系来说没有太多作用 b. 访问频率低，放在知识图谱上反而影响效率</p>
<p><img src="http://t11.baidu.com/it/u=302720116,1354414349&fm=173&app=25&f=JPEG?w=640&h=322&s=69203C720F70448A506130D2000080B1" alt="img"></p>
<p>另外，从分析原则（Analytics Principle）的角度，我们不需要把跟关系分析无关的实体放在图谱当中；从冗余原则（Redundancy Principle）的角度，有些重复性信息、高频信息可以放到传统数据库当中。</p>
<p>4.4 把数据存入知识图谱</p>
<p>存储上我们要面临存储系统的选择，但由于我们设计的知识图谱带有属性，图数据库可以作为首选。但至于选择哪个图数据库也要看业务量以及对效率的要求。如果数据量特别庞大，则 Neo4j 很可能满足不了业务的需求，这时候不得不去选择支持准分布式的系统比如 OrientDB, JanusGraph 等，或者通过效率、冗余原则把信息存放在传统数据库中，从而减少知识图谱所承载的信息量。 通常来讲，对于 10 亿节点以下规模的图谱来说 Neo4j 已经足够了。</p>
<p>4.5 上层应用的开发</p>
<p>等我们构建好知识图谱之后，接下来就要使用它来解决具体的问题。对于风控知识图谱来说，首要任务就是挖掘关系网络中隐藏的欺诈风险。<strong>从算法的角度来讲，有两种不同的场景：一种是基于规则的；另一种是基于概率的。</strong>鉴于目前 AI 技术的现状，基于规则的方法论还是在垂直领域的应用中占据主导地位，但随着数据量的增加以及方法论的提升，基于概率的模型也将会逐步带来更大的价值。</p>
<p>4.5.1 基于规则的方法论</p>
<p>首先，我们来看几个基于规则的应用，分别是不一致性验证、基于规则的特征提取、基于模式的判断。</p>
<p><strong>不一致性验证</strong></p>
<p>为了判断关系网络中存在的风险，一种简单的方法就是做不一致性验证，也就是通过一些规则去找出潜在的矛盾点。这些规则是以人为的方式提前定义好的，所以在设计规则这个事情上需要一些业务的知识。比如在下面的这个图中，李明和李飞两个人都注明了同样的公司电话，但实际上从数据库中判断这俩人其实在不同的公司上班，这就是一个矛盾点。 类似的规则其实可以有很多，不在这里一一列出。</p>
<p><img src="http://t11.baidu.com/it/u=2086250224,504274614&fm=173&app=25&f=JPEG?w=640&h=355&s=A012EC325F0254C2566F58D80200D0B2" alt="img"></p>
<p><strong>基于规则提取特征</strong></p>
<p>我们也可以基于规则从知识图谱中提取一些特征，而且这些特征一般基于深度的搜索比如 2 度，3 度甚至更高维度。比如我们可以问一个这样的问题：“申请人二度关系里有多少个实体触碰了黑名单？”，从图中我们很容观察到二度关系中有两个实体触碰了黑名单（黑名单由红色来标记）。等这些特征被提取之后，一般可以作为风险模型的输入。在此还是想说明一点，如果特征并不涉及深度的关系，其实传统的关系型数据库则足以满足需求。</p>
<p><img src="http://t11.baidu.com/it/u=1060578160,1139020907&fm=173&app=25&f=JPEG?w=639&h=364&s=2032EC325F0264C0446978DA020050B2" alt="img"></p>
<p><strong>基于模式的判断</strong></p>
<p>这种方法比较适用于找出团体欺诈，它的核心在于通过一些模式来找到有可能存在风险的团体或者子图（sub-graph），然后对这部分子图做进一步的分析。 这种模式有很多种，在这里举几个简单的例子。 比如在下图中，三个实体共享了很多其他的信息，我们可以看做是一个团体，并对其做进一步的分析。</p>
<p><img src="http://t12.baidu.com/it/u=3828566894,715445935&fm=173&app=25&f=JPEG?w=640&h=325&s=05F2EC329B8340C208C13D52020080F2" alt="img"></p>
<p>再比如，我们也可以从知识图谱中找出强连通图，并把它标记出来，然后做进一步风险分析。强连通图意味着每一个节点都可以通过某种路径达到其他的点，也就说明这些节点之间有很强的关系。</p>
<p><img src="http://t10.baidu.com/it/u=480692214,290401441&fm=173&app=25&f=JPEG?w=640&h=327&s=61728472DF324580425830D90200C0B2" alt="img"></p>
<p>4.5.2 基于概率的方法</p>
<p>除了基于规则的方法，也可以使用概率统计的方法。 比如社区挖掘、标签传播、聚类等技术都属于这个范畴。 对于这类技术，在本文里不做详细的讲解，感兴趣的读者可以参考相关文献。</p>
<p>社区挖掘算法的目的在于从图中找出一些社区。对于社区，我们可以有多种定义，但直观上可以理解为社区内节点之间关系的密度要明显大于社区之间的关系密度。下面的图表示社区发现之后的结果，图中总共标记了三个不同的社区。一旦我们得到这些社区之后，就可以做进一步的风险分析。</p>
<p>由于社区挖掘是基于概率的方法论，好处在于不需要人为地去定义规则，特别是对于一个庞大的关系网络来说，定义规则这事情本身是一件很复杂的事情。</p>
<p><img src="http://t11.baidu.com/it/u=3112136647,1918214170&fm=173&app=25&f=JPEG?w=640&h=392&s=A036EC328F026EC05CFCCDDA0200D0B3" alt="img"></p>
<p>标签传播算法的核心思想在于节点之间信息的传递。这就类似于，跟优秀的人在一起自己也会逐渐地变优秀是一个道理。因为通过这种关系会不断地吸取高质量的信息，最后使得自己也会不知不觉中变得更加优秀。具体细节不在这里做更多解释。</p>
<p>相比规则的方法论，基于概率的方法的缺点在于：需要足够多的数据。如果数据量很少，而且整个图谱比较稀疏（Sparse），基于规则的方法可以成为我们的首选。尤其是对于金融领域来说，数据标签会比较少，这也是为什么基于规则的方法论还是更普遍地应用在金融领域中的主要原因。</p>
<p>4.5.3 基于动态网络的分析</p>
<p>以上所有的分析都是基于静态的关系图谱。所谓的静态关系图谱，意味着我们不考虑图谱结构本身随时间的变化，只是聚焦在当前知识图谱结构上。然而，我们也知道图谱的结构是随时间变化的，而且这些变化本身也可以跟风险有所关联。</p>
<p>在下面的图中，我们给出了一个知识图谱 T 时刻和 T+1 时刻的结构，我们很容易看出在这两个时刻中间，图谱结构（或者部分结构）发生了很明显的变化，这其实暗示着潜在的风险。那怎么去判断这些结构上的变化呢？ 感兴趣的读者可以查阅跟“dynamic network mining”相关的文献。</p>
<p><img src="http://t12.baidu.com/it/u=621530735,2369132207&fm=173&app=25&f=JPEG?w=639&h=302&s=6172A47297F3658044C084CE000010B2" alt="img"></p>
<p>\5. 知识图谱在其他行业中的应用</p>
<p>除了金融领域，知识图谱的应用可以涉及到很多其他的行业，包括医疗、教育、证券投资、推荐等等。其实，只要有关系存在，则有知识图谱可发挥价值的地方。 在这里简单举几个垂直行业中的应用。</p>
<p>比如对于教育行业，我们经常谈论个性化教育、因材施教的理念。其核心在于理解学生当前的知识体系，而且这种知识体系依赖于我们所获取到的数据比如交互数据、评测数据、互动数据等等。为了分析学习路径以及知识结构，我们则需要针对于一个领域的概念知识图谱，简单来讲就是概念拓扑结构。在下面的图中，我们给出了一个非常简单的概念图谱：比如为了学习逻辑回归则需要先理解线性回归；为了学习 CNN，得对神经网络有所理解等等。所有对学生的评测、互动分析都离不开概念图谱这个底层的数据。</p>
<p><img src="http://t11.baidu.com/it/u=2915145958,428470587&fm=173&app=25&f=JPEG?w=639&h=229&s=617284721134F6217FFE45D90200D0B2" alt="img"></p>
<p>在证券领域，我们经常会关心比如“一个事件发生了，对哪些公司产生什么样的影响？” 比如有一个负面消息是关于公司 1 的高管，而且我们知道公司 1 和公司 2 有种很密切的合作关系，公司 2 有个主营产品是由公司 3 提供的原料基础上做出来的。</p>
<p><img src="http://t12.baidu.com/it/u=819872987,394960907&fm=173&app=25&f=JPEG?w=640&h=278&s=1832EC12093153825FF4C54B0300F0B1" alt="img"></p>
<p>其实有了这样的一个知识图谱，我们很容易回答哪些公司有可能会被这次的负面事件所影响。当然，仅仅是“有可能”，具体会不会有强相关性必须由数据来验证。所以在这里，知识图谱的好处就是把我们所需要关注的范围很快给我们圈定。接下来的问题会更复杂一些，比如既然我们知道公司 3 有可能被这次事件所影响，那具体影响程度有多大？ 对于这个问题，光靠知识图谱是很难回答的，必须要有一个影响模型、以及需要一些历史数据才能在知识图谱中做进一步推理以及计算。</p>
<p>\6. 实践上的几点建议</p>
<p>首先，知识图谱是一个比较新的工具，它的主要作用还是在于分析关系，尤其是深度的关系。所以在业务上，首先要确保它的必要性，其实很多问题可以用非知识图谱的方式来解决。</p>
<p>知识图谱领域一个最重要的话题是知识的推理。 而且知识的推理是走向强人工智能的必经之路。但很遗憾的，目前很多语义网络的角度讨论的推理技术（比如基于深度学习，概率统计）很难在实际的垂直应用中落地。其实目前最有效的方式还是基于一些规则的方法论，除非我们有非常庞大的数据集。</p>
<p>最后，还是要强调一点，<strong>知识图谱工程本身还是业务为重心，以数据为中心。不要低估业务和数据的重要性。</strong></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>强化学习</title>
    <url>/2020/11/21/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>强化学习的基本要素，我们对其分别进行定义：</p>
<ul>
<li>智能体（Agent）：可以采取行动的智能个体；例如，可以完成投递的无人机，或者在视频游戏中朝目标行动的超级马里奥。强化学习算法就是一个智能体。<a id="more"></a></li>
<li>行动（Action）：在电子游戏中，行动可能包括向右奔跑或者向左奔跑，向高出处跳或者向低处跳，下蹲或者站住不动。在股市中，行动可能包括买入，卖出或者持有任何有价证券或者它们的变体。在处理空中飞行的无人机时，行动可能包括三维空间中的很多速度和加速度。</li>
<li>环境（Environment）：指的就是智能体行走于其中的世界。这个环境将智能体当前的状态和行动作为输入，输出是智能体的奖励和下一步的状态。</li>
<li>状态（State，S）：一个状态就是智能体所处的具体即时状态；也就是说，一个具体的地方和时刻，这是一个具体的即时配置。</li>
<li>奖励（Reward，R）：奖励是我们衡量某个智能体的行动成败的反馈。例如，在视频游戏中，当马里奥碰到金币的时候，它就会赢得分数。面对任何既定的状态，智能体要以行动的形式向环境输出，然后环境会返回这个智能体的一个新状态和奖励。它们可以有效地评估该智能体的行动。</li>
</ul>
<p>所以，环境就是能够将当前状态下采取的动作转换成下一个状态和奖励的函数；环境是一个我们只能看到输入输出的黑盒子。智能体是将新的状态和奖励转换成下一个行动的函数。我们可以知悉智能体的函数，但是我们无法知悉环境的函数。强化学习相当于智能体在尝试逼近这个环境的函数，这样我们就能够向黑盒子环境发送最大化奖励的行动了。</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Fuzzing</title>
    <url>/2025/10/21/Fuzzing/</url>
    <content><![CDATA[<h1 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h1><h2 id="1、编译Peach"><a href="#1、编译Peach" class="headerlink" title="1、编译Peach"></a>1、编译Peach</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./waf configure &amp;&amp; \</span><br><span class="line">./waf build &amp;&amp; \</span><br><span class="line">./waf install</span><br></pre></td></tr></table></figure>

<h2 id="2、插桩"><a href="#2、插桩" class="headerlink" title="2、插桩"></a>2、插桩</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /dev/shm</span><br><span class="line">dd if=/dev/zero bs=10M count=1 of=song</span><br><span class="line">export SHM_ENV_VAR=/dev/shm/song</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dd if=/dev/zero bs=10M count=1 of=lucky</span><br><span class="line">export LUCKY_GLOBAL_MMAP_FILE=/dev/shm/lucky</span><br><span class="line"></span><br><span class="line">strings ./fftp | grep asan</span><br></pre></td></tr></table></figure>

<h2 id="3、mono"><a href="#3、mono" class="headerlink" title="3、mono"></a>3、mono</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=/opt/mono-4.8/bin:$PATH</span><br></pre></td></tr></table></figure>

<h2 id="4、收集覆盖率"><a href="#4、收集覆盖率" class="headerlink" title="4、收集覆盖率"></a>4、收集覆盖率</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang control.c -fPIC -shared -o libcoverage.so</span><br><span class="line">cp libcoverage.so /usr/local/lib/ &amp;&amp; ldconfig</span><br></pre></td></tr></table></figure>

<h2 id="5、结束进程"><a href="#5、结束进程" class="headerlink" title="5、结束进程"></a>5、结束进程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux | grep hello</span><br><span class="line">kill pid</span><br><span class="line">kill -9 pid</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>git提交本地项目</title>
    <url>/2025/10/21/git%E6%8F%90%E4%BA%A4%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="1、本地项目提交到github"><a href="#1、本地项目提交到github" class="headerlink" title="1、本地项目提交到github"></a>1、本地项目提交到github</h1><h2 id="1-1、创建一个仓库，例如Test"><a href="#1-1、创建一个仓库，例如Test" class="headerlink" title="1.1、创建一个仓库，例如Test"></a>1.1、创建一个仓库，例如Test</h2><h2 id="1-2、克隆Test到本地"><a href="#1-2、克隆Test到本地" class="headerlink" title="1.2、克隆Test到本地"></a>1.2、克隆Test到本地</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone test.git</span><br></pre></td></tr></table></figure>

<h2 id="1-3、将本地项目的所有文件复制到Test里面"><a href="#1-3、将本地项目的所有文件复制到Test里面" class="headerlink" title="1.3、将本地项目的所有文件复制到Test里面"></a>1.3、将本地项目的所有文件复制到Test里面</h2><h2 id="1-4、执行git-add-添加需要上传的文件"><a href="#1-4、执行git-add-添加需要上传的文件" class="headerlink" title="1.4、执行git add 添加需要上传的文件"></a>1.4、执行git add 添加需要上传的文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .        #相当于选中所有项目文件</span><br><span class="line">git status       #可查看选中</span><br></pre></td></tr></table></figure>

<h2 id="1-5、提交到本地git管理"><a href="#1-5、提交到本地git管理" class="headerlink" title="1.5、提交到本地git管理"></a>1.5、提交到本地git管理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit  -m  &quot;first commit&quot;</span><br></pre></td></tr></table></figure>

<h2 id="1-6、推送到github"><a href="#1-6、推送到github" class="headerlink" title="1.6、推送到github"></a>1.6、推送到github</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u origin master/main</span><br></pre></td></tr></table></figure>



<h1 id="2、删除提交记录"><a href="#2、删除提交记录" class="headerlink" title="2、删除提交记录"></a>2、删除提交记录</h1><h2 id="2-1、查看提交历史"><a href="#2-1、查看提交历史" class="headerlink" title="2.1、查看提交历史"></a>2.1、查看提交历史</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure>

<h2 id="2-2、重置到指定提交"><a href="#2-2、重置到指定提交" class="headerlink" title="2.2、重置到指定提交"></a>2.2、重置到指定提交</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD~2    #保留暂存区</span><br><span class="line">git reset HEAD~2           #不保留删除暂存区</span><br><span class="line">git reset --hard HEAD~2    #工作区的修改都被恢复</span><br></pre></td></tr></table></figure>

<h2 id="2-3、强制推送到远程仓库"><a href="#2-3、强制推送到远程仓库" class="headerlink" title="2.3、强制推送到远程仓库"></a>2.3、强制推送到远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push --force</span><br></pre></td></tr></table></figure>

<h1 id="3、更新提交信息"><a href="#3、更新提交信息" class="headerlink" title="3、更新提交信息"></a>3、更新提交信息</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit --amend -m &quot;新的提交信息&quot;</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>动态覆盖率若干协议实战</title>
    <url>/2025/05/27/%E5%8A%A8%E6%80%81%E8%A6%86%E7%9B%96%E7%8E%87%E8%8B%A5%E5%B9%B2%E5%8D%8F%E8%AE%AE%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="插桩"><a href="#插桩" class="headerlink" title="插桩"></a>插桩</h2><p>都使用pcguard插桩：Create shared memory</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /dev/shm</span><br><span class="line">dd if=/dev/zero bs=10M count=1 of=song</span><br><span class="line">export SHM_ENV_VAR=/dev/shm/song</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dd if=/dev/zero bs=10M count=1 of=lucky</span><br><span class="line">export LUCKY_GLOBAL_MMAP_FILE=/dev/shm/lucky</span><br></pre></td></tr></table></figure>

<p>可以验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nm fftp | grep pc_guard</span><br><span class="line">strings ./fftp | grep asan</span><br></pre></td></tr></table></figure>

<h2 id="LightFTP"><a href="#LightFTP" class="headerlink" title="LightFTP"></a>LightFTP</h2><p>备忘：在4fea4969cec4   peach-ubuntu18这个容器</p>
<p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AFL_USE_ASAN=1 make CC=/afl/compiler/afl-clang-fast      CXX=/afl/compiler/afl-clang-fast++      CFLAGS=&quot;-fsanitize=address -fsanitize-coverage=trace-pc-guard&quot;      CXXFLAGS=&quot;-fsanitize=address -fsanitize-coverage=trace-pc-guard&quot;</span><br><span class="line"></span><br><span class="line">/pcguard_cov/afl-clang-fast</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./fftp ../../Bin/fftp.conf</span><br><span class="line">./peach ftp-llm.xml -maxNoCoverage 10 -NthIteration 100</span><br></pre></td></tr></table></figure>

<h2 id="IEC104"><a href="#IEC104" class="headerlink" title="IEC104"></a>IEC104</h2><p>备忘：在52a9f3a51351   peach-clang-ubuntu14这个容器</p>
<p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AFL_USE_ASAN=1 make CC=/compiler/afl-clang-fast      CXX=/compiler/afl-clang-fast++</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./iec104_monitor -d 127.0.0.1 -m server -n 2 -p 10000</span><br><span class="line">./peach iec104.xml -maxNoCoverage 10 -NthIteration 100</span><br></pre></td></tr></table></figure>

<h2 id="qpid"><a href="#qpid" class="headerlink" title="qpid"></a>qpid</h2><p>备忘：在这个容器32231fb0d7c1   amqp-qpid</p>
<p>编译</p>
<p>cmake需要更高版本，ubuntu18默认的版本不行</p>
<p><a href="https://github.com/Kitware/CMake/releases/tag/v3.16.3">https://github.com/Kitware/CMake/releases/tag/v3.16.3</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/cmake-3.16.3-Linux-x86_64/bin/cmake -DCMAKE_C_COMPILER=/compiler/afl-clang-fast -DCMAKE_CXX_COMPILER=/compiler/afl-clang-fast++ -DBUILD_PROBES=no ..</span><br><span class="line">AFL_USE_ASAN=1 make -j$(nproc)</span><br></pre></td></tr></table></figure>

<p>pcguard</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/cmake-3.16.3-Linux-x86_64/bin/cmake -DCMAKE_C_COMPILER=/compiler/afl-clang-fast -DCMAKE_CXX_COMPILER=/compiler/afl-clang-fast++ -DCMAKE_C_FLAGS=&quot;-fsanitize-coverage=trace-pc-guard&quot; -DCMAKE_CXX_FLAGS=&quot;-fsanitize-coverage=trace-pc-guard&quot; -DBUILD_PROBES=no ..</span><br><span class="line">AFL_USE_ASAN=1 make -j$(nproc)</span><br></pre></td></tr></table></figure>

<p>aa</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/cmake-3.16.3-Linux-x86_64/bin/cmake -DCMAKE_C_COMPILER=/pcguard-cov/afl-clang-fast -DCMAKE_CXX_COMPILER=/pcguard-cov/afl-clang-fast++ -DCMAKE_C_FLAGS=&quot;-fsanitize-coverage=trace-pc-guard&quot; -DCMAKE_CXX_FLAGS=&quot;-fsanitize-coverage=trace-pc-guard&quot; -DBUILD_PROBES=no ..</span><br><span class="line">AFL_USE_ASAN=1 make -j$(nproc)</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;opt&#x2F;qpid-cpp&#x2F;build&#x2F;src</span><br><span class="line">.&#x2F;qpidd</span><br><span class="line">.&#x2F;peach amqp-config.xml -maxNoCoverage 10 -NthIteration 100</span><br></pre></td></tr></table></figure>

<h2 id="mosquitto"><a href="#mosquitto" class="headerlink" title="mosquitto"></a>mosquitto</h2><p>备忘：016f1a20d27a   mqtt-ubuntu18</p>
<p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AFL_USE_ASAN=1 make WITH_DOCS=no CC=/compiler/afl-clang-fast      CXX=/compiler/afl-clang-fast++      CFLAGS=&quot;-fsanitize=address -fsanitize-coverage=trace-pc-guard&quot;      CXXFLAGS=&quot;-fsanitize=address -fsanitize-coverage=trace-pc-guard&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AFL_USE_ASAN=1 make WITH_DOCS=no CC=/pcguard-cov/afl-clang-fast      CXX=/pcguard-cov/afl-clang-fast++      CFLAGS=&quot;-fsanitize=address -fsanitize-coverage=trace-pc-guard&quot;      CXXFLAGS=&quot;-fsanitize=address -fsanitize-coverage=trace-pc-guard&quot;</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/mosquitto/src/mosquitto</span><br><span class="line">LD_LIBRARY_PATH=/mosquitto/lib ./mosquitto_pub -t &#x27;test/topic&#x27; -m &#x27;hello world&#x27; </span><br><span class="line">LD_LIBRARY_PATH=/mosquitto/lib ./mosquitto_sub -t &#x27;test/topic&#x27; -v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./peach mqtt-llm.xml -maxNoCoverage 10 -NthIteration 1000</span><br></pre></td></tr></table></figure>

<h2 id="vsomeip"><a href="#vsomeip" class="headerlink" title="vsomeip"></a>vsomeip</h2><p>备忘：8b23ddce35d6   someip2 </p>
<p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_C_COMPILER=/pcguard-cov/afl-clang-fast -DCMAKE_CXX_COMPILER=/pcguard-cov/afl-clang-fast++ -DCMAKE_C_FLAGS=&quot;-fsanitize-coverage=trace-pc-guard&quot; -DCMAKE_CXX_FLAGS=&quot;-fsanitize-coverage=trace-pc-guard&quot; ..</span><br><span class="line">AFL_USE_ASAN=1 make</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=/opt/vsomeip/build</span><br><span class="line">VSOMEIP_CONFIGURATION=/opt/vsomeip/config/vsomeip.json ./hello_world_service</span><br></pre></td></tr></table></figure>

<h2 id="libcoap"><a href="#libcoap" class="headerlink" title="libcoap"></a>libcoap</h2><p>备忘：d38e656d3e03 coap-ubuntu20</p>
<p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置 CMake</span></span><br><span class="line">cmake -DCMAKE_C_COMPILER=/pcguard-cov/afl-clang-fast -DCMAKE_CXX_COMPILER=/pcguard-cov/afl-clang-fast++ -DCMAKE_C_FLAGS=&quot;-fsanitize=address -fsanitize-coverage=trace-pc-guard -g -O1 -fno-omit-frame-pointer&quot; -DCMAKE_CXX_FLAGS=&quot;-fsanitize=address -fsanitize-coverage=trace-pc-guard -g -O1 -fno-omit-frame-pointer&quot; -DENABLE_DTLS=0 -DENABLE_Q_BLOCK=ON -DENABLE_DOCS=OFF .. </span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./coap-server</span><br><span class="line">./peach coap.xml -maxNoCoverage 10 -NthIteration 1000</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>英语地道表达</title>
    <url>/2025/05/08/%E8%8B%B1%E8%AF%AD%E5%9C%B0%E9%81%93%E8%A1%A8%E8%BE%BE/</url>
    <content><![CDATA[<h1 id="Scenario1"><a href="#Scenario1" class="headerlink" title="Scenario1"></a>Scenario1</h1><p>A: what comes with that? 配菜是什么？</p>
<p>B: there is a side of …        配菜是XXX。</p>
<p>A: instead of the …   不要XXX，</p>
<p>    is there any way that i could substitute the   替换为XXX。</p>
<p>C: i’l have the same.</p>
<p> A: this is shaping up to be …</p>
<h1 id="Scenario2"><a href="#Scenario2" class="headerlink" title="Scenario2"></a>Scenario2</h1><p>A: you’re overthinking this.   想太多</p>
<p>B: there you go, xxx</p>
<p>A: see,this is where everything goes wrong, when we talk.</p>
<h1 id="Scenario3"><a href="#Scenario3" class="headerlink" title="Scenario3"></a>Scenario3</h1><p>A: are you seriously gonna …   你真的要XXX？</p>
<p>B: I can’t face …   我不能面对XXX。</p>
<p>    if I see her, I’m gonna have to confess. 坦白</p>
<p>A:  take a breather, it’s just a dent.  放轻松，只是XXX </p>
<p>    saying nothing is not lying. it’s just letting the truth speak for itself.</p>
<p>B: all we have to do is keep it from sb until … 我们要做的是XXX。</p>
<h1 id="Scenario4"><a href="#Scenario4" class="headerlink" title="Scenario4"></a>Scenario4</h1><p>yesterday was a big homework day.   </p>
<p>I had sth to read    我有一些事要XXX</p>
<p>I got all that done.  全搞定了</p>
<p>I fell chill right now</p>
<h1 id="Scenario5"><a href="#Scenario5" class="headerlink" title="Scenario5"></a>Scenario5</h1><p>It just brought things home.</p>
<p>I know we haven’t kept in touch as much as I would have liked.</p>
<p>I got all that done. 全搞定了</p>
<p>I fell chill right now</p>
]]></content>
  </entry>
  <entry>
    <title>跑qpid协议</title>
    <url>/2025/04/30/%E8%B7%91qpid%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="依赖环境"><a href="#依赖环境" class="headerlink" title="依赖环境"></a>依赖环境</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装基础依赖和常用库</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">    build-essential \</span></span><br><span class="line"><span class="bash">    cmake \</span></span><br><span class="line"><span class="bash">    g++ \</span></span><br><span class="line"><span class="bash">    gcc \</span></span><br><span class="line"><span class="bash">    make \</span></span><br><span class="line"><span class="bash">    libboost-all-dev \</span></span><br><span class="line"><span class="bash">    uuid-dev \</span></span><br><span class="line"><span class="bash">    pkg-config \</span></span><br><span class="line"><span class="bash">    libsasl2-dev \</span></span><br><span class="line"><span class="bash">    libnss3-dev \</span></span><br><span class="line"><span class="bash">    libnspr4-dev \</span></span><br><span class="line"><span class="bash">    doxygen \</span></span><br><span class="line"><span class="bash">    graphviz \</span></span><br><span class="line"><span class="bash">    help2man \</span></span><br><span class="line"><span class="bash">    swig \</span></span><br><span class="line"><span class="bash">    libxerces-c-dev \</span></span><br><span class="line"><span class="bash">    libxqilla-dev \</span></span><br><span class="line"><span class="bash">    libibverbs-dev \</span></span><br><span class="line"><span class="bash">    librdmacm-dev \</span></span><br><span class="line"><span class="bash">    libdb++-dev \</span></span><br><span class="line"><span class="bash">    libaio-dev \</span></span><br><span class="line"><span class="bash">    ruby ruby-dev \</span></span><br><span class="line"><span class="bash">    wget \</span></span><br><span class="line"><span class="bash">    unzip \</span></span><br><span class="line"><span class="bash">    git \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get clean</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Python 2 pip 和 setuptools</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> wget https://bootstrap.pypa.io/pip/2.7/get-pip.py &amp;&amp; python2 get-pip.py &amp;&amp; rm get-pip.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 Qpid-C++ 源码（可以替换成你自己的仓库）</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /opt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> git <span class="built_in">clone</span> https://gitbox.apache.org/repos/asf/qpid-cpp.git</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 build 目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /opt/qpid-cpp</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认进入 bash，方便调试</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="python2-7环境"><a href="#python2-7环境" class="headerlink" title="python2.7环境"></a>python2.7环境</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install python2.7</span><br><span class="line">ln -s /usr/bin/python2.7 /usr/bin/python</span><br><span class="line">python --version</span><br></pre></td></tr></table></figure>

<h1 id="qpid-cpp-的-CMake-逻辑"><a href="#qpid-cpp-的-CMake-逻辑" class="headerlink" title="qpid-cpp 的 CMake 逻辑"></a>qpid-cpp 的 CMake 逻辑</h1><p>顶层 <code>/opt/qpid-cpp/CMakeLists.txt</code> 是总控，主要负责：</p>
<ul>
<li><p>定义全局变量</p>
</li>
<li><p>配置 option、include path</p>
</li>
<li><p>调用 <code>add_subdirectory(src)</code>、<code>add_subdirectory(bindings)</code> 等子目录的 CMakeLists</p>
</li>
</ul>
<p>而**真正控制 <code>qpidd</code> 编译细节的是 <code>src/CMakeLists.txt</code>**。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span> (qpidd <span class="variable">$&#123;qpidd_SOURCES&#125;</span> /opt/qpid-cpp/build/coverage_runtime.o)</span><br><span class="line"><span class="keyword">target_compile_options</span>(qpidd PRIVATE -fsanitize-coverage=trace-pc-guard)</span><br><span class="line"><span class="keyword">target_link_libraries</span> (qpidd qpidbroker qpidcommon)</span><br></pre></td></tr></table></figure>

<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/qpid-cpp/build</span><br><span class="line">rm -rf CMakeCache.txt CMakeFiles</span><br><span class="line">CXX=clang++ CC=clang cmake -DBUILD_PROBES=no ..</span><br><span class="line">make -j$(nproc)</span><br></pre></td></tr></table></figure>

<h1 id="查看是否插桩成功"><a href="#查看是否插桩成功" class="headerlink" title="查看是否插桩成功"></a>查看是否插桩成功</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nm qpidd | grep trace_pc_guard</span><br></pre></td></tr></table></figure>

<h1 id="启动-Broker："><a href="#启动-Broker：" class="headerlink" title="启动 Broker："></a>启动 Broker：</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/sbin/qpidd</span><br><span class="line">/qpid-cpp/build/src/qpidd</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模糊测试</category>
      </categories>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>插桩覆盖率信息动态获取</title>
    <url>/2025/04/14/%E6%8F%92%E6%A1%A9%E8%A6%86%E7%9B%96%E7%8E%87%E4%BF%A1%E6%81%AF%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<h2 id="为什么afl插桩可以动态获取覆盖率，而gcov需要终止程序来收集？"><a href="#为什么afl插桩可以动态获取覆盖率，而gcov需要终止程序来收集？" class="headerlink" title="为什么afl插桩可以动态获取覆盖率，而gcov需要终止程序来收集？"></a>为什么afl插桩可以动态获取覆盖率，而gcov需要终止程序来收集？</h2><p>AFL（American Fuzzy Lop）使用的是<strong>插桩 + 共享内存的覆盖率收集机制</strong>。插桩后的代码会把覆盖信息写到一个共享内存区域。</p>
<p><code>gcov</code>这类工具，通常使用<strong>静态插桩 + 文件写出</strong>的方式收集覆盖率。只有在程序<strong>正常终止</strong>时，插桩逻辑才会将内存中的统计信息写到 <code>.gcda</code> 等文件中。</p>
<h2 id="GCC、Clang、LLVM-三者的区别"><a href="#GCC、Clang、LLVM-三者的区别" class="headerlink" title="GCC、Clang、LLVM 三者的区别"></a><strong>GCC、Clang、LLVM</strong> 三者的区别</h2><table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>GCC</strong></td>
<td>编译器套件</td>
<td>GNU 编译器合集，包括 <code>gcc</code>, <code>g++</code>, <code>gfortran</code> 等</td>
</tr>
<tr>
<td><strong>Clang</strong></td>
<td>编译器前端</td>
<td>LLVM 项目中的 C/C++/Objective-C 编译器</td>
</tr>
<tr>
<td><strong>LLVM</strong></td>
<td>编译基础设施框架</td>
<td>提供中间语言、优化、后端、JIT 等一整套架构</td>
</tr>
</tbody></table>
<h3 id="LLVM把gcc解耦了，前后端分离，模块化"><a href="#LLVM把gcc解耦了，前后端分离，模块化" class="headerlink" title="LLVM把gcc解耦了，前后端分离，模块化"></a>LLVM把gcc解耦了，前后端分离，模块化</h3><p> Source Code<br>          ▼<br>Frontend (Parser)<br>   GCC or Clang   ← GCC 与 Clang 竞争的是这里<br>          ▼<br>     LLVM IR          ← Clang 会转成中间代码<br>          ▼<br> Optimizer (opt)<br>          ▼<br> Backend (llc)<br> Generate Assembly<br>          ▼</p>
<p>   Linker (lld)     </p>
<h4 id="💡-AFL-根据你系统中安装的编译器选择不同的插桩模式和深度。你用得越高级（比如-afl-clang-fast），对-Clang-LLVM-的依赖就越强。"><a href="#💡-AFL-根据你系统中安装的编译器选择不同的插桩模式和深度。你用得越高级（比如-afl-clang-fast），对-Clang-LLVM-的依赖就越强。" class="headerlink" title="💡 AFL 根据你系统中安装的编译器选择不同的插桩模式和深度。你用得越高级（比如 afl-clang-fast），对 Clang/LLVM 的依赖就越强。"></a>💡 AFL 根据你系统中安装的编译器选择不同的插桩模式和深度。你用得越高级（比如 <code>afl-clang-fast</code>），对 Clang/LLVM 的依赖就越强。</h4><table>
<thead>
<tr>
<th>插桩方式</th>
<th>编译器依赖</th>
<th>插桩原理</th>
<th>是否推荐</th>
</tr>
</thead>
<tbody><tr>
<td><code>afl-gcc</code></td>
<td>只要 gcc 就行</td>
<td>静态插桩，效果一般</td>
<td>❌（老旧）</td>
</tr>
<tr>
<td><code>afl-clang</code></td>
<td>clang 即可</td>
<td>静态插桩</td>
<td>❌（少用了）</td>
</tr>
<tr>
<td><code>afl-clang-fast</code></td>
<td>clang + llvm</td>
<td>LLVM IR 级插桩（支持 PCGUARD）</td>
<td>✅ 推荐使用</td>
</tr>
</tbody></table>
<h4 id="afl-clang-fast-使用了-PCGUARD-插桩-，但还封装了-共享内存逻辑-路径-hash-热度计数；纯-PCGUARD-插桩更干净、更灵活，更适合你这种-Peach-外部控制执行流程的情况；-两者在“插桩方式”看起来类似，但在运行时处理覆盖率的方式不同（特别是-bitmap-的更新频率和逻辑）；"><a href="#afl-clang-fast-使用了-PCGUARD-插桩-，但还封装了-共享内存逻辑-路径-hash-热度计数；纯-PCGUARD-插桩更干净、更灵活，更适合你这种-Peach-外部控制执行流程的情况；-两者在“插桩方式”看起来类似，但在运行时处理覆盖率的方式不同（特别是-bitmap-的更新频率和逻辑）；" class="headerlink" title="afl-clang-fast` 使用了 PCGUARD 插桩 ，但还封装了 共享内存逻辑 + 路径 hash + 热度计数；纯 PCGUARD 插桩更干净、更灵活，更适合你这种 Peach 外部控制执行流程的情况； 两者在“插桩方式”看起来类似，但在运行时处理覆盖率的方式不同（特别是 bitmap 的更新频率和逻辑）；"></a>afl-clang-fast` 使用了 PCGUARD 插桩 ，但还封装了 <strong>共享内存逻辑 + 路径 hash + 热度计数</strong>；纯 PCGUARD 插桩更干净、更灵活，更适合你这种 Peach 外部控制执行流程的情况； 两者在“插桩方式”看起来类似，但在<strong>运行时处理覆盖率的方式</strong>不同（特别是 bitmap 的更新频率和逻辑）；</h4><table>
<thead>
<tr>
<th>项目</th>
<th>AFL 默认插桩（afl-gcc）</th>
<th>afl-clang-fast（基于 PCGUARD）</th>
<th>纯 PCGUARD 插桩</th>
</tr>
</thead>
<tbody><tr>
<td><strong>插桩方式</strong></td>
<td>修改源码或汇编</td>
<td>添加 LLVM IR pass，激活 <code>trace-pc-guard</code></td>
<td>使用 clang 内置的 <code>-fsanitize-coverage=trace-pc-guard</code></td>
</tr>
<tr>
<td><strong>插桩代码</strong></td>
<td>自己加 inline asm</td>
<td>让编译器插入回调，链接 AFL runtime</td>
<td>只插入调用 <code>__sanitizer_cov_trace_pc_guard()</code>，不链接 AFL runtime</td>
</tr>
<tr>
<td><strong>侵入性</strong></td>
<td>中等：依赖特殊宏定义</td>
<td>高：需要额外 runtime 支持</td>
<td>低：编译器自带</td>
</tr>
<tr>
<td><strong>性能影响</strong></td>
<td>中</td>
<td>高（加 hash + map 计数）</td>
<td>低（只标记一次命中）</td>
</tr>
<tr>
<td><strong>实时性能力</strong></td>
<td>✅ 用共享内存读 bitmap</td>
<td>✅ 可用共享内存</td>
<td>✅ 你可以自己定义共享内存 &amp; 写 hook</td>
</tr>
<tr>
<td><strong>结果粒度</strong></td>
<td>分支级别 + hit 频率</td>
<td>分支级别 + hit 桶</td>
<td>分支级别（单次）</td>
</tr>
</tbody></table>
<p> <strong>clang插桩编译</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -fsanitize-coverage&#x3D;trace-pc-guard -g -o target_cov target.c coverage_runtime.c</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Clang trace-pc-guard 插桩只是调用 <code>__sanitizer_cov_trace_pc_guard()</code>，但是你需要<strong>提供这个函数的定义</strong>来告诉程序 <strong>“hit 了这个分支之后要干什么”</strong>。</p>
</li>
<li><p><strong>记录在哪？怎么算？怎么展示？</strong> 这些逻辑都得你来写（AFL、SanCov、LibFuzzer 都是自带的 runtime 实现）。</p>
</li>
</ul>
<h4 id="当面对一个使用-Makefile-的项目，想用自己写的-PCGUARD-插桩-runtime（如-coverage-runtime-c）-时："><a href="#当面对一个使用-Makefile-的项目，想用自己写的-PCGUARD-插桩-runtime（如-coverage-runtime-c）-时：" class="headerlink" title="当面对一个使用 Makefile 的项目，想用自己写的 PCGUARD 插桩 runtime（如 coverage_runtime.c） 时："></a>当面对一个使用 <strong>Makefile</strong> 的项目，想用自己写的 <strong>PCGUARD 插桩 runtime（如 <code>coverage_runtime.c</code>）</strong> 时：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -O0 -g -fno-omit-frame-pointer -fsanitize-coverage&#x3D;trace-pc-guard -c coverage_runtime.c -o coverage_runtime.o</span><br><span class="line"></span><br><span class="line">make CC&#x3D;clang CFLAGS&#x3D;&quot;-O0 -g -fno-omit-frame-pointer -fsanitize-coverage&#x3D;trace-pc-guard&quot; LDFLAGS&#x3D;&quot;coverage_runtime.o -lrt&quot;</span><br></pre></td></tr></table></figure>

<h4 id="检查插桩了是否真的用上了自定义的runtime："><a href="#检查插桩了是否真的用上了自定义的runtime：" class="headerlink" title="检查插桩了是否真的用上了自定义的runtime："></a>检查插桩了是否真的用上了自定义的runtime：</h4><p>用nm命令查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nm fftp | grep trace_pc_guard</span><br></pre></td></tr></table></figure>

<p>输出大概如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000424fc0 T __sanitizer_cov_trace_pc_guard</span><br><span class="line">00000000004250b0 T __sanitizer_cov_trace_pc_guard_init</span><br><span class="line">0000000000ed4c28 b __sanitizer_cov_trace_pc_guard_init.N</span><br><span class="line">00000000004183a0 T __sanitizer_dump_trace_pc_guard_coverage</span><br><span class="line">0000000000425b10 t sancov.module_ctor_trace_pc_guard</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000417dd0 W __sanitizer_cov_trace_pc_guard</span><br><span class="line">0000000000417e20 W __sanitizer_cov_trace_pc_guard_init</span><br><span class="line">00000000004180d0 T __sanitizer_dump_trace_pc_guard_coverage</span><br><span class="line">00000000004252f0 t sancov.module_ctor_trace_pc_guard</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>w</code> 表示默认实现（空实现）</p>
</li>
<li><p><code>U</code> 表示程序用到了这个函数，但你需要 <strong>自己实现它</strong>。</p>
</li>
<li><p><code>T</code> 表示你实现了它。这才是对的！！</p>
</li>
<li><p><code>sancov.module_ctor_trace_pc_guard</code>说明有 guard 埋点</p>
</li>
</ul>
<h4 id="确保-coverage-runtime-o-在所有目标文件之前"><a href="#确保-coverage-runtime-o-在所有目标文件之前" class="headerlink" title="确保 coverage_runtime.o 在所有目标文件之前"></a>确保 <strong>coverage_runtime.o 在所有目标文件之前</strong></h4><h3 id="coverage-runtime-c"><a href="#coverage-runtime-c" class="headerlink" title="coverage_runtime.c"></a>coverage_runtime.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EDGES 65536</span></span><br><span class="line"><span class="keyword">uint8_t</span>* bitmap = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard(<span class="keyword">uint32_t</span>* guard) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> idx = *guard;</span><br><span class="line">    *guard = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (bitmap)</span><br><span class="line">        bitmap[idx % MAX_EDGES] = <span class="number">1</span>;  <span class="comment">// 标记为覆盖</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[PCGUARD] Hit idx: %u\n&quot;</span>, idx % MAX_EDGES);  <span class="comment">// 打印命中的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="keyword">uint32_t</span>* start, <span class="keyword">uint32_t</span>* stop) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint32_t</span> N;</span><br><span class="line">    <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/tmp/peach_cov_map&quot;</span>, O_CREAT | O_RDWR, <span class="number">0600</span>);</span><br><span class="line">    ftruncate(fd, MAX_EDGES);</span><br><span class="line">    bitmap = mmap(<span class="number">0</span>, MAX_EDGES, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span>* x = start; x &lt; stop; x++)</span><br><span class="line">        *x = ++N;  <span class="comment">// 每个guard初始化一个索引</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>guard就是edge的编号，hit（命中）了就记录在共享内存</p>
<table>
<thead>
<tr>
<th>特性/工具</th>
<th>LLVM/Clang 插桩</th>
<th>GCC/gcov 插桩</th>
</tr>
</thead>
<tbody><tr>
<td>插桩工具</td>
<td><code>-fsanitize-coverage=...</code></td>
<td><code>-fprofile-arcs -ftest-coverage</code></td>
</tr>
<tr>
<td>覆盖粒度</td>
<td>基本块、边（edge）、调用、返回等</td>
<td>行（line）、分支（branch）、函数（function）</td>
</tr>
<tr>
<td>用途</td>
<td>模糊测试、路径去重、反馈引导优化等</td>
<td>单元测试、代码覆盖分析</td>
</tr>
<tr>
<td>代表工具</td>
<td>AFL, LibFuzzer, etc.</td>
<td>gcov, lcov, gcovr</td>
</tr>
<tr>
<td>报告能力</td>
<td>不生成测试报告（靠 fuzz 工具处理 bitmap）</td>
<td>自动生成 <code>.gcov</code> 报告文件</td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="共享内存需要注意的问题"><a href="#共享内存需要注意的问题" class="headerlink" title="共享内存需要注意的问题"></a>共享内存需要注意的问题</h2><h4 id="1-mmap映射文件到内存时必须先预分配大小，ftruncate-fd-MAX-EDGES-要不然可能报错Aborted-core-dumped"><a href="#1-mmap映射文件到内存时必须先预分配大小，ftruncate-fd-MAX-EDGES-要不然可能报错Aborted-core-dumped" class="headerlink" title="1) mmap映射文件到内存时必须先预分配大小，ftruncate(fd, MAX_EDGES); 要不然可能报错Aborted (core dumped)"></a>1) mmap映射文件到内存时必须先预分配大小，ftruncate(fd, MAX_EDGES); 要不然可能报错Aborted (core dumped)</h4><h4 id="2-插桩runtime中定义的共享内存的地址、大小与读取覆盖率信息的程序中的必须保证完全一致，要不然可能读写的不是一个东西，导致输出全为0或其他错误。"><a href="#2-插桩runtime中定义的共享内存的地址、大小与读取覆盖率信息的程序中的必须保证完全一致，要不然可能读写的不是一个东西，导致输出全为0或其他错误。" class="headerlink" title="2) 插桩runtime中定义的共享内存的地址、大小与读取覆盖率信息的程序中的必须保证完全一致，要不然可能读写的不是一个东西，导致输出全为0或其他错误。"></a>2) 插桩runtime中定义的共享内存的地址、大小与读取覆盖率信息的程序中的必须保证完全一致，要不然可能读写的不是一个东西，导致输出全为0或其他错误。</h4><h4 id="3-读取覆盖率信息的程序也可以创建共享内存文件，-可以避免执行先后顺序的问题。如果只读，有可能在SUT还没启动时就去访问共享内存初始化什么的出错。"><a href="#3-读取覆盖率信息的程序也可以创建共享内存文件，-可以避免执行先后顺序的问题。如果只读，有可能在SUT还没启动时就去访问共享内存初始化什么的出错。" class="headerlink" title="3) 读取覆盖率信息的程序也可以创建共享内存文件， 可以避免执行先后顺序的问题。如果只读，有可能在SUT还没启动时就去访问共享内存初始化什么的出错。"></a>3) 读取覆盖率信息的程序也可以创建共享内存文件， 可以避免执行先后顺序的问题。如果只读，有可能在SUT还没启动时就去访问共享内存初始化什么的出错。</h4><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -fsanitize-coverage&#x3D;trace-pc-guard -g -o target_cov target.c coverage_runtime.c</span><br><span class="line">clang control.c -fPIC -shared -o libruntime.so</span><br><span class="line">mcs Program.cs -out:peach.exe</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模糊测试</category>
      </categories>
      <tags>
        <tag>插桩</tag>
      </tags>
  </entry>
  <entry>
    <title>修改peach源码</title>
    <url>/2025/04/08/%E4%BF%AE%E6%94%B9peach%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h1 id="一、解析xml到dom"><a href="#一、解析xml到dom" class="headerlink" title="一、解析xml到dom"></a>一、解析xml到dom</h1><h2 id="1、任何元素节点都要定义一个类，在Dom文件夹下"><a href="#1、任何元素节点都要定义一个类，在Dom文件夹下" class="headerlink" title="1、任何元素节点都要定义一个类，在Dom文件夹下"></a>1、任何元素节点都要定义一个类，在Dom文件夹下</h2><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Peach.Core.Dom</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">PitParsable(<span class="meta-string">&quot;Field&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Field</span> : <span class="title">DataElement</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Field</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataElement <span class="title">PitParser</span>(<span class="params">PitParser context, XmlNode node, DataElementContainer parent</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> fieldName = node.getAttrString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> fieldValue = node.getAttrString(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> field = <span class="keyword">new</span> Field(fieldName);</span><br><span class="line">            field.DefaultValue = <span class="keyword">new</span> Variant(fieldValue);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> field;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最重要的就是标记能被解析到，然后有个解析函数PitParser</p>
<h2 id="2、PitParser解析，在Peach-Core-Analyzers"><a href="#2、PitParser解析，在Peach-Core-Analyzers" class="headerlink" title="2、PitParser解析，在Peach.Core.Analyzers"></a>2、PitParser解析，在Peach.Core.Analyzers</h2><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">dataModelPitParsable[<span class="string">&quot;DataModel&quot;</span>] = <span class="keyword">typeof</span>(DataModel);</span><br><span class="line">dataElementPitParsable[<span class="string">&quot;Field&quot;</span>] = <span class="keyword">typeof</span>(Field);</span><br></pre></td></tr></table></figure>

<p>主要就是存储元素节点的字典，根据name获取解析方法解析。</p>
<p>然后，在handlePeach函数中添加相应节点的处理逻辑</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pass 2 - 解析 ConfigModel</span></span><br><span class="line">            <span class="keyword">foreach</span> (XmlNode child <span class="keyword">in</span> node.ChildNodes)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (child.Name == <span class="string">&quot;ConfigModel&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> config = handleConfigModel(child, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (config != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">try</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            dom.confcigModels.Add(config.name, config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        catch (ArgumentException)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">var</span> entry = dataModelPitParsable.Where(kv =&gt; kv.Value == config.GetType()).Select(kv =&gt; kv.Key).FirstOrDefault();</span><br><span class="line">                            <span class="keyword">var</span> name = entry != <span class="literal">null</span> ? <span class="string">&quot;&lt;&quot;</span> + entry + <span class="string">&quot;&gt;&quot;</span> : <span class="string">&quot;Config Model&quot;</span>;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> PeachException(<span class="string">&quot;Error, a &quot;</span> + name + <span class="string">&quot; element named &#x27;&quot;</span> + config.name + <span class="string">&quot;&#x27; already exists.&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>其中，dom类中需要增加相应变量的支持，比如confcigModels集合</p>
<ul>
<li><p><strong>Dom</strong>：</p>
<ul>
<li>Dom 是整个解析后的文档对象模型，包含所有的顶级元素，例如 StateModel、Agent、Publisher 等。</li>
<li>它是全局的，存储了所有解析后的对象。</li>
</ul>
</li>
<li><p><strong>Test</strong>：</p>
<ul>
<li>Test 是 Dom 的一个子集，表示一个具体的测试配置。</li>
<li>它引用了 Dom 中的某些对象（如 StateModel 和 Publisher），并将它们存储在自己的上下文中。</li>
</ul>
</li>
</ul>
<p>想解析存储到test中时，test类中也要有相应变量的支持。</p>
<h1 id="二、测试引擎engine"><a href="#二、测试引擎engine" class="headerlink" title="二、测试引擎engine"></a>二、测试引擎engine</h1><h2 id="取出一个configmodel来启动server"><a href="#取出一个configmodel来启动server" class="headerlink" title="取出一个configmodel来启动server"></a>取出一个configmodel来启动server</h2><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> assignedConfigKey = context.config.parallelNum % dom.configModels.Count;</span><br><span class="line">ConfigModel assignedConfig = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> key <span class="keyword">in</span> dom.configModels.Keys)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == assignedConfigKey)</span><br><span class="line">    &#123;</span><br><span class="line">        assignedConfig = dom.configModels[key];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The current machine is executing the configmodel:&quot;</span>);</span><br><span class="line">Console.WriteLine(assignedConfig); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Start agents</span></span><br><span class="line"><span class="keyword">foreach</span> (Dom.Agent agent <span class="keyword">in</span> test.agents.Values)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Only use agent if on correct platform</span></span><br><span class="line">    <span class="keyword">if</span> ((agent.platform &amp; Platform.GetOS()) != Platform.OS.None)</span><br><span class="line">    &#123;</span><br><span class="line">        context.agentManager.AgentConnect(agent,assignedConfig);</span><br><span class="line">        context.agentManager.GetAgent(agent.name).SessionStarting();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note: We want to perfrom SessionStarting on each agent</span></span><br><span class="line">        <span class="comment">//       in turn.  We do this incase the first agent starts</span></span><br><span class="line">        <span class="comment">//       a virtual machine that contains the second agent.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="agent的调用链"><a href="#agent的调用链" class="headerlink" title="agent的调用链"></a>agent的调用链</h2><p><strong>Engine=&gt;AgentManager=&gt;AgentClient=&gt;AgentServerLocal=&gt;Agent=&gt;monitor</strong></p>
<p> AgentServerLocal继承自 AgentClient, AgentServerLocal里又有个Agent，Agent通过反射机制创建monitor的实例</p>
<h1 id="三、runtime"><a href="#三、runtime" class="headerlink" title="三、runtime"></a>三、runtime</h1><p>在runtime下的ConsoleWatcher.cs可以输出迭代信息，获取覆盖率显示等。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span>&lt;<span class="title">uint</span>&gt; seenPaths</span> = <span class="keyword">new</span> HashSet&lt;uint&gt;();</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">&quot;libcoverage.so&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">get_edge_coverage_count</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">&quot;libcoverage.so&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> uint <span class="title">get_path_hash</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">&quot;libcoverage.so&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">reset_path_hash</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Engine_IterationFinished</span>(<span class="params">RunContext context, uint currentIteration</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> edgeHits = get_edge_coverage_count();</span><br><span class="line">    uint pathHash = get_path_hash();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> isNew = seenPaths.Add(pathHash);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;[✓] Edge coverage count: &quot;</span> + edgeHits);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;[✓] Current path hash: 0x&quot;</span> + pathHash.ToString(<span class="string">&quot;X8&quot;</span>) + (isNew ? <span class="string">&quot; (new)&quot;</span> : <span class="string">&quot; (duplicate)&quot;</span>));</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;[=] Total unique paths so far: &quot;</span> + seenPaths.Count);</span><br><span class="line"></span><br><span class="line">    reset_path_hash();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模糊测试工具</category>
      </categories>
      <tags>
        <tag>peach</tag>
      </tags>
  </entry>
  <entry>
    <title>编译运行Peach</title>
    <url>/2025/03/28/%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8CPeach/</url>
    <content><![CDATA[<h1 id="Dockfile"><a href="#Dockfile" class="headerlink" title="Dockfile"></a>Dockfile</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 Ubuntu 14.04 作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装基础依赖和Python 2</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">    build-essential \</span></span><br><span class="line"><span class="bash">    mono-complete \</span></span><br><span class="line"><span class="bash">    g++-multilib \</span></span><br><span class="line"><span class="bash">    python2.7 \</span></span><br><span class="line"><span class="bash">    <span class="comment"># 安装旧版GCC/G++ 4.8以兼容Pin工具包</span></span></span><br><span class="line">    gcc-<span class="number">4.8</span> \</span><br><span class="line">    g++-<span class="number">4.8</span> \</span><br><span class="line">    gcc-<span class="number">4.8</span>-multilib \</span><br><span class="line">    g++-<span class="number">4.8</span>-multilib \</span><br><span class="line">    <span class="comment"># 安装其他必要依赖</span></span><br><span class="line">    libpng-dev \</span><br><span class="line">    wget \</span><br><span class="line">    git \</span><br><span class="line">    &amp;&amp; ln -s /usr/bin/python2.<span class="number">7</span> /usr/bin/python \</span><br><span class="line">    <span class="comment"># 设置默认编译器为gcc-4.8/g++-4.8</span></span><br><span class="line">    &amp;&amp; update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-<span class="number">4.8</span> <span class="number">100</span> \</span><br><span class="line">    &amp;&amp; update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-<span class="number">4.8</span> <span class="number">100</span> \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /peach</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制Peach源代码到容器</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./peachfuzz-code/ .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /peach/3rdParty/pin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pin文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./pin-3.19-98425-gd666b2bee-gcc-linux.tar.gz .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -xzf pin-3.19-98425-gd666b2bee-gcc-linux.tar.gz \</span></span><br><span class="line"><span class="bash">&amp;&amp; mv pin-2.13-61206-gcc.4.4.7-linux/ pin-2.13-61206-gcc.4.4.7-linux-back/ &amp;&amp; mv pin-3.19-98425-gd666b2bee-gcc-linux/ pin-2.13-61206-gcc.4.4.7-linux/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保waf有执行权限并编译</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x ./waf &amp;&amp; \</span></span><br><span class="line"><span class="bash">  ./waf configure &amp;&amp; \</span></span><br><span class="line"><span class="bash">  ./waf build &amp;&amp; \</span></span><br><span class="line"><span class="bash">  ./waf install</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /peach/output</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认启动命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="使用-Ubuntu-14-04-作为基础镜像"><a href="#使用-Ubuntu-14-04-作为基础镜像" class="headerlink" title="使用 Ubuntu 14.04 作为基础镜像"></a>使用 Ubuntu 14.04 作为基础镜像</h1><p>编译peach3.x版本，版本比较老，需要用到比较老的mono版本，Ubuntu 14相应的mono为3.x版本，可以编译通过。</p>
<table>
<thead>
<tr>
<th>Ubuntu</th>
<th>14.04.1</th>
<th>16.04.1</th>
<th>18.04.1</th>
</tr>
</thead>
<tbody><tr>
<td>linux</td>
<td>3.13.0</td>
<td>4.4.0</td>
<td>4.15.0</td>
</tr>
<tr>
<td>mono</td>
<td>3.2.8</td>
<td>4.2.1.102</td>
<td>4.6.2.7</td>
</tr>
</tbody></table>
<h1 id="安装基础依赖和Python-2"><a href="#安装基础依赖和Python-2" class="headerlink" title="安装基础依赖和Python 2"></a>安装基础依赖和Python 2</h1><p>主要注意gcc、python版本也要低，python2执行waf</p>
<h1 id="自己安装mono"><a href="#自己安装mono" class="headerlink" title="自己安装mono"></a>自己安装mono</h1><p>下载源码 <a href="https://origin-download.mono-project.com/sources/mono/">https://origin-download.mono-project.com/sources/mono/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install bison</span><br><span class="line">apt-get install gettext</span><br><span class="line"></span><br><span class="line">tar  jvxf  mono-xxx.tar.bz2</span><br><span class="line">cd  &#x2F;mono-xxx</span><br><span class="line"></span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr </span><br><span class="line">make</span><br><span class="line">make  install</span><br></pre></td></tr></table></figure>

<h2 id="自己安装mono-之在ubuntu-22-04实战"><a href="#自己安装mono-之在ubuntu-22-04实战" class="headerlink" title="自己安装mono 之在ubuntu 22.04实战"></a>自己安装mono 之在ubuntu 22.04实战</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://download.mono-project.com/sources/mono/mono-4.8.0.520.tar.bz2</span><br><span class="line">tar -xvjf mono-4.8.0.520.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> mono-4.8.0.520</span><br><span class="line">./configure --prefix=/opt/mono-4.8</span><br><span class="line">make -j$(nproc)</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/mono-4.8/bin/mono --version</span><br></pre></td></tr></table></figure>

<p><strong>glibc 2.25+</strong> 之后，把 <code>makedev()</code> 从 <code>&lt;sys/types.h&gt;</code> 移到了 <code>&lt;sys/sysmacros.h&gt;</code>，而 Mono 4.8 的代码还写的是老版本方式，导致找不到。直接在 processes.c 顶部加一句：</p>
<p>打开 <code>mono/io-layer/processes.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sysmacros.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>就能解决。</p>
<p>还可能缺少 <strong>libgdiplus</strong> 这个动态库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install -y libgdiplus</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/opt/mono-4.8/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<h1 id="WORKDIR-命令"><a href="#WORKDIR-命令" class="headerlink" title="WORKDIR 命令"></a>WORKDIR 命令</h1><p>WORKDIR命令指定工作目录，可对后续代码产生影响。</p>
<p>而RUN命令只对当前命令有效，cd只影响当前命令，命令执行完，下一个RUN会回到workdir工作目录</p>
<h1 id="COPY-命令"><a href="#COPY-命令" class="headerlink" title="COPY 命令"></a>COPY 命令</h1><p>在 <code>COPY</code> 指令中，<code>./XXX/</code> 末尾的 <code>/</code> 表示复制XXX目录下的所有内容，而不是整个目录。</p>
<p>去掉末尾的/，则连着文件名也复制过来</p>
<h1 id="Pin文件"><a href="#Pin文件" class="headerlink" title="Pin文件"></a>Pin文件</h1><p>下载的Peach3.1.124源码中，/3rdParty/pin下的包编译时会出错，好像是损坏了。</p>
<p>直接网上下载了个pin3.x的过去顶上，结果编译也成功了</p>
<p><a href="https://software.intel.com/sites/landingpage/pintool/downloads/pin-3.19-98425-gd666b2bee-gcc-linux.tar.gz">https://software.intel.com/sites/landingpage/pintool/downloads/pin-3.19-98425-gd666b2bee-gcc-linux.tar.gz</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最终在mono3.x+pin3.x+gcc4.x+peach3.x+ubuntu14这个环境下编译成功了！！</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>编译环境较老，待测协议却又不一定能跑起来？</p>
<p>可以编译好之后，复制出bin目录文件到Ubuntu18等环境中去适配测试协议！！</p>
]]></content>
      <categories>
        <category>模糊测试工具</category>
      </categories>
      <tags>
        <tag>peach</tag>
      </tags>
  </entry>
  <entry>
    <title>论文中画各种图</title>
    <url>/2025/03/25/%E8%AE%BA%E6%96%87%E4%B8%AD%E7%94%BB%E5%90%84%E7%A7%8D%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="画折线图"><a href="#画折线图" class="headerlink" title="画折线图"></a>画折线图</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line"> </span><br><span class="line">#epoch,acc,loss,val_acc,val_loss</span><br><span class="line">x_axis_data &#x3D; list(range(0,24,2))</span><br><span class="line">y_axis_data1 &#x3D; [68.72,69.17,69.26,69.63,69.35,70.3,66.8,90,92,93,95,99]</span><br><span class="line">y_axis_data2 &#x3D; [52,71,73,66,74,82,71,90,91,93,94,99]</span><br><span class="line">y_axis_data3 &#x3D; [82,83,82,76,84,92,81,90,91,92,93,95]</span><br><span class="line">     </span><br><span class="line">#画图 </span><br><span class="line">plt.gca().set_facecolor(&#39;#f3f7ff&#39;)</span><br><span class="line"></span><br><span class="line">plt.plot(x_axis_data, y_axis_data1, &#39;b*--&#39;, alpha&#x3D;1, linewidth&#x3D;1, label&#x3D;&#39;acc&#39;)#&#39;</span><br><span class="line">plt.plot(x_axis_data, y_axis_data2, &#39;rs--&#39;, alpha&#x3D;1, linewidth&#x3D;1, label&#x3D;&#39;acc&#39;)</span><br><span class="line">plt.plot(x_axis_data, y_axis_data3, &#39;go--&#39;, alpha&#x3D;1, linewidth&#x3D;1, label&#x3D;&#39;acc&#39;)</span><br><span class="line">plt.xticks(x_axis_data)</span><br><span class="line"># plt.xticks(y_axis_data1)</span><br><span class="line"></span><br><span class="line">plt.legend(loc&#x3D;&quot;best&quot;)  #显示上面的label</span><br><span class="line">plt.xlabel(&#39;Hours&#39;)</span><br><span class="line">plt.ylabel(&#39;Coverage&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># plt.grid(color&#x3D;&#39;gray&#39;, alpha&#x3D;0.5, linestyle&#x3D;&#39;:&#39;)</span><br><span class="line">plt.grid(True, which&#x3D;&#39;major&#39;, linestyle&#x3D;&#39;-&#39;, color&#x3D;&#39;gray&#39;, alpha&#x3D;0.3)</span><br><span class="line">plt.grid(True, which&#x3D;&#39;minor&#39;, linestyle&#x3D;&#39;:&#39;, color&#x3D;&#39;gray&#39;, alpha&#x3D;0.3)</span><br><span class="line">plt.minorticks_on()</span><br><span class="line"></span><br><span class="line"># plt.figure(figsize&#x3D;(12, 6),dpi&#x3D;300)  # 设置dpi为300，可以根据需要调整</span><br><span class="line">plt.savefig(&#39;fix2.png&#39;, dpi&#x3D;300) #指定分辨率保存</span><br><span class="line">plt.show()</span><br><span class="line">plt.close()</span><br></pre></td></tr></table></figure>

<h1 id="画柱状图"><a href="#画柱状图" class="headerlink" title="画柱状图"></a>画柱状图</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="画雷达图"><a href="#画雷达图" class="headerlink" title="画雷达图"></a>画雷达图</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">def plot_radar_chart(labels, array, title):</span><br><span class="line"></span><br><span class="line">    plt.rcParams.update(&#123;&#39;font.size&#39;: 25&#125;)</span><br><span class="line">    # 设置全局刻度字体大小</span><br><span class="line">    # plt.rcParams[&#39;xtick.labelsize&#39;] &#x3D; 25  # x轴刻度字体大小</span><br><span class="line">    plt.rcParams[&#39;ytick.labelsize&#39;] &#x3D; 25  # y轴刻度字体大小</span><br><span class="line">    </span><br><span class="line">    fuzzer &#x3D; [&quot;LLM_atr1&quot;,&quot;LLM_atr2&quot;,&quot;LLM_atr3&quot;,&quot;human&quot;]</span><br><span class="line">    fuzzer &#x3D; [&quot;LLM&quot;,&quot;Human&quot;]</span><br><span class="line">    colors &#x3D; [&#39;r&#39;,&#39;b&#39;,&#39;r&#39;,&#39;b&#39;]</span><br><span class="line">    num_vars &#x3D; len(labels)</span><br><span class="line">    len_val &#x3D; len(array)</span><br><span class="line"></span><br><span class="line">    angles &#x3D; np.linspace(0, 2 * np.pi, num_vars, endpoint&#x3D;False).tolist()</span><br><span class="line"></span><br><span class="line">    angles +&#x3D; angles[:1]</span><br><span class="line">    </span><br><span class="line">    fig, ax &#x3D; plt.subplots(figsize&#x3D;(14, 12), subplot_kw&#x3D;dict(polar&#x3D;True))</span><br><span class="line">    </span><br><span class="line">    # 设置背景颜色</span><br><span class="line">    ax.set_facecolor(&#39;#f3f7ff&#39;)  # 这里设置为浅灰色，你可以根据需要修改颜色</span><br><span class="line"></span><br><span class="line">    for i in range(len_val):</span><br><span class="line">        values &#x3D; []</span><br><span class="line">        values &#x3D; array[i]  </span><br><span class="line">        values +&#x3D; values[:1]</span><br><span class="line">        </span><br><span class="line">        # print(angles)</span><br><span class="line">        # print(values)</span><br><span class="line">        ax.fill(angles, values, color&#x3D;colors[i], alpha&#x3D;0.1)</span><br><span class="line">        ax.plot(angles, values, linewidth&#x3D;1, linestyle&#x3D;&#39;solid&#39;, label&#x3D;fuzzer[i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ax.grid(linewidth&#x3D;1, linestyle&#x3D;&#39;--&#39;, alpha&#x3D;0.5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ax.spines[&#39;polar&#39;].set_visible(False)</span><br><span class="line"></span><br><span class="line">    #设置y轴显示</span><br><span class="line">    # ax.set_yticklabels([0,1,2,3,4])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ax.set_xticks(angles[:-1])</span><br><span class="line"> </span><br><span class="line">    ax.set_xticklabels(labels)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 调整圆的间隔</span><br><span class="line">    # ax.set_rticks([0, 0.3, 0.6, 0.9, 1.2])  # 设置径向刻度的位置</span><br><span class="line">    ax.set_rlabel_position(15)  # 设置径向刻度标签的位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # plt.title(title)</span><br><span class="line"></span><br><span class="line">    # 添加图例loc&#x3D;&#39;best&#39;,</span><br><span class="line">    plt.legend(loc &#x3D; (0.9, 0.95))</span><br><span class="line">    # fig.legend(loc&#x3D;&#39;best&#39;)</span><br><span class="line"></span><br><span class="line">    return ax</span><br><span class="line"></span><br><span class="line">#   # 打印所有可用的样式列表</span><br><span class="line"># for i in plt.style.available:</span><br><span class="line">#可读性</span><br><span class="line">	#DIV&#x2F;0!	</span><br><span class="line"># values &#x3D; [ [4.088888889,	3.458730159,	3.576190476],[3.771428682,	2.492063381,	3.657142857]]</span><br><span class="line"># plot_radar_chart([&#39;name&#39;, &#39;note&#39;, &#39;field&#39;],values, &#39;&#39;)</span><br><span class="line"></span><br><span class="line">#语义</span><br><span class="line"># [0.83521746,0.769798413,0.704907937,0.65028254,0.7487],  [0.83521746,0.769798413,0.704907937,0.65028254,0.9366],</span><br><span class="line"># values &#x3D; [ [0.83521746,0.769798413,0.704907937,0.65028254,1],[0.684297279,0.639577778	,0.584657143,0.505793651,1]]</span><br><span class="line"># plot_radar_chart([&#39;data model&#39;, &#39;state model&#39;,&#39;action&#39;, &#39;transfer&#39;,  &#39;attribute&#39;],values, &#39;&#39;)</span><br><span class="line"></span><br><span class="line"># values &#x3D; [ [0.83521746,0.769798413,0.704907937,0.65028254,0.7487,4.088888889&#x2F;5,	3.458730159&#x2F;5,	3.576190476&#x2F;5],</span><br><span class="line"># [0.684297279,0.639577778	,0.584657143,0.505793651,1,3.771428682&#x2F;5,	2.492063381&#x2F;5,	3.657142857&#x2F;5]]</span><br><span class="line"># plot_radar_chart([&#39;data model&#39;, &#39;state model&#39;,&#39;action&#39;, &#39;transfer&#39;,  &#39;attribute&#39;,&#39;name&#39;, &#39;note&#39;, &#39;field&#39;],values, &#39;&#39;)</span><br><span class="line"></span><br><span class="line"># values &#x3D; [ [0.83521746,0.769798413,0.704907937,0.65028254,0.9366,4.088888889&#x2F;5,	3.458730159&#x2F;5,	3.576190476&#x2F;5],</span><br><span class="line"># [0.684297279,0.639577778	,0.584657143,0.505793651,1,3.771428682&#x2F;5,	2.492063381&#x2F;5,	3.657142857&#x2F;5]]</span><br><span class="line"># plot_radar_chart([&#39;data model&#39;, &#39;state model&#39;,&#39;action&#39;, &#39;transfer&#39;,  &#39;attribute&#39;,&#39;name&#39;, &#39;note&#39;, &#39;field&#39;],values, &#39;&#39;)</span><br><span class="line"></span><br><span class="line">values &#x3D; [ [0.83521746,0.769798413,0.704907937,0.65028254,1,4.088888889&#x2F;5,	3.458730159&#x2F;5,	3.576190476&#x2F;5],</span><br><span class="line">[0.684297279,0.639577778	,0.584657143,0.505793651,1,3.771428682&#x2F;5,	2.492063381&#x2F;5,	3.657142857&#x2F;5]]</span><br><span class="line">plot_radar_chart([&#39;DataModelNode&#39;, &#39;StateModelNode&#39;,&#39;Action&#39;, &#39;Transfer&#39;,  &#39;Attribute&#39;,&#39;Name&#39;, &#39;Note&#39;, &#39;Field&#39;],values, &#39;&#39;)</span><br><span class="line"></span><br><span class="line">plt.savefig(&#39;read.png&#39;, dpi&#x3D;300) #指定分辨率保存</span><br><span class="line">plt.show()</span><br><span class="line">plt.close()</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>photoshop之签名变清晰</title>
    <url>/2024/11/27/photoshop%E4%B9%8B%E7%AD%BE%E5%90%8D%E5%8F%98%E6%B8%85%E6%99%B0/</url>
    <content><![CDATA[<h1 id="模糊的手写签名图像变清晰"><a href="#模糊的手写签名图像变清晰" class="headerlink" title="模糊的手写签名图像变清晰"></a>模糊的手写签名图像变清晰</h1><p>step1： 在 Photoshop 中打开手写签名图片，调用“图像” → “调整” → “色阶”命令</p>
<p><img src="C:\Users\15287\Desktop\1.jpg" alt="1"><img src="C:\Users\15287\Desktop\2.jpg" alt="2"></p>
<p>在弹出的对话框中，用“黑场”吸管工具在笔画上点击，以其浓淡程度作为黑色标准，之后，点击“确定”按钮。</p>
<p>step2：调用“滤镜” → “模糊” → “高斯模糊”命令</p>
<p><img src="C:\Users\15287\Desktop\3.jpg" alt="3"><img src="C:\Users\15287\Desktop\4.jpg" alt="4"></p>
<p>在弹出的对话框中，根据图片大小设定模糊半径（本例设为 1 个像素），以便让笔画变得稍微圆润些，然后点击“确定”按钮。</p>
<p>step3：调用“图像” → “调整” → “阈值”命令</p>
<p><img src="C:\Users\15287\Desktop\6.jpg" alt="6"><img src="C:\Users\15287\Desktop\7.jpg" alt="7"></p>
<p>在弹出的对话框中，一边用鼠标拖动滑块，一边观察笔画粗细的变化，当觉得满意后，点击“确定”按钮。</p>
<p>最终效果图：</p>
<p><img src="file:///C:/Users/15287/Pictures/Typedown/1f07b9cf-9874-49cf-85d2-1b05a3eaca6a.png" alt="1f07b9cf-9874-49cf-85d2-1b05a3eaca6a"></p>
]]></content>
  </entry>
  <entry>
    <title>Ubuntu常用命令</title>
    <url>/2024/10/23/Ubuntu%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="1、解压"><a href="#1、解压" class="headerlink" title="1、解压"></a>1、解压</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar –xvf file.tar  </span><br><span class="line">tar -xzvf file.tar.gz </span><br></pre></td></tr></table></figure>

<h1 id="2、vi的增删改查"><a href="#2、vi的增删改查" class="headerlink" title="2、vi的增删改查"></a>2、vi的增删改查</h1><h3 id="在Vi中执行搜索的基本步骤如下："><a href="#在Vi中执行搜索的基本步骤如下：" class="headerlink" title="在Vi中执行搜索的基本步骤如下："></a>在Vi中执行搜索的基本步骤如下：</h3><ol>
<li>按<code>/</code>，向前搜索。按<code>?</code>，向后搜索。</li>
<li>输入搜索模式或者字符串。</li>
<li>按<code>Enter</code>执行搜索。</li>
<li>按<code>n</code>查找 下一个事件或<code>N</code>查找上一个事件</li>
</ol>
<h3 id="ndd-向下删除当前行在内的n行"><a href="#ndd-向下删除当前行在内的n行" class="headerlink" title="ndd      //向下删除当前行在内的n行"></a>ndd      //向下删除当前行在内的n行</h3><h3 id="esc-dG-删除光标后的所有内容"><a href="#esc-dG-删除光标后的所有内容" class="headerlink" title="esc+dG //删除光标后的所有内容"></a>esc+dG //删除光标后的所有内容</h3><h1 id="3、查看ubuntu版本"><a href="#3、查看ubuntu版本" class="headerlink" title="3、查看ubuntu版本"></a>3、查看ubuntu版本</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure>

<h1 id="5、根据端口查pid"><a href="#5、根据端口查pid" class="headerlink" title="5、根据端口查pid"></a>5、根据端口查pid</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ss -tulpn | grep :&lt;端口号&gt;</span><br><span class="line"></span><br><span class="line">netstat -tulpn | grep :&lt;端口号&gt;</span><br></pre></td></tr></table></figure>

<h2 id="6、查看运行的进程"><a href="#6、查看运行的进程" class="headerlink" title="6、查看运行的进程"></a>6、查看运行的进程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux | grep hello</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>跑协议遇到的问题</title>
    <url>/2024/10/21/%E8%B7%91%E5%8D%8F%E8%AE%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1、libmodbus的使用"><a href="#1、libmodbus的使用" class="headerlink" title="1、libmodbus的使用"></a>1、libmodbus的使用</h1><h2 id="1、重点关注项目下的3个文件夹：doc，src，tests"><a href="#1、重点关注项目下的3个文件夹：doc，src，tests" class="headerlink" title="1、重点关注项目下的3个文件夹：doc，src，tests"></a>1、重点关注项目下的3个文件夹：doc，src，tests</h2><ul>
<li><p>doc文件夹包含库的使用文档，文件名就是函数名，介绍每个函数的使用方法，参数定制，返回值说明，示例代码等。</p>
</li>
<li><p>src文件夹包含源文件和头文件，我们只需要把这些文件添加到工程中，然后包含头文件就可以直接使用了。</p>
</li>
<li><p>tests文件夹包含libmodbus使用示例。</p>
</li>
</ul>
<h2 id="2、使用autoconf构建makefile文件"><a href="#2、使用autoconf构建makefile文件" class="headerlink" title="2、使用autoconf构建makefile文件"></a>2、使用autoconf构建makefile文件</h2><pre><code> ./configure CC=gcc CXX=g++ CFLAGS=&quot;-g -fprofile-arcs -ftest-coverage&quot;</code></pre>
<p>“-fprofile-arcs -ftest-coverage” 这个参数开启插桩编译。</p>
<p>“Run <code>./autogen.sh</code> first to generate the <code>configure</code> script if required.”</p>
<h2 id="3、执行tests下的测试程序产生-gcda-文件"><a href="#3、执行tests下的测试程序产生-gcda-文件" class="headerlink" title="3、执行tests下的测试程序产生 *.gcda 文件"></a>3、执行tests下的测试程序产生 *.gcda 文件</h2><pre><code># 生成覆盖率文本报告
lcov -c -d . -o test.info --rc lcov_branch_coverage=1 
# 生成覆盖率网页报告
genhtml --branch-coverage -o result test.info </code></pre>
<p>执行命令后，可以看到一个 result 文件夹，在里面就是对应的网页版覆盖率报告。</p>
<h1 id="2、LightFTP"><a href="#2、LightFTP" class="headerlink" title="2、LightFTP"></a>2、LightFTP</h1><p>Q：不能生成.gcda覆盖率文件？</p>
<p>A：因为程序没有正常结束，需要输入q来结束程序才行，不可以用ctrl+c。</p>
<p>或者添加信号处理函数。</p>
<h1 id="3、live555"><a href="#3、live555" class="headerlink" title="3、live555"></a>3、live555</h1><p>可以使用VLC工具来查看meidia推送的音乐、视频等资源</p>
<h1 id="3、AFLNet报错"><a href="#3、AFLNet报错" class="headerlink" title="3、AFLNet报错"></a>3、AFLNet报错</h1><p>内存限制问题：-p 协议名 -m none</p>
<h1 id="4、profuzzbench相关问题"><a href="#4、profuzzbench相关问题" class="headerlink" title="4、profuzzbench相关问题"></a>4、profuzzbench相关问题</h1><h2 id="1）Dockerfile"><a href="#1）Dockerfile" class="headerlink" title="1）Dockerfile"></a>1）Dockerfile</h2><p>fuzzer（AFLNet） 的git链接对不对，涉及到补丁能不能正确补上，以支持相关协议测试。 </p>
<p>COPY命令确保原文件本身有执行权限，要不然COPY过去权限一样的</p>
<p>为了收集覆盖率，协议源码往往需要修改主函数能够处理中断信号</p>
<h2 id="2）run-sh"><a href="#2）run-sh" class="headerlink" title="2）run.sh"></a>2）run.sh</h2><p>启动被测服务，以及AFLNet发包测试，一般没什么问题</p>
<h2 id="3）cov-sh"><a href="#3）cov-sh" class="headerlink" title="3）cov_.sh"></a>3）cov_.sh</h2><p>使用AFLNet的重放来获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#terminate running server(s)</span><br><span class="line">pkill fftp</span><br><span class="line">ftpclean</span><br><span class="line">$replayer $f FTP $pno 1 &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</span><br><span class="line">timeout -k 0 -s SIGUSR1 3s .&#x2F;fftp fftp.conf $pno &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>pkill主要是防止启动服务前有端口占用等情况</p>
]]></content>
      <categories>
        <category>模糊测试</category>
      </categories>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>docker的使用</title>
    <url>/2024/10/16/docker%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t 镜像名 .</span><br></pre></td></tr></table></figure>

<h2 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<h2 id="删除none镜像（多次构建时出现）"><a href="#删除none镜像（多次构建时出现）" class="headerlink" title="删除none镜像（多次构建时出现）"></a>删除none镜像（多次构建时出现）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure>

<h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p>-a 可以看见没在运行的容器</p>
<h2 id="从镜像创建容器"><a href="#从镜像创建容器" class="headerlink" title="从镜像创建容器"></a>从镜像创建容器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it 镜像名 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<h2 id="启动-停止已有容器"><a href="#启动-停止已有容器" class="headerlink" title="启动/停止已有容器"></a>启动/停止已有容器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start&#x2F;stop 容器ID</span><br></pre></td></tr></table></figure>

<h2 id="进入已有容器"><a href="#进入已有容器" class="headerlink" title="进入已有容器"></a>进入已有容器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器ID &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<h2 id="删除镜像-容器"><a href="#删除镜像-容器" class="headerlink" title="删除镜像/容器"></a>删除镜像/容器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm 容器ID</span><br><span class="line">docker rmi 镜像名</span><br></pre></td></tr></table></figure>

<h2 id="复制本地文件到Dockfile"><a href="#复制本地文件到Dockfile" class="headerlink" title="复制本地文件到Dockfile"></a>复制本地文件到Dockfile</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 复制本地文件到镜像中</span><br><span class="line">COPY 本地路径 镜像路径</span><br><span class="line"></span><br><span class="line">复制容器文件到主机</span><br><span class="line">docker cp &lt;container_id&gt;:&lt;container_path&gt; &lt;host_path&gt;</span><br></pre></td></tr></table></figure>

<p>注意，路径好像不可以用绝对路径，必须与dockfile在同一目录。。。</p>
<h1 id="运行容器权限不足"><a href="#运行容器权限不足" class="headerlink" title="运行容器权限不足"></a>运行容器权限不足</h1><p>以root身份启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>COPY命令复制的文件在主机就没有权限，复制过去也没有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN chmod +x</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>协议插桩遇到的问题</title>
    <url>/2024/10/10/%E5%8D%8F%E8%AE%AE%E6%8F%92%E6%A1%A9%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="插桩"><a href="#插桩" class="headerlink" title="插桩"></a>插桩</h1><h2 id="1、编译器背景"><a href="#1、编译器背景" class="headerlink" title="1、编译器背景"></a>1、编译器背景</h2><p>编译器主要三大块：<strong>前端（frontEnd），优化器（Optimizer）和后端（backEnd）。</strong></p>
<p>源码翻译为中间表示，中间表示翻译为特定机器码</p>
<p><strong>GCC（GNU Compiler Collection）</strong> 是一个工具集合，包含的预处理器为<code>cpp</code>，还会调用汇编器<code>as</code>、连接器<code>ld</code>。</p>
<p>GCC 也将三段式做的比较好，并且实现了很多前端，支持了很多语言。但是致命缺陷是，他们是一个完整的可执行文件，没有给其它语言的开发者提供代码重用的接口。即使 GCC 是开源的，但是源代码重用的难度也比较大。<strong>也就是说GCC太庞大了，耦合度太高！！</strong></p>
<p><strong>LLVM （Low Level Virtual Machine）</strong>，顾名思义是一种中间表示，类似Java虚拟机，降低耦合度，解决重用问题。</p>
<p><strong>clang + llvm  ≈  GCC</strong> ，其实llvm+gcc/clang/其他，也是可以的。上述的GCC（RTL）与llvm（IR）的中间表达是不一样的。</p>
<h2 id="2、SanitizerCoverage插桩"><a href="#2、SanitizerCoverage插桩" class="headerlink" title="2、SanitizerCoverage插桩"></a>2、SanitizerCoverage插桩</h2><h3 id="插桩编译"><a href="#插桩编译" class="headerlink" title="插桩编译"></a>插桩编译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -fsanitize&#x3D;address -fsanitize-coverage&#x3D;trace-pc-guard -o test test.c</span><br></pre></td></tr></table></figure>

<p>-fsanitize-coverage=trace-pc-guard：对边进行插桩。（默认：edge）<br>-fsanitize-coverage=func,trace-pc-guard：对每个函数插桩。<br>-fsanitize-coverage=bb,no-prune,trace-pc-guard：对基本块插桩。</p>
<p>或者直接在makefile文件里加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CC &#x3D; clang</span><br><span class="line">CFLAGS &#x3D; -fsanitize&#x3D;address -fsanitize-coverage&#x3D;trace-pc-guard -g</span><br></pre></td></tr></table></figure>



<p>或者make命令后加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make CC&#x3D;&quot;clang -O2 -fno-omit-frame-pointer -g -fsanitize&#x3D;address -fsanitize-coverage&#x3D;trace-pc-guard,trace-cmp,trace-gep,trace-div&quot;</span><br></pre></td></tr></table></figure>

<h3 id="执行程序获取覆盖率数据文件。"><a href="#执行程序获取覆盖率数据文件。" class="headerlink" title="执行程序获取覆盖率数据文件。"></a>执行程序获取覆盖率数据文件。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ASAN_OPTIONS&#x3D;coverage&#x3D;1 .&#x2F;test</span><br></pre></td></tr></table></figure>

<h3 id="sancov文件是-AddressSanitizer生成的覆盖率文件，这些文件包含了程序在运行时覆盖的代码部分的信息。将该文件转换为覆盖率信息。"><a href="#sancov文件是-AddressSanitizer生成的覆盖率文件，这些文件包含了程序在运行时覆盖的代码部分的信息。将该文件转换为覆盖率信息。" class="headerlink" title=".sancov文件是 AddressSanitizer生成的覆盖率文件，这些文件包含了程序在运行时覆盖的代码部分的信息。将该文件转换为覆盖率信息。"></a>.sancov文件是 AddressSanitizer生成的覆盖率文件，这些文件包含了程序在运行时覆盖的代码部分的信息。将该文件转换为覆盖率信息。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sancov -symbolize *.sancov .&#x2F;test &gt; test.symcov</span><br></pre></td></tr></table></figure>

<h3 id="查看覆盖率信息。"><a href="#查看覆盖率信息。" class="headerlink" title="查看覆盖率信息。"></a>查看覆盖率信息。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat test.symcov</span><br></pre></td></tr></table></figure>

<h3 id="打印覆盖的函数："><a href="#打印覆盖的函数：" class="headerlink" title="打印覆盖的函数："></a>打印覆盖的函数：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sancov -covered-functions *.sancov .&#x2F;test</span><br></pre></td></tr></table></figure>

<h2 id="3、Code-Coverage插桩"><a href="#3、Code-Coverage插桩" class="headerlink" title="3、Code Coverage插桩"></a>3、Code Coverage插桩</h2><h3 id="插桩编译-1"><a href="#插桩编译-1" class="headerlink" title="插桩编译"></a>插桩编译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -fprofile-instr-generate -fcoverage-mapping test.c -o test</span><br></pre></td></tr></table></figure>

<p>或者直接在makefile文件里加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CC &#x3D; clang</span><br><span class="line">CFLAGS &#x3D; -fprofile-instr-generate -fcoverage-mapping -g</span><br></pre></td></tr></table></figure>

<p>或者make命令后加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make CC&#x3D;&quot;clang -O2 -fno-omit-frame-pointer -g -fprofile-instr-generate -fcoverage-mapping&quot;</span><br></pre></td></tr></table></figure>

<h3 id="执行程序获取覆盖率数据文件。-1"><a href="#执行程序获取覆盖率数据文件。-1" class="headerlink" title="执行程序获取覆盖率数据文件。"></a>执行程序获取覆盖率数据文件。</h3><pre><code>LLVM_PROFILE_FILE=&quot;test.profraw&quot; ./test</code></pre>
<h3 id="合并生成的覆盖率数据文件。"><a href="#合并生成的覆盖率数据文件。" class="headerlink" title="合并生成的覆盖率数据文件。"></a>合并生成的覆盖率数据文件。</h3><pre><code>llvm-profdata merge -sparse test.profraw test2.profraw ... -o test.profdata</code></pre>
<h3 id="查看覆盖率信息"><a href="#查看覆盖率信息" class="headerlink" title="查看覆盖率信息:"></a>查看覆盖率信息:</h3><pre><code>llvm-cov show ./test -instr-profile=test.profdata</code></pre>
<h3 id="查看覆盖率报告："><a href="#查看覆盖率报告：" class="headerlink" title="查看覆盖率报告："></a>查看覆盖率报告：</h3><pre><code>llvm-cov report ./test -instr-profile=test.profdata</code></pre>
<h2 id="4、gcov-插桩"><a href="#4、gcov-插桩" class="headerlink" title="4、gcov 插桩"></a>4、gcov 插桩</h2><h3 id="插桩编译-2"><a href="#插桩编译-2" class="headerlink" title="插桩编译"></a>插桩编译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc test.c -c -fprofile-arcs -ftest-coverage -o test.o</span><br></pre></td></tr></table></figure>

<p>或者直接在makefile文件里加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CC&#x3D;gcc</span><br><span class="line">CFLAGS+&#x3D; -fprofile-arcs -ftest-coverage</span><br></pre></td></tr></table></figure>

<p>或者make命令后加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make CC&#x3D;&quot;gcc -g -fprofile-arcs -ftest-coverage&quot;</span><br><span class="line"> make CFLAGS&#x3D;&quot;-fprofile-arcs -ftest-coverage&quot; CPPFLAGS&#x3D;&quot;-fprofile-arcs -ftest-coverage&quot; CXXFLAGS&#x3D;&quot;-fprofile-arcs -ftest-coverage&quot; LDFLAGS&#x3D;&quot;-fprofile-arcs -ftest-coverage&quot; clean all</span><br></pre></td></tr></table></figure>

<h3 id="运行程序后，会生成一个-gcda-文件，里面包含代码执行次数等数据。"><a href="#运行程序后，会生成一个-gcda-文件，里面包含代码执行次数等数据。" class="headerlink" title="运行程序后，会生成一个 *.gcda 文件，里面包含代码执行次数等数据。"></a>运行程序后，会生成一个 *.gcda 文件，里面包含代码执行次数等数据。</h3><p>注意：遇到*.gcda不能生成的情况，大概率是因为程序没有正常结束，比如用ctrl+c</p>
<p>源码中添加信号处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void sig_handler(int signo)&#123;</span><br><span class="line">  if (signo &#x3D;&#x3D; SIGUSR1)</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    signal(SIGUSR1, sig_handler);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timeout -k 0 -s SIGUSR1 3s .&#x2F;test &#x2F;&#x2F;3s控制运行时长</span><br></pre></td></tr></table></figure>

<h3 id="输出覆盖率报告"><a href="#输出覆盖率报告" class="headerlink" title="输出覆盖率报告"></a>输出覆盖率报告</h3><pre><code># 生成覆盖率文本报告
lcov -c -d . -o test.info --rc lcov_branch_coverage=1 
# 生成覆盖率网页报告
genhtml --branch-coverage -o result test.info </code></pre>
]]></content>
      <categories>
        <category>模糊测试</category>
      </categories>
      <tags>
        <tag>插桩</tag>
      </tags>
  </entry>
  <entry>
    <title>内网穿透</title>
    <url>/2024/09/30/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h1><p>首先，IP有限，有了局域网，不同局域网内的IP可以相同。访问公网的时候：</p>
<p>局域网内的，</p>
<p>IP+端口</p>
<p>映射到</p>
<p>网关的，</p>
<p>公网IP+端口</p>
<p>相当于，用不同的端口号来区分了内部的IP，并且会在内网访问外网的过程中，在路由表中记下来映射关系。</p>
<p>所以，局域网=&gt;公网，表中有记录，返回的数据也能正确交给局域网中的电脑。</p>
<p>但是，公网=&gt;内网，表中没记录，无法知道内网中的IP在哪里。</p>
<h1 id="2、内网穿透的原理"><a href="#2、内网穿透的原理" class="headerlink" title="2、内网穿透的原理"></a>2、内网穿透的原理</h1><p>1.理论上，在路由表中添加映射关系就可以，但实际中肯定不是老是人为去改路由器</p>
<p>2.工具，花生壳、Cpolar等，电脑上运行一个客户端，与他们的服务端通信，这个客户端再与内网中的电脑应用进行端口映射。QQ、微信也一样，都要有服务端才能做到不同局域网中的A能联系到B。</p>
<p><img src="https://pica.zhimg.com/80/v2-fac34de448ae1dd5c7555e7a496be7bc_1440w.webp" alt="v2-fac34de448ae1dd5c7555e7a496be7bc_1440w"></p>
<h1 id="3、连接局域网的服务器"><a href="#3、连接局域网的服务器" class="headerlink" title="3、连接局域网的服务器"></a>3、连接局域网的服务器</h1><p>使用工具映射SSH的22端口，得到公网地址与端口号</p>
<p>可以使用vscode等再连接这个公网地址和端口号即可。</p>
<h1 id="4、遇到的小问题"><a href="#4、遇到的小问题" class="headerlink" title="4、遇到的小问题"></a>4、遇到的小问题</h1><p>使用Cpolar映射基于Django的web服务时，需要设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG &#x3D; True</span><br><span class="line"></span><br><span class="line">ALLOWED_HOSTS &#x3D; [&#39;localhost&#39;, &#39;127.0.0.1&#39;, &#39;[::1]&#39;, &#39;3e287042.r7.cpolar.cn&#39;]</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>使用Django遇到的问题</title>
    <url>/2024/09/22/%E4%BD%BF%E7%94%A8Django%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Django的使用"><a href="#Django的使用" class="headerlink" title="Django的使用"></a>Django的使用</h1><h2 id="一、基本配置"><a href="#一、基本配置" class="headerlink" title="一、基本配置"></a>一、基本配置</h2><h3 id="数据库初始化"><a href="#数据库初始化" class="headerlink" title="数据库初始化"></a>数据库初始化</h3><p>model里定义数据库模型，需要先初始化数据库：<br>    python manage.py makemigrations<br>    python manage.py migrate</p>
<p>然后在admin.py中进行注册</p>
<h3 id="修改菜单名"><a href="#修改菜单名" class="headerlink" title="修改菜单名"></a>修改菜单名</h3><h4 id="在apps-py中修改项目名"><a href="#在apps-py中修改项目名" class="headerlink" title="在apps.py中修改项目名"></a>在apps.py中修改项目名</h4><pre><code>from django.apps import AppConfigclass 

App01Config(AppConfig):    
    name = &#39;XXX&#39;
    verbose_name = &#39;XXX管理系统&#39;</code></pre>
<h4 id="在models-py中表模型中添加Meta元标签："><a href="#在models-py中表模型中添加Meta元标签：" class="headerlink" title="在models.py中表模型中添加Meta元标签："></a>在models.py中表模型中添加Meta元标签：</h4><pre><code>class Meta:        
    verbose_name = &#39;XXX&#39;
    verbose_name_plural = verbose_name</code></pre>
<h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@receiver(op, sender&#x3D;Model)</span><br><span class="line">def function():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">op &#x3D; pre_save&#x2F;post_save&#x2F;pre_delete&#x2F;post_delete</span><br></pre></td></tr></table></figure>

<p>实例Model被增删前后，触发执行函数function，比如从A表删除一条记录，B表中也要随之删除。</p>
<h2 id="二、SimpleUI"><a href="#二、SimpleUI" class="headerlink" title="二、SimpleUI"></a>二、SimpleUI</h2><h3 id="自定义菜单"><a href="#自定义菜单" class="headerlink" title="自定义菜单"></a>自定义菜单</h3><pre><code>SIMPLEUI_CONFIG = &#123;
    # 是否使用系统默认菜单，自定义菜单时建议关闭。
    &#39;system_keep&#39;: False,

    # 用于菜单排序和过滤, 不填此字段为默认排序和全部显示。空列表[] 为全部不显示.
    &#39;menu_display&#39;: [&#39;发票管理&#39;,&#39;权限管理&#39;],

    # 设置是否开启动态菜单, 默认为False. 如果开启, 则会在每次用户登陆时刷新展示菜单内容
    &#39;dynamic&#39;: False,
    &#39;menus&#39;: [
        &#123;
            &#39;app&#39;: &#39;manager&#39;,
            &#39;name&#39;: &#39;发票管理&#39;,
            &#39;icon&#39;: &#39;fa fa-user-md&#39;,
            &#39;models&#39;: [
                &#123;
                    &#39;name&#39;: &#39;发票列表&#39;,
                    # app名/model里定义的数据模型/。
                    &#39;url&#39;: &#39;manager/invoice/&#39;,
                    &#39;icon&#39;: &#39;fa fa-user&#39;
                &#125;,
            ]
        &#125;,

            &#123;
            &#39;app&#39;: &#39;auth&#39;,
            &#39;name&#39;: &#39;权限管理&#39;,
            &#39;icon&#39;: &#39;fas fa-user-shield&#39;,
            &#39;models&#39;: [
                &#123;
                    &#39;name&#39;: &#39;管理用户列表&#39;,
                    &#39;icon&#39;: &#39;fa fa-user-secret&#39;,
                    &#39;url&#39;: &#39;auth/user/&#39;
                &#125;,
                &#123;
                    &#39;name&#39;: &#39;用户组&#39;,
                    &#39;icon&#39;: &#39;fa fa-th-list&#39;,
                    &#39;url&#39;: &#39;auth/group/&#39;
                &#125;
            ]
        &#125;,
    ]
&#125;</code></pre>
<p>注意踩坑，url里要用小写。。。。。。</p>
<h3 id="Tip1"><a href="#Tip1" class="headerlink" title="Tip1"></a>Tip1</h3><p>自定义菜单里的url写全(IP那种)，映射到view中的请求即可注册到菜单中，</p>
<p>就不需要全都要用admin的model去映射。</p>
<p>不过扩展的新应用app需要在INSTALLED_APPS这里面注册</p>
<h3 id="Tip2"><a href="#Tip2" class="headerlink" title="Tip2"></a>Tip2</h3><h2 id="三、QuerySet"><a href="#三、QuerySet" class="headerlink" title="三、QuerySet"></a>三、QuerySet</h2><h3 id="1、all"><a href="#1、all" class="headerlink" title="1、all()"></a>1、all()</h3><pre><code>tt = Model.objects.all()</code></pre>
<p>返回所有的Model的实例及其字段值，相当于SQL的：<br>    SELECT * FROM Model</p>
<h3 id="2、values"><a href="#2、values" class="headerlink" title="2、values()"></a>2、values()</h3><pre><code>tt = Model.objects.values(&#39;id&#39;, &#39;username&#39;)  

tt = Model.objects.values_list(&#39;id&#39;, &#39;username&#39;)</code></pre>
<p>返回所有的Model的实例及其指定字段值，相当于SQL的：<br>    SELECT id, username FROM Model</p>
<p>当只需要获取一个属性的值时，可以通过制定flat=True来获得：<br>    tt = Model.objects.values_list(‘username’, flat=True)</p>
<p>相当于SQL的：<br>    SELECT username FROM Model</p>
<h3 id="3、filter"><a href="#3、filter" class="headerlink" title="3、filter()"></a>3、filter()</h3><pre><code>tt = Model.objects.filter(username = &quot;xx&quot;)</code></pre>
<p>相当于SQL的：<br>    SELECT * FROM Model where username = “xx”</p>
<h3 id="4、get"><a href="#4、get" class="headerlink" title="4、get()"></a>4、get()</h3><pre><code>obj= Model .objects.get(username =‘xx’)</code></pre>
<p>上述所有函数除了get方法，返回的结果全是QuerySet， 可用for循环取出来即可</p>
<p><a href="https://www.cnblogs.com/Lin-Yi/p/7515982.html">django的models模块查询方法 - 稀里糊涂林老冷 - 博客园</a></p>
]]></content>
  </entry>
  <entry>
    <title>偶遇小问题</title>
    <url>/2024/09/06/%E5%81%B6%E9%81%87%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h6 id="1-boofuzz"><a href="#1-boofuzz" class="headerlink" title="1.boofuzz"></a>1.boofuzz</h6><p>安装boofuzz的时候boo命令却用不了？</p>
<p>需要用sudo权限安装才对</p>
<h6 id="2-SGfuzz"><a href="#2-SGfuzz" class="headerlink" title="2.SGfuzz"></a>2.SGfuzz</h6><p>构建socker容器时，如需复制文件到容器，需要在要复制的那个文件所在目录进行构建（即同级目录）</p>
<h6 id="3-HTML之convas"><a href="#3-HTML之convas" class="headerlink" title="3.HTML之convas"></a>3.HTML之convas</h6><p>多个convas覆盖的问题</p>
<p>需要在同一个div里弄多个convas才叠加显示</p>
]]></content>
  </entry>
  <entry>
    <title>华为服务器</title>
    <url>/2024/09/06/%E5%8D%8E%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="ssh连接服务器"><a href="#ssh连接服务器" class="headerlink" title="ssh连接服务器"></a>ssh连接服务器</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh username@hostname</span><br></pre></td></tr></table></figure>

<p>其中，<code>username</code> 是您的用户名，<code>hostname</code> 是目标服务器的主机名或IP地址，然后输入密码。</p>
<h1 id="SCP命令传输文件到目标服务器"><a href="#SCP命令传输文件到目标服务器" class="headerlink" title="SCP命令传输文件到目标服务器"></a>SCP命令传输文件到目标服务器</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp &#x2F;path&#x2F;to&#x2F;local&#x2F;file username@hostname:&#x2F;path&#x2F;to&#x2F;remote&#x2F;directory</span><br></pre></td></tr></table></figure>

<p>其中，<code>/path/to/local/file</code> 是本地文件的路径，<code>username</code> 是您的用户名，<code>hostname</code> 是目标服务器的主机名或IP地址，<code>/path/to/remote/directory</code> 是目标服务器上已创建的目录路径。</p>
<h1 id="查看nginx实际调用的配置文件"><a href="#查看nginx实际调用的配置文件" class="headerlink" title="查看nginx实际调用的配置文件"></a>查看nginx实际调用的配置文件</h1><h2 id="1-查看nginx路径"><a href="#1-查看nginx路径" class="headerlink" title="1.查看nginx路径"></a>1.查看nginx路径</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@hcss-ecs-d6be:&#x2F;etc# ps aux|grep nginx</span><br><span class="line">root      538024  0.0  0.0  15672  1004 ?        Ss   Aug10   0:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">nginx     538025  0.0  1.4  37932 25888 ?        S    Aug10   0:00 nginx: worker process</span><br><span class="line">nginx     538026  0.0  1.4  37924 25864 ?        S    Aug10   0:05 nginx: worker process</span><br><span class="line">root      927076  0.0  0.1   6476  2252 pts&#x2F;0    S+   14:28   0:00 grep --color&#x3D;auto nginx</span><br></pre></td></tr></table></figure>

<p>nginx的路径为：/usr/sbin/nginx</p>
<h2 id="2-查看nginx配置文件路径"><a href="#2-查看nginx配置文件路径" class="headerlink" title="2.查看nginx配置文件路径"></a>2.查看nginx配置文件路径</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@hcss-ecs-d6be:&#x2F;etc# &#x2F;usr&#x2F;sbin&#x2F;nginx -t</span><br><span class="line">nginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful</span><br></pre></td></tr></table></figure>

<p>nginx的配置文件路径为： /etc/nginx/nginx.conf</p>
<p>网页访问路径为：/usr/share/nginx/html</p>
<h2 id="ps-命令"><a href="#ps-命令" class="headerlink" title="ps 命令"></a>ps 命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@hcss-ecs-d6be:&#x2F;etc# ps aux|grep nginx</span><br><span class="line">root      538024  0.0  0.0  15672  1004 ?        Ss   Aug10   0:00 nginx: master process &#x2F;usr&#x2F;sbin&#x2F;nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">nginx     538025  0.0  1.4  37932 25888 ?        S    Aug10   0:00 nginx: worker process</span><br><span class="line">nginx     538026  0.0  1.4  37924 25864 ?        S    Aug10   0:05 nginx: worker process</span><br><span class="line">root      927128  0.0  0.1   6476  2428 pts&#x2F;0    S+   14:33   0:00 grep --color&#x3D;auto nginx</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>使用hexo遇到的问题</title>
    <url>/2022/12/01/%E4%BD%BF%E7%94%A8hexo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="配置文件优先级"><a href="#配置文件优先级" class="headerlink" title="配置文件优先级"></a>配置文件优先级</h1><p>Hexo 配置文件<code>_config.yml</code>中的 <code>theme_config</code> 配置项的优先级最高，其次是 <code>_config.[theme].yml</code> 文件，最后是位于主题目录下的 <code>_config.yml</code> 文件。</p>
<p>打开<strong>主题配置文件</strong>，查找custom_file_path去掉相应注释配置</p>
<p>有的时候主题下的配置文件修改无效就是因为外面还有个_config.[theme].yml`配置文件。</p>
<h1 id="Hexo-下的-config-yml-配置主题"><a href="#Hexo-下的-config-yml-配置主题" class="headerlink" title="Hexo 下的_config.yml 配置主题"></a>Hexo 下的_config.yml 配置主题</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>



<h1 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h1><p>乱码必然是编码问题了，<font color="red" ><strong>千万不要用记事本去打开hexo的那些配置文件</strong>，</font>记事本的编码太坑了。一般改成UTF-8即可。</p>
<p>1.可用Sublime Text 3等工具修改编码</p>
<p>2.设置language时，网上会说用<strong>zh-Hans</strong>就行了。。。这得看language文件夹里的是<strong>zh-CN还是zh-Hans</strong></p>
<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">

<h1 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h1><p>这是老生常谈的问题了，低版本的hexo和高版本的hexo有个别的差别。</p>
<p>1.hexo s后，满怀激动的打开浏览器，艹，全是json串。</p>
<p><img src="https://img-blog.csdnimg.cn/20201120100408290.JPG#pic_center" alt="在这里插入图片描述"></p>
<p>2.某些配置文件变了或位置不一样了，这个注意一下就行。</p>
<h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><h2 id="1、域名必须用自己GitHub的那个名。"><a href="#1、域名必须用自己GitHub的那个名。" class="headerlink" title="1、域名必须用自己GitHub的那个名。"></a>1、域名必须用自己GitHub的那个名。</h2><p><img src="https://img-blog.csdnimg.cn/20201121150314926.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2、main与master要统一，代码到底放哪个分支，setting里面往下拖。"><a href="#2、main与master要统一，代码到底放哪个分支，setting里面往下拖。" class="headerlink" title="2、main与master要统一，代码到底放哪个分支，setting里面往下拖。"></a>2、main与master要统一，代码到底放哪个分支，setting里面往下拖。<img src="https://img-blog.csdnimg.cn/20201121150507263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></h2><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">

<h2 id="3、error-src-refspec-xxx-does-not-match-any-error-failed-to-push-some-refs-to"><a href="#3、error-src-refspec-xxx-does-not-match-any-error-failed-to-push-some-refs-to" class="headerlink" title="3、error: src refspec xxx does not match any / error: failed to push some refs to"></a>3、error: src refspec xxx does not match any / error: failed to push some refs to</h2><p>出现这个错误应该是因为.deploy_git文件被动过，我就是因为换电脑粘贴过去的。。。</p>
<p>解决：</p>
<p>a、删除.deploy_git文件</p>
<p>b、执行git init</p>
<p>c、执行git add .</p>
<p>d、执行git commit -m “first commit” </p>
<p>输入用户名和邮箱之后，再hexo d，皆大欢喜，终于可以了！！</p>
<h1 id="next主题装饰"><a href="#next主题装饰" class="headerlink" title="next主题装饰"></a>next主题装饰</h1><p><font color=#999AAA >上面两个最烦人的问题解决后，基本看到效果了</font>。剩下的就是装修好看一点的问题了，我就列举一些：</p>
<p>1.什么分类、标签、头像等基本的搞一搞</p>
<p>2.可以添加一个网易云音乐</p>
<p>3.tagcloud</p>
<p>4.鼠标点击有爱心特效</p>
<p>5.增加搜索功能</p>
<p>6.可以用LeanCloud做阅读统计和评论</p>
<p>7.live2d养一只宠物</p>
<p>8.文章圆角与透明度等等</p>
<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">

<h1 id="live2d添加卡通角色"><a href="#live2d添加卡通角色" class="headerlink" title="live2d添加卡通角色"></a>live2d添加卡通角色</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save live2d-widget-model-shizuku</span><br></pre></td></tr></table></figure>

<h1 id="网易云音乐外链"><a href="#网易云音乐外链" class="headerlink" title="网易云音乐外链"></a>网易云音乐外链</h1><p><strong>第一种：将外链放到…`/themes/hexo-theme-next/layout/_macro/sidebar.swig文件下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;280 height&#x3D;52 src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;0&amp;id&#x3D;3099434842&amp;auto&#x3D;0&amp;height&#x3D;32&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>第二种：直接去主题的layout文件里去添加html语句，显然不易修改，但是一直都在</strong></p>
<h2 id="更个性化–音乐播放悬浮"><a href="#更个性化–音乐播放悬浮" class="headerlink" title="更个性化–音乐播放悬浮"></a>更个性化–音乐播放悬浮</h2><p>其实就是_layout文件里先写个div框，通过js控制播放与悬浮</p>
<h1 id="文章末尾添加线或标记"><a href="#文章末尾添加线或标记" class="headerlink" title="文章末尾添加线或标记"></a>文章末尾添加线或标记</h1><p><strong>第一种方式（推荐），通过custom_file_path去配置postBodyEnd</strong></p>
<p><strong>第二种方式，直接去主题的layout文件里去添加</strong></p>
<h1 id="去除首页文章间隔与短横线"><a href="#去除首页文章间隔与短横线" class="headerlink" title="去除首页文章间隔与短横线"></a>去除首页文章间隔与短横线</h1><p>网上说的是去主题文件下css里的一个post_eof文件修改，但是我修改之后没效果。</p>
<p>解决：</p>
<p>凡是要修改css的地方都可以在custom_file_path这里配置的style文件里修改就行，更简单的方法就是直接f12看某个地方的id或class，然后sty文件里直接写css修改就行。</p>
<p>不仅仅可以去除短横线了，文章样式都可以改为自己修饰的！</p>
<h1 id="添加背景图片"><a href="#添加背景图片" class="headerlink" title="添加背景图片"></a>添加背景图片</h1><p>把想设置的背景放入<code>./themes/next/source/images</code>中，命名为<code>bg.jpg</code>。在根目录<code>source</code>文件夹下添加style文件<code>source/_data/styles.styl</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;网站背景图片设置</span><br><span class="line">body &#123;</span><br><span class="line">    background:url(&#x2F;images&#x2F;bg.jpg);</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    &#x2F;&#x2F;不重复</span><br><span class="line">        background-repeat:no-repeat;</span><br><span class="line">    background-size:cover;</span><br><span class="line">    &#x2F;&#x2F;填充</span><br><span class="line">        background-position:50% 50%;</span><br><span class="line">    &#x2F;&#x2F;缩放设置，百分比越小则图片被放大</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="博客内容等透明度"><a href="#博客内容等透明度" class="headerlink" title="博客内容等透明度"></a>博客内容等透明度</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;文章的透明度</span><br><span class="line">.content-wrap &#123;</span><br><span class="line">    opacity:0.8</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;侧边栏的透明度</span><br><span class="line">.sidebar &#123;</span><br><span class="line">    opacity:0.8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="valine-评论背景调整"><a href="#valine-评论背景调整" class="headerlink" title="valine 评论背景调整"></a>valine 评论背景调整</h1><p>…\themes\next\layout_third-party\comments\valine.swig里添加修饰</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.comments &#123;</span><br><span class="line">  opacity: 1; </span><br><span class="line">  display: block;</span><br><span class="line">  background-color: rgba(255, 255, 255, 0.9);</span><br><span class="line">&#125;</span><br><span class="line"> .v &#123;</span><br><span class="line">  opacity: 1; </span><br><span class="line">  display: block;</span><br><span class="line">  background-color: rgba(255, 255, 255, 0.9);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.vpower&#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line"> .txt-right &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h1 id="busuanzi不显示统计次数"><a href="#busuanzi不显示统计次数" class="headerlink" title="busuanzi不显示统计次数"></a>busuanzi不显示统计次数</h1><p>搞半天只是广告过滤插件给拦截了。。。可以看控制台（control）是否报错：net::ERR_BLOCKED_BY_CLIENT。</p>
<p>也可以f12看源码里有没有数字，是否是因为隐藏。</p>
<h1 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h1><p>1.运行自己写的css的时候可能会报错expected “indent”, got “outdent”？</p>
<p>解决：</p>
<p>找个网站格式化css，比如<a href="https://tool.ip138.com/css/">https://tool.ip138.com/css/</a> ，很容易就能看到css哪里有问题。</p>
<p>2.js加载中文可能乱码？</p>
<p>解决：</p>
<p>乱码问题大概率就是编码不一致导致的了，把中文转utf-8就能解决，比如<a href="https://www.sojson.com/utf8.html">https://www.sojson.com/utf8.html</a></p>
<h4 id="其他待补充…"><a href="#其他待补充…" class="headerlink" title="其他待补充…"></a>其他待补充…</h4>]]></content>
  </entry>
  <entry>
    <title>redis一些知识</title>
    <url>/2022/11/28/redis%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="Redis有哪些数据结构"><a href="#Redis有哪些数据结构" class="headerlink" title="Redis有哪些数据结构"></a>Redis有哪些数据结构</h1><p><strong>String</strong>、<strong>Hash</strong>、<strong>List</strong>、<strong>Set</strong>、<strong>SortedSet</strong>。</p>
<p>如果你是Redis中高级用户，在面试中突出你和其他候选人的不同，还需要加上下面几种数据结构<strong>HyperLogLog、Geo、Pub/Sub</strong>。</p>
<h1 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h1><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，<strong>Redis</strong>可能会出现短暂的卡顿现象。严重的话会出现缓存雪崩，我们一般需要在时间上加一个随机值，使得过期时间分散一些。</p>
<p>电商首页经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好在失效的时间点大量用户涌入，就有可能造成缓存雪崩</p>
<h3 id="你使用过Redis分布式锁么，它是什么回事？"><a href="#你使用过Redis分布式锁么，它是什么回事？" class="headerlink" title="你使用过Redis分布式锁么，它是什么回事？"></a>你使用过Redis分布式锁么，它是什么回事？</h3><p>先拿<strong>setnx</strong>来争抢锁，抢到之后，再用<strong>expire</strong>给锁加一个过期时间防止锁忘记了释放。如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？ set指令有非常复杂的参数，这个是可以同时把<strong>setnx</strong>和<strong>expire</strong>合成一条指令来用的！</p>
<h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h3><p>使用<strong>keys</strong>指令可以扫出指定模式的key列表。</p>
<h3 id="如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？"><a href="#如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？" class="headerlink" title="如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？"></a>如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</h3><p>Redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用<strong>scan</strong>指令，<strong>scan</strong>指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<p><strong>不过，增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 。</strong></p>
<h3 id="使用Redis做异步队列？"><a href="#使用Redis做异步队列？" class="headerlink" title="使用Redis做异步队列？"></a>使用Redis做异步队列？</h3><p>一般使用list结构作为队列，<strong>rpush</strong>生产消息，<strong>lpop</strong>消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p>
<h3 id="可不可以不用sleep呢？"><a href="#可不可以不用sleep呢？" class="headerlink" title="可不可以不用sleep呢？"></a>可不可以不用sleep呢？</h3><p>list还有个指令叫<strong>blpop</strong>，在没有消息的时候，它会阻塞住直到消息到来。</p>
<h3 id="能不能生产一次消费多次呢？"><a href="#能不能生产一次消费多次呢？" class="headerlink" title="能不能生产一次消费多次呢？"></a>能不能生产一次消费多次呢？</h3><p>使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列。</p>
<h3 id="pub-sub有什么缺点？"><a href="#pub-sub有什么缺点？" class="headerlink" title="pub/sub有什么缺点？"></a>pub/sub有什么缺点？</h3><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如<strong>RocketMQ</strong>等。</p>
<h1 id="Redis-避免缓存穿透的利器之BloomFilter"><a href="#Redis-避免缓存穿透的利器之BloomFilter" class="headerlink" title="Redis-避免缓存穿透的利器之BloomFilter"></a>Redis-避免缓存穿透的利器之BloomFilter</h1><h1 id="Bloom-Filter-原理"><a href="#Bloom-Filter-原理" class="headerlink" title="Bloom Filter 原理"></a>Bloom Filter 原理</h1><p>布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p>
<p>Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。</p>
<h1 id="Bloom-Filter的缺点"><a href="#Bloom-Filter的缺点" class="headerlink" title="Bloom Filter的缺点"></a>Bloom Filter的缺点</h1><p>bloom filter之所以能做到在时间和空间上的效率比较高，是因为牺牲了判断的准确率、删除的便利性</p>
<ul>
<li>存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果bloom filter中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。</li>
<li>删除困难。一个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素的判断。可以采用<a href="https://link.juejin.cn/?target=http://wiki.corp.qunar.com/confluence/download/attachments/199003276/US9740797.pdf?version=1&modificationDate=1526538500000&api=v2">Counting Bloom Filter</a></li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会被打倒数据库上。</p>
<p>即这个数据根本不存在，如果黑客攻击时，启用很多个线程，一直对这个不存在的数据发送请求 ，那么请求就会一直被打到数据库上，很容易将数据库打崩。</p>
<p> 解决方案：</p>
<p>1.缓存空对象</p>
<p>2.布隆过滤器</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到db，属于常见的“热点”问题</p>
<p>解决方案：</p>
<p>1.预先设置热门数据，提前存入缓存</p>
<p>2.实时监控热门数据，调整key过期时长</p>
<p>3.二级缓存:对于热点数据进行二级缓存，并对于不同级别的缓存设定不同的失效时间。</p>
<p>4.设置分布式锁</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>大量的应用请求无法在Redis缓存中进行处理，紧接着应用将大量请求发送到数据库层，导致数据库层的压力激增。击穿与雪崩的区别即在于击穿是对于特定的热点数据来说，而雪崩是全部数据。</p>
<p><strong>原因一：缓存中有大量Key同时过期，导致大量请求无法得到处理，大量数据需要回源数据库</strong></p>
<p>方案一 差异化设置过期时间，比如，在初始化缓存的时候，给这些数据的过期时间增加一个较小的随机数，这样一来不同数据的过期时间有所差别又差别不大，即避免了大量数据同时过期又能保证这些数据在相近的时间失效</p>
<p>方案二 服务降级<br>允许核心业务访问数据库，非核心业务直接返回预定义的信息</p>
<p>方案三 不设置过期时间</p>
<p>**原因二：Redis实例发生故障宕机，无法处理请求，就会导致大量请求积压到数据库层 **</p>
<p>方案一 服务熔断<br>暂停业务应用对缓存服务的访问，从而降低对数据库的压力</p>
<p>方案二 请求限流<br>控制每秒进入应用程序的请求数，避免过多的请求被发到数据库</p>
<p>方案三 Redis构建高可靠集群<br>通过主从节点的方式构建Redis高可靠集群。可以保证在Redis主节点故障宕机时，从节点切换到主节点，继续提供服务，避免由于缓存实例宕机导致缓存雪崩。</p>
<h3 id="Redis是怎么持久化的？"><a href="#Redis是怎么持久化的？" class="headerlink" title="Redis是怎么持久化的？"></a>Redis是怎么持久化的？</h3><p>RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。</p>
<p><strong>这里很好理解，把RDB理解为一整个表全量的数据，AOF理解为每次操作的日志就好了，服务器重启的时候先把表的数据全部搞进去，但是他可能不完整，你再回放一下日志，数据不就完整了嘛。不过Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF/RDB文件城后，Redis启动成功； AOF/RDB文件存在错误时，Redis启动失败并打印错误信息</strong></p>
<h3 id="那如果突然机器掉电会怎样？"><a href="#那如果突然机器掉电会怎样？" class="headerlink" title="那如果突然机器掉电会怎样？"></a>那如果突然机器掉电会怎样？</h3><p>取决于AOF日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。</p>
<h3 id="Redis的同步机制？"><a href="#Redis的同步机制？" class="headerlink" title="Redis的同步机制？"></a>Redis的同步机制？</h3><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次<strong>bgsave</strong>，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。</p>
<h3 id="Redis集群，集群的高可用怎么保证，集群的原理是什么？"><a href="#Redis集群，集群的高可用怎么保证，集群的原理是什么？" class="headerlink" title="Redis集群，集群的高可用怎么保证，集群的原理是什么？"></a>Redis集群，集群的高可用怎么保证，集群的原理是什么？</h3><p><strong>Redis Sentinal</strong> 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</p>
<p><strong>Redis Cluster</strong> 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p>
]]></content>
  </entry>
  <entry>
    <title>2022面试</title>
    <url>/2022/11/28/2022%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h1 id="c-空类有哪些函数"><a href="#c-空类有哪些函数" class="headerlink" title="c++空类有哪些函数"></a>c++空类有哪些函数</h1><p><strong>构造、析构、拷贝构造、赋值、取址运算符</strong></p>
<h1 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h1><h1 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h1><h2 id="UDP实现可靠传输"><a href="#UDP实现可靠传输" class="headerlink" title="UDP实现可靠传输"></a>UDP实现可靠传输</h2><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h1 id="map与unordered-map"><a href="#map与unordered-map" class="headerlink" title="map与unordered_map"></a>map与unordered_map</h1><p><strong>抛出结论，在需要有序性或者对单次查询有时间要求的应用场景下，应使用map，其余情况应使用unordered_map。</strong></p>
<p>**数组、链表实现的有序，红黑树会排序，就不是原来的插入顺序 **</p>
<h1 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h1><h1 id="XML解析器"><a href="#XML解析器" class="headerlink" title="XML解析器"></a>XML解析器</h1>]]></content>
  </entry>
  <entry>
    <title>C++轻量级服务器</title>
    <url>/2022/11/28/C-%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="一-socket基础"><a href="#一-socket基础" class="headerlink" title="一. socket基础"></a>一. socket基础</h1><p>首先在服务器，我们需要建立一个socket套接字，对外提供一个网络通信接口，在Linux系统中这个套接字竟然仅仅是一个文件描述符，也就是一个<code>int</code>类型的值！</p>
<p>为了方便编码以及代码的可读性，可以封装一个错误处理函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errif</span><span class="params">(<span class="keyword">bool</span> condition, <span class="keyword">const</span> <span class="keyword">char</span> *errmsg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(condition)&#123;</span><br><span class="line">        perror(errmsg);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">errif(sockfd == <span class="number">-1</span>, <span class="string">&quot;socket create error&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数：IP地址类型，AF_INET表示使用IPv4，如果使用IPv6请使用AF_INET6。</li>
<li>第二个参数：数据传输方式，SOCK_STREAM表示流格式、面向连接，多用于TCP。SOCK_DGRAM表示数据报格式、无连接，多用于UDP。</li>
<li>第三个参数：协议，0表示根据前面的两个参数自动推导协议类型。设置为IPPROTO_TCP和IPPTOTO_UDP，分别表示TCP和UDP。</li>
</ul>
<p>对于客户端，服务器存在的唯一标识是一个IP地址和端口，这时候我们需要将这个套接字绑定到一个IP地址和端口上。首先创建一个sockaddr_in结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">serv_addr.sin_family = AF_INET;</span><br><span class="line">serv_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">serv_addr.sin_port = htons(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>

<p>然后将socket地址与文件描述符绑定：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">errif(bind(sockfd, (sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>, <span class="string">&quot;socket bind error&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>最后我们需要使用<code>listen</code>函数监听这个socket端口，这个函数的第二个参数是listen函数的最大监听队列长度，系统建议的最大值<code>SOMAXCONN</code>被定义为128。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">errif(listen(sockfd, SOMAXCONN) == <span class="number">-1</span>, <span class="string">&quot;socket listen error&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>要接受一个客户端连接，需要使用<code>accept</code>函数。对于每一个客户端，我们在接受连接时也需要保存客户端的socket地址信息，于是有以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> clnt_addr_len = <span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line"><span class="comment">//填充0初始化</span></span><br><span class="line">bzero(&amp;clnt_addr, <span class="keyword">sizeof</span>(clnt_addr));</span><br><span class="line"><span class="keyword">int</span> clnt_sockfd = accept(sockfd, (sockaddr*)&amp;clnt_addr, &amp;clnt_addr_len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;new client fd %d! IP: %s Port: %d\n&quot;</span>, clnt_sockfd, inet_ntoa(clnt_addr.sin_addr), ntohs(clnt_addr.sin_port));</span><br><span class="line">errif(clnt_sockfd == <span class="number">-1</span>, <span class="string">&quot;socket accept error&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>连接测试：</p>
<h2 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    errif(sockfd == <span class="number">-1</span>, <span class="string">&quot;socket create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">    errif(bind(sockfd, (sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>, <span class="string">&quot;socket bind error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    errif(listen(sockfd, SOMAXCONN) == <span class="number">-1</span>, <span class="string">&quot;socket listen error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_addr_len = <span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">    bzero(&amp;clnt_addr, <span class="keyword">sizeof</span>(clnt_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> clnt_sockfd = accept(sockfd, (sockaddr*)&amp;clnt_addr, &amp;clnt_addr_len);</span><br><span class="line">    errif(clnt_sockfd == <span class="number">-1</span>, <span class="string">&quot;socket accept error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new client fd %d! IP: %s Port: %d\n&quot;</span>, clnt_sockfd, inet_ntoa(clnt_addr.sin_addr), ntohs(clnt_addr.sin_port));</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        bzero(&amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">ssize_t</span> read_bytes = read(clnt_sockfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(read_bytes &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;message from client fd %d: %s\n&quot;</span>, clnt_sockfd, buf);</span><br><span class="line">            write(clnt_sockfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(read_bytes == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client fd %d disconnected\n&quot;</span>, clnt_sockfd);</span><br><span class="line">            close(clnt_sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(read_bytes == <span class="number">-1</span>)&#123;</span><br><span class="line">            close(clnt_sockfd);</span><br><span class="line">            errif(<span class="literal">true</span>, <span class="string">&quot;socket read error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    errif(sockfd == <span class="number">-1</span>, <span class="string">&quot;socket create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">    errif(connect(sockfd, (sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>, <span class="string">&quot;socket connect error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        bzero(&amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">ssize_t</span> write_bytes = write(sockfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(write_bytes == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;socket already disconnected, can&#x27;t write any more!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bzero(&amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">ssize_t</span> read_bytes = read(sockfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(read_bytes &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;message from server: %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(read_bytes == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server socket disconnected!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(read_bytes == <span class="number">-1</span>)&#123;</span><br><span class="line">            close(sockfd);</span><br><span class="line">            errif(<span class="literal">true</span>, <span class="string">&quot;socket read error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二-高并发"><a href="#二-高并发" class="headerlink" title="二. 高并发"></a>二. 高并发</h1><p>IO复用是针对IO接口，而多线程是针对CPU。在Linux系统中，IO复用使用select, poll和epoll来实现。epoll改进了前两者，更加高效、性能更好，是目前几乎所有高并发服务器的基石。</p>
<p>epoll监听事件的描述符会放在一颗红黑树上，我们将要监听的IO口放入epoll红黑树中，就可以监听该IO上的事件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev);    <span class="comment">//添加事件到epoll</span></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &amp;ev);    <span class="comment">//修改epoll红黑树上的事件</span></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);   <span class="comment">//删除事件</span></span><br></pre></td></tr></table></figure>

<p>其中sockfd表示我们要添加的IO文件描述符，ev是一个epoll_event结构体，其中的events表示事件，如EPOLLIN等，data是一个用户数据union:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> events;	<span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;	<span class="comment">/* User data variable */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br></pre></td></tr></table></figure>

<p>epoll默认采用LT触发模式，即水平触发，只要fd上有事件，就会一直通知内核。这样可以保证所有事件都得到处理、不容易丢失，但可能发生的大量重复通知也会影响epoll的性能。如使用ET模式，即边缘触法，fd从无事件到有事件的变化会通知内核一次，之后就不会再次通知内核。这种方式十分高效，可以大大提高支持的并发度，但程序逻辑必须一次性很好地处理该fd上的事件，编程比LT更繁琐。注意ET模式必须搭配非阻塞式socket使用。</p>
<p>我们可以随时使用<code>epoll_wait</code>获取有事件发生的fd：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nfds = epoll_wait(epfd, events, maxevents, timeout);</span><br></pre></td></tr></table></figure>

<p>其中events是一个epoll_event结构体数组，maxevents是可供返回的最大事件大小，一般是events的大小，timeout表示最大等待时间，设置为-1表示一直等待。</p>
<p>服务器改写成epoll版本，基本思想为：在创建了服务器socket fd后，将这个fd添加到epoll，只要这个fd上发生可读事件，表示有一个新的客户端连接。然后accept这个客户端并将客户端的socket fd添加到epoll，epoll会监听客户端socket fd是否有事件发生，如果发生则处理事件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sockfd = socket(...);   <span class="comment">//创建服务器socket fd</span></span><br><span class="line">bind(sockfd...);</span><br><span class="line">listen(sockfd...);</span><br><span class="line"><span class="keyword">int</span> epfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>], <span class="title">ev</span>;</span></span><br><span class="line">ev.events = EPOLLIN;    <span class="comment">//在代码中使用了ET模式，且未处理错误，在day12进行了修复，实际上接受连接最好不要用ET模式</span></span><br><span class="line">ev.data.fd = sockfd;    <span class="comment">//该IO口为服务器socket fd</span></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev);    <span class="comment">//将服务器socket fd添加到epoll</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;    <span class="comment">// 不断监听epoll上的事件并处理</span></span><br><span class="line">    <span class="keyword">int</span> nfds = epoll_wait(epfd, events, MAX_EVENTS, <span class="number">-1</span>);   <span class="comment">//有nfds个fd发生事件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i)&#123;  <span class="comment">//处理这nfds个事件</span></span><br><span class="line">        <span class="keyword">if</span>(events[i].data.fd == sockfd)&#123;    <span class="comment">//发生事件的fd是服务器socket fd，表示有新客户端连接</span></span><br><span class="line">            <span class="keyword">int</span> clnt_sockfd = accept(sockfd, (sockaddr*)&amp;clnt_addr, &amp;clnt_addr_len);</span><br><span class="line">            ev.data.fd = clnt_sockfd;   </span><br><span class="line">            ev.events = EPOLLIN | EPOLLET;  <span class="comment">//对于客户端连接，使用ET模式，可以让epoll更加高效，支持更多并发</span></span><br><span class="line">            setnonblocking(clnt_sockfd);    <span class="comment">//ET需要搭配非阻塞式socket使用</span></span><br><span class="line">            epoll_ctl(epfd, EPOLL_CTL_ADD, clnt_sockfd, &amp;ev);   <span class="comment">//将该客户端的socket fd添加到epoll</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN)&#123;      <span class="comment">//发生事件的是客户端，并且是可读事件（EPOLLIN）</span></span><br><span class="line">            handleEvent(events[i].data.fd);         <span class="comment">//处理该fd上发生的事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三-封装成类"><a href="#三-封装成类" class="headerlink" title="三. 封装成类"></a>三. 封装成类</h1><p>socket：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Socket *serv_sock = <span class="keyword">new</span> Socket();</span><br><span class="line">InetAddress *serv_addr = <span class="keyword">new</span> InetAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">serv_sock-&gt;bind(serv_addr);</span><br><span class="line">serv_sock-&gt;listen();   </span><br><span class="line">InetAddress *clnt_addr = <span class="keyword">new</span> InetAddress();  </span><br><span class="line">Socket *clnt_sock = <span class="keyword">new</span> Socket(serv_sock-&gt;accept(clnt_addr));    </span><br></pre></td></tr></table></figure>

<p>epoll：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Epoll *ep = <span class="keyword">new</span> Epoll();</span><br><span class="line">ep-&gt;addFd(serv_sock-&gt;getFd(), EPOLLIN | EPOLLET);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;epoll_event&gt; events = ep-&gt;poll();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; events.size(); ++i)&#123;</span><br><span class="line">        <span class="comment">// handle event</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四-抽象服务器"><a href="#四-抽象服务器" class="headerlink" title="四. 抽象服务器"></a>四. 抽象服务器</h1><p>仔细分析可发现，对于每一个事件，不管提供什么样的服务，首先需要做的事都是调用<code>accept()</code>函数接受这个TCP连接，然后将socket文件描述符添加到epoll。当这个IO口有事件发生的时候，再对此TCP连接提供相应的服务。因此我们可以分离接受连接这一模块，添加一个<code>Acceptor</code>类，这个类有以下几个特点：</p>
<ul>
<li>类存在于事件驱动<code>EventLoop</code>类中，也就是Reactor模式的main-Reactor</li>
<li>类中的socket fd就是服务器监听的socket fd，每一个Acceptor对应一个socket fd</li>
<li>这个类也通过一个独有的<code>Channel</code>负责分发到epoll，该Channel的事件处理函数<code>handleEvent()</code>会调用Acceptor中的接受连接函数来新建一个TCP连接</li>
</ul>
<p>对于TCP协议，三次握手新建连接后，这个连接将会一直存在，直到我们四次挥手断开连接。因此，我们也可以把TCP连接抽象成一个<code>Connection</code>类，这个类也有以下几个特点：</p>
<ul>
<li>类存在于事件驱动<code>EventLoop</code>类中，也就是Reactor模式的main-Reactor</li>
<li>类中的socket fd就是客户端的socket fd，每一个Connection对应一个socket fd</li>
<li>每一个类的实例通过一个独有的<code>Channel</code>负责分发到epoll，该Channel的事件处理函数<code>handleEvent()</code>会调用Connection中的事件处理函数来响应客户端请求</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><code>Acceptor</code>拿着服务器的<code>sockfd</code>等待着客户来连接，即大堂经理，负责招待贵客。一旦建立连接，拿到客户的<code>sockfd</code>，将这个连接保存管理起来。所有的<code>sockfd</code>都会放入<code>epoll</code>中进行监听。连接中的客户被监听到事件，则仍给线程池进行任务处理。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>关于线程池，需要特别注意的有两点，一是在多线程环境下任务队列的读写操作都应该考虑互斥锁，二是当任务队列为空时CPU不应该不断轮询耗费CPU资源。为了解决第一点，这里使用<code>std::mutex</code>来对任务队列进行加锁解锁。为了解决第二个问题，使用了条件变量<code>std::condition_variable</code>。</p>
<h2 id="主从Reactor多线程"><a href="#主从Reactor多线程" class="headerlink" title="主从Reactor多线程"></a>主从Reactor多线程</h2><p>main-Reactor只负责接受新的连接，建立连接后将连接交给sub-Reactor管理。一个线程负责一个sub-Reactor，并监听该connection上的事件，读写任务交给线程池完成。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean生命周期</title>
    <url>/2022/11/28/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="一-什么是bean对象"><a href="#一-什么是bean对象" class="headerlink" title="一. 什么是bean对象"></a>一. 什么是bean对象</h2><p>在普通Java环境下创建对象简要的步骤可以分为：</p>
<p>1):java源码被编译为被编译为class文件</p>
<p>2):等到类需要被初始化时（比如说new、反射等）</p>
<p>3):class文件被虚拟机通过类加载器加载到JVM</p>
<p>4):初始化对象供我们使用</p>
<p>简单来说，可以理解为它是用Class对象作为「模板」进而创建出具体的实例。而Spring所管理的Bean不同的是，除了Class对象之外，还会使用BeanDefinition的实例来描述对象的信息，比如说，我们可以在Spring所管理的Bean有一系列的描述：@Scope、@Lazy、@DependsOn等等。可以理解为Class只描述了类的信息，而BeanDefinition描述了对象的信息。</p>
<h1 id="二-配置信息"><a href="#二-配置信息" class="headerlink" title="二. 配置信息"></a>二. 配置信息</h1><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2kvNTgwNjMxLzIwMTQwNS8xODE0NTM0MTQyMTIwNjYucG5n?x-oss-process=image/format,png" alt="img"></p>
<p>Spring在启动的时候需要「扫描」在XML/注解/JavaConfig 中需要被Spring管理的Bean信息，随后，会将这些信息封装成BeanDefinition，最后会把这些信息放到一个beanDefinitionMap中&lt;beanName，BeanDefinition对象&gt;。接着会遍历这个beanDefinitionMap，执行BeanFactoryPostProcessor这个Bean工厂后置处理器的逻辑，之后，就到了实例化对象啦，在Spring里边是通过反射来实现的，一般情况下会通过反射选择合适的构造器来把对象实例化。</p>
<h1 id="三-管理bean对象"><a href="#三-管理bean对象" class="headerlink" title="三. 管理bean对象"></a>三. 管理bean对象</h1><p><img src="https://img-blog.csdnimg.cn/20210201171210687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2ODY0NzQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>第1步：调用bean的构造方法创建bean；</p>
<p>第2步：通过反射调用setter方法进行属性的依赖注入；</p>
<p>第3步：如果实现BeanNameAware接口的话，会设置bean的name；</p>
<p>第4步：如果实现了BeanFactoryAware，会把bean factory设置给bean；</p>
<p>第5步：如果实现了ApplicationContextAware，会给bean设置ApplictionContext；</p>
<p>(是否实现了Aware接口，用于对Spring Bean的扩展）</p>
<p>第6步：如果实现了BeanPostProcessor接口，则执行前置处理方法；</p>
<p>（这个BeanPostProcessor后置处理器是AOP实现的关键）</p>
<p>第7步：实现了InitializingBean接口的话，执行afterPropertiesSet方法；</p>
<p>第8步：执行自定义的init方法；</p>
<p>第9步：执行BeanPostProcessor接口的后置处理方法。</p>
<p>这时，就完成了bean的创建过程。</p>
<p>在使用完bean需要销毁时，会先执行DisposableBean接口的destroy方法，然后在执行自定义的destroy方法。</p>
<h3 id="Spring是怎么解决循环依赖的"><a href="#Spring是怎么解决循环依赖的" class="headerlink" title="Spring是怎么解决循环依赖的"></a><strong>Spring是怎么解决循环依赖的</strong></h3><p>首先A对象实例化，然后对属性进行注入，发现依赖B对象</p>
<p>B对象此时还没创建出来，所以转头去实例化B对象</p>
<p>B对象实例化之后，发现需要依赖A对象，那A对象已经实例化了嘛，所以B对象最终能完成创建</p>
<p>B对象返回到A对象的属性注入的方法上，A对象最终完成创建</p>
<p>至于原理，其实就是用到了三级的缓存，所谓的三级缓存其实就是三个Map（一级，日常实际获取Bean的地方）（二级，还没进行属性注入，由三级缓存放进来）（三级，Value是一个对象工厂）</p>
<p>我们自己去getBean的时候，实际上拿到的是一级缓存的。</p>
]]></content>
      <tags>
        <tag>spring - java</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算字母大小写转换</title>
    <url>/2021/12/17/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>大写变小写、小写变大写 : 字符 ^= 32;</p>
<p>大写变小写、小写变小写 : 字符 |= 32;</p>
<p>小写变大写、大写变大写 : 字符 &amp;= -33;</p>
<p>小写字母的ASCII码比大写字母的大，比如，大写A是65，小写a是97，它们的差是32。</p>
<p>65 | 32 转为二进制=&gt;可以得到 0100 0001 | 0010 0000 = 0110 0001 = 97 = a</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow初始化及其求导</title>
    <url>/2021/09/13/tensorflow%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%85%B6%E6%B1%82%E5%AF%BC/</url>
    <content><![CDATA[<p>直接上代码，一看就明白！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#随机初始化</span></span><br><span class="line">v1=tf.Variable(tf.random.normal(shape=[<span class="number">4</span>,<span class="number">3</span>],mean=<span class="number">0</span>,stddev=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#结合numpy</span></span><br><span class="line">a = np.random.random((<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment">#常量形式</span></span><br><span class="line">v2=tf.constant(a.astype(<span class="string">&#x27;float32&#x27;</span>))</span><br><span class="line"><span class="comment">#变量形式1</span></span><br><span class="line">v3=tf.Variable(a.astype(<span class="string">&#x27;float32&#x27;</span>))</span><br><span class="line"><span class="comment">#变量形式2</span></span><br><span class="line">v4=tf.Variable(v2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#特殊形式0，1等</span></span><br><span class="line">v5=tf.Variable(tf.ones([<span class="number">4</span>,<span class="number">3</span>]))</span><br><span class="line"></span><br><span class="line">v6=tf.convert_to_tensor(a,dtype=tf.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(a)</span></span><br><span class="line"><span class="comment"># print(v1)</span></span><br><span class="line"><span class="comment"># print(v2)</span></span><br><span class="line"><span class="comment"># print(v3)</span></span><br><span class="line"><span class="comment"># print(v4)</span></span><br><span class="line"><span class="comment"># print(v5)</span></span><br><span class="line"><span class="comment"># print(v6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print((v6.numpy() == v2.numpy()).all())</span></span><br><span class="line"><span class="comment"># print((v6.numpy() == v3.numpy()).all())</span></span><br><span class="line"><span class="comment"># print((v6.numpy() == v4.numpy()).all())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#试图对常量求导</span></span><br><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> g:  <span class="comment"># 记录求导的磁带</span></span><br><span class="line">    y = v2 * v2</span><br><span class="line">dy_dx = g.gradient(y, v2)  <span class="comment"># 求导</span></span><br><span class="line">print(dy_dx)</span><br><span class="line"></span><br><span class="line"><span class="comment">#监控常量</span></span><br><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> g:  <span class="comment"># 记录求导的磁带</span></span><br><span class="line">    g.watch(v2)</span><br><span class="line">    y = v2 * v2</span><br><span class="line">dy_dx = g.gradient(y, v2)  <span class="comment"># 求导</span></span><br><span class="line">print(dy_dx)</span><br><span class="line"></span><br><span class="line"><span class="comment">#对变量求导</span></span><br><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> g:  <span class="comment"># 记录求导的磁带</span></span><br><span class="line">    y = v4 * v4</span><br><span class="line">dy_dx = g.gradient(y, v4)  <span class="comment"># 求导</span></span><br><span class="line">print(dy_dx)</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>tensorflow</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow计算psnr与ssim</title>
    <url>/2021/09/13/tensorflow%E8%AE%A1%E7%AE%97psnr%E4%B8%8Essim/</url>
    <content><![CDATA[<h1 id="加载mnist进行测试"><a href="#加载mnist进行测试" class="headerlink" title="加载mnist进行测试"></a>加载mnist进行测试</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">load_engine = tf.keras.datasets.mnist</span><br><span class="line"><span class="comment"># load_engine = tf.keras.datasets.fashion_mnist</span></span><br><span class="line">(x_train, y_train), (x_test, y_test) = load_engine.load_data()</span><br><span class="line">print(x_train.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将标签转one_hot编码</span></span><br><span class="line">y_train = tf.one_hot(y_train,<span class="number">10</span>)</span><br><span class="line">y_test = tf.one_hot(y_test,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#扩展一维，将灰度图变成单通道图</span></span><br><span class="line">x_train = np.expand_dims(x_train.astype(np.float32) / <span class="number">255.0</span>, axis=<span class="number">-1</span>)  <span class="comment"># [60000, 28, 28, 1]</span></span><br><span class="line"><span class="comment"># x_train = tf.expand_dims(x_train,axis=-1)</span></span><br><span class="line"><span class="comment"># x_train = tf.reshape(x_train,(-1,28,28,1))</span></span><br></pre></td></tr></table></figure>

<h1 id="方便的预处理操作"><a href="#方便的预处理操作" class="headerlink" title="方便的预处理操作"></a>方便的预处理操作</h1><p>洗牌、批量、转换等操作都可以。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mnist_dataset = tf.data.Dataset.from_tensor_slices((x_train, y_train))</span><br><span class="line">mnist_dataset = mnist_dataset.batch(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h1 id="计算指标"><a href="#计算指标" class="headerlink" title="计算指标"></a>计算指标</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自定义计算psnr</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_psnr2</span>(<span class="params">img1, img2</span>):</span></span><br><span class="line">   mse = np.mean((img1/<span class="number">1.0</span> - img2/<span class="number">1.0</span>) ** <span class="number">2</span> )</span><br><span class="line">   <span class="keyword">if</span> mse &lt; <span class="number">1.0e-10</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">10</span> * math.log10(<span class="number">1.0</span>/mse)</span><br></pre></td></tr></table></figure>
<h2 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> images, labels <span class="keyword">in</span> mnist_dataset:    <span class="comment"># image: [4, 28, 28, 1], labels: [4]</span></span><br><span class="line">    print(labels.shape)</span><br><span class="line">    print(images.shape)</span><br><span class="line"></span><br><span class="line">    print(images[<span class="number">0</span>].shape)</span><br><span class="line">    print(images[<span class="number">1</span>].shape)</span><br><span class="line">    print(get_psnr2(images[<span class="number">0</span>], images[<span class="number">1</span>]))</span><br><span class="line">    psnr = tf.image.psnr(images[<span class="number">0</span>], images[<span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">    print(psnr)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/6a20185518e54157b408fb899ba7c1ee.png" alt="在这里插入图片描述"><br>结果正常！</p>
<h2 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a><font color = red>测试2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> images, labels <span class="keyword">in</span> mnist_dataset:    <span class="comment"># image: [4, 28, 28, 1], labels: [4]</span></span><br><span class="line">    print(labels.shape)</span><br><span class="line">    print(images.shape)</span><br><span class="line"></span><br><span class="line">    print(images[<span class="number">0</span>].shape)</span><br><span class="line">    print(images[<span class="number">1</span>].shape)</span><br><span class="line">    print(get_psnr2(images[<span class="number">0</span>], images[<span class="number">0</span>]))</span><br><span class="line">    psnr = tf.image.psnr(images[<span class="number">0</span>], images[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line">    print(psnr)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/8eaf15a2cf38418498e61e1de9234706.png" alt="在这里插入图片描述"><br>不会吧不会吧，不会tensorflow连除数为0都不考虑吧。。。<br>计算psnr需要计算mse，当两张一样的图片时，mse几乎为0，在计算psnr那就无穷大了。<br>tensorflow万万没想到我会计算两张一样的图片？？？。。。</p>
<h2 id="测试3，批量计算"><a href="#测试3，批量计算" class="headerlink" title="测试3，批量计算"></a>测试3，批量计算</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bath=[]</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> images, labels <span class="keyword">in</span> mnist_dataset:    <span class="comment"># image: [4, 28, 28, 1], labels: [4]</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    bath.append(images)</span><br><span class="line">    <span class="keyword">if</span> i&gt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># psnr = tf.image.psnr(images, images, 1)</span></span><br><span class="line">    <span class="comment"># print(psnr)</span></span><br><span class="line">    <span class="comment"># break</span></span><br><span class="line"></span><br><span class="line">print(tf.image.psnr(bath[<span class="number">0</span>],bath[<span class="number">1</span>],<span class="number">1</span>))</span><br><span class="line">print(tf.image.ssim(bath[<span class="number">0</span>],bath[<span class="number">1</span>],<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/ef8a44fa50244bf9bdb93a41b12250b1.png" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>tensorflow</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>tf.image.resize与skimage的resize</title>
    <url>/2021/08/21/tf.image.resize%E4%B8%8Eskimage%E7%9A%84resize/</url>
    <content><![CDATA[<h1 id="skimage文档是这样说的"><a href="#skimage文档是这样说的" class="headerlink" title="skimage文档是这样说的"></a>skimage文档是这样说的</h1><p>skimage.transform.resize( image , output_shape , order=None , <strong>mode=’reflect’</strong> , cval=0 , clip=True , preserve_range=False , anti_aliasing=None , anti_aliasing_sigma=None )</p>
<p>Performs <strong>interpolation</strong> to up-size or down-size N-dimensional images.</p>
<p>mode{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional<br>Points outside the boundaries of the input are filled according to the given mode. Modes match the behaviour of <strong>numpy.pad.</strong></p>
<h1 id="numpy文档又是这么说的"><a href="#numpy文档又是这么说的" class="headerlink" title="numpy文档又是这么说的"></a>numpy文档又是这么说的</h1><p>‘constant’ (default)<br>Pads with a constant value.</p>
<p>‘edge’<br>Pads with the edge values of array.</p>
<p>‘reflect’<br>Pads with the reflection of the vector mirrored on the first and last values of the vector along each axis.</p>
<p>‘symmetric’<br>Pads with the reflection of the vector mirrored along the edge of the array.</p>
<p>‘wrap’<br>Pads with the wrap of the vector along the axis. The first values are used to pad the end and the end values are used to pad the beginning.</p>
<h3 id="pad和插值应该有区别吧？？？"><a href="#pad和插值应该有区别吧？？？" class="headerlink" title="pad和插值应该有区别吧？？？"></a>pad和插值应该有区别吧？？？</h3><h1 id=""><a href="#" class="headerlink" title="============================"></a>============================</h1><h1 id="tf2-0的resize"><a href="#tf2-0的resize" class="headerlink" title="tf2.0的resize"></a>tf2.0的resize</h1><p>tf.image.resize(<br>    images, size, method=ResizeMethod.BILINEAR, preserve_aspect_ratio=False,<br>    antialias=False, name=None<br>)</p>
<p>其中 method 有四种选择：</p>
<p>ResizeMethod.BILINEAR ：双线性插值</p>
<p>ResizeMethod.NEAREST_NEIGHBOR ： 最近邻插值</p>
<p>ResizeMethod.BICUBIC ： 双三次插值</p>
<p>ResizeMethod.AREA ：面积插值</p>
<h2 id="这才是正儿八经的用插值来resize图片吧？！！"><a href="#这才是正儿八经的用插值来resize图片吧？！！" class="headerlink" title="这才是正儿八经的用插值来resize图片吧？！！"></a>这才是正儿八经的用插值来resize图片吧？！！</h2><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>从实验层面来看一下他们之间的区别究竟有多大。<br>思路：加载一批图片，分别用上述两种resize方法进行处理，然后算一下他们之间的psnr值看看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#加载cifar10的测试集</span><br><span class="line">x_test, y_test &#x3D; get_data_set(&quot;test&quot;)</span><br><span class="line">#随便整几张图片试试</span><br><span class="line">x_test &#x3D; x_test[:33]</span><br><span class="line"></span><br><span class="line"># img &#x3D; x_test[0,:,:,:]</span><br><span class="line">#</span><br><span class="line"># print(img.shape)</span><br><span class="line"># plt.imshow(img)</span><br><span class="line"># plt.show()</span><br><span class="line"># aa &#x3D; tf.image.resize(img, [48, 48]).numpy()</span><br><span class="line"># print(aa.shape)</span><br><span class="line"># plt.imshow(aa)</span><br><span class="line"># plt.show()</span><br><span class="line"></span><br><span class="line">from skimage.transform import resize</span><br><span class="line"></span><br><span class="line">X_test &#x3D; np.array([resize(x, output_shape&#x3D;(48, 48)) for x in x_test])</span><br><span class="line"></span><br><span class="line">import math</span><br><span class="line">def get_psnr(img1, img2):</span><br><span class="line">   mse &#x3D; np.mean( (img1&#x2F;1. - img2&#x2F;1.) ** 2 )</span><br><span class="line">   if mse &lt; 1.0e-10:</span><br><span class="line">      return 100</span><br><span class="line">   PIXEL_MAX &#x3D; 1</span><br><span class="line">   return 20 * math.log10(PIXEL_MAX &#x2F; math.sqrt(mse))</span><br><span class="line"></span><br><span class="line">#四种方式</span><br><span class="line">bb &#x3D; [tf.image.ResizeMethod.BILINEAR,tf.image.ResizeMethod.NEAREST_NEIGHBOR,tf.image.ResizeMethod.BICUBIC , tf.image.ResizeMethod.AREA]</span><br><span class="line"></span><br><span class="line">for j in range(4):</span><br><span class="line">    for i in range(32):</span><br><span class="line">        temp &#x3D; tf.image.resize(x_test[i, :, :, :], [48, 48], method&#x3D;bb[j]).numpy()</span><br><span class="line">        psnr &#x3D; get_psnr(temp,X_test[i, :, :, :])</span><br><span class="line">        print(psnr,end&#x3D;&quot; &quot;)</span><br><span class="line">    print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)</span><br></pre></td></tr></table></figure>

<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote>
<p>46.669033558302885 48.90798774917477 53.38381232542708 48.43096027380447 46.63530041008276 49.853715847548045 46.97129446274798 57.92736516572543 52.02712480456207 47.9270666009561 56.815827971818976 43.58148330692217 49.15912003347911 45.571104617307476 44.778364129271104 46.13820707579342 43.018938041725974 49.702719907722226 48.09563717071776 49.98946646853693 45.87546487951293 63.99499287231072 53.94231731555267 43.738499959122024 46.908452504151406 44.42300374351233 47.622822312811095 50.28564910040936 45.20506178645428 49.319071870542366 47.76259998082413 55.95695969034264 =====================<br>26.97628677450534 26.924861715004923 29.183922133559385 28.454948098090075 27.641430200201178 29.73183032295352 25.466182577940355 31.338492508076765 29.9067674657335 26.197798316302723 31.13589159316287 25.056555401591417 28.983519879947536 23.96870655942354 25.427217596503308 26.396676988617553 25.754045363673626 27.128767028700782 28.461873499287837 27.005025244577926 24.871044509277738 25.537881905908407 35.51861682838789 23.738132391790444 28.941631597341658 27.680023619665302 28.389742788850572 28.745888550449724 24.902620199920307 29.115073004421962 29.751666906604072 32.08766152133068 =====================<br>37.03543857489388 37.259828641504036 40.213764737505635 38.04380796549642 36.7790259503914 39.23595602822592 35.77335658889253 42.27602482590236 40.28042495809771 37.0365490315566 42.2178204137436 35.00559003779734 38.91261259423612 34.711268849468595 35.35611781891313 36.27121114979309 35.65962402278565 37.664839650830196 38.37510414747462 37.376202536896336 36.05599500393482 36.64829305721068 45.38580840924415 34.07303854523669 38.97407018442087 37.5050909468706 39.13560505488175 39.3079174725139 35.70591190864245 38.35261549238907 39.2579847332357 43.88169978322925 =====================<br>34.77223282063561 34.00181912589067 36.918973301639596 34.3329021393655 34.247488624884085 36.45586961708923 32.32954212272813 38.57978679534951 37.007158514958 34.32080115763002 38.97647966809106 32.45896604574029 35.47081126975141 31.825603643146007 32.64746063172551 33.70869438835973 33.031301832751815 34.430776528882056 35.08218773125719 34.47020053917494 33.410030293674254 32.82951933890276 43.05155492385302 31.716446871714886 36.40419415215108 35.800352782290055 35.61569268275426 36.03531143542608 32.84526522882461 35.80328351242286 37.49832733079886 39.793573612797786 =====================</p>
</blockquote>
<p>显然，tf的双线性插值模式的psnr值最大，50左右。我们知道，这个值其实也不低了。我也试了，用skimage的resize处理的图片训练的模型来预测用tf.resize处理的图片。效果也不差。</p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>计算机视觉</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达神经网络</title>
    <url>/2021/06/06/%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
    <content><![CDATA[<h1 id="What-you-need-to-remember"><a href="#What-you-need-to-remember" class="headerlink" title="What you need to remember:"></a>What you need to remember:</h1><p>• <strong>np.exp(x)</strong> works for any np.array x and applies the exponential function<br>to every coordinate<br>• the <strong>sigmoid</strong> function and its gradient</p>
<a id="more"></a>
<p>• <strong>image2vector</strong> is commonly used in deep learning<br>• <strong>np.reshape</strong> is widely used. In the future, you’ll see that keeping your<br>matrix/vector dimensions straight will go toward eliminating a lot of<br>bugs.<br>• numpy has efficient built-in functions<br>• <strong>broadcasting</strong> is extremely useful</p>
<h1 id="What-to-remember"><a href="#What-to-remember" class="headerlink" title="What to remember:"></a>What to remember:</h1><p>• <strong>Vectorization</strong> is very important in deep learning. It provides computa-<br>tional efficiency and clarity.<br>• You have reviewed the L1 and L2 <strong>loss</strong>.<br>• You are familiar with many numpy functions such as np.sum, np.dot,<br>np.multiply, np.maximum, etc…</p>
<h1 id="What-you-need-to-remember-1"><a href="#What-you-need-to-remember-1" class="headerlink" title="What you need to remember:"></a>What you need to remember:</h1><p>Common steps for <strong>pre-processing</strong> a new dataset are:<br>• Figure out the dimensions and shapes of the problem (m_train, m_test, num_px,<br>…)<br>• Reshape the datasets such that each example is now a vector of size (num_px *<br>num_px * 3, 1)<br>• <strong>Standardize</strong> the data</p>
<h1 id="What-to-remember-You’ve-implemented-several-functions-that"><a href="#What-to-remember-You’ve-implemented-several-functions-that" class="headerlink" title="What to remember: You’ve implemented several functions that:"></a>What to remember: You’ve implemented several functions that:</h1><p>• <strong>Initialize</strong> (w,b)<br>• <strong>Optimize</strong> the loss iteratively to learn parameters (w,b):<br>– computing the cost and its <strong>gradient</strong><br>– <strong>updating</strong> the parameters using gradient descent<br>• Use the learned (w,b) to <strong>predict</strong> the labels for a given set of examples</p>
<h1 id="What-to-remember-from-this-assignment"><a href="#What-to-remember-from-this-assignment" class="headerlink" title="What to remember from this assignment:"></a>What to remember from this assignment:</h1><ol>
<li><strong>Preprocessing</strong> the dataset is important.</li>
<li>You implemented each function separately: initialize(), propagate(), optimize().<br>Then you built a model().</li>
<li>Tuning the learning rate (which is an example of a ”<strong>hyperparameter</strong>”) can make a<br>big difference to the algorithm</li>
</ol>
<h1 id="What-you-should-remember"><a href="#What-you-should-remember" class="headerlink" title="What you should remember:"></a>What you should remember:</h1><p>• The weights W<sup>[l]</sup> should be <strong>initialized</strong> randomly to break symmetry.<br>• It is however okay to initialize the biases b<sup>[l]</sup> to zeros. Symmetry is still<br>broken so long as W<sup>[l]</sup> is initialized randomly.</p>
<p>• Initializing weights to very large random values does not work well.</p>
<p>• Hopefully intializing with <strong>small random values</strong> does better. </p>
<h1 id="What-you-should-remember-from-this-assignment"><a href="#What-you-should-remember-from-this-assignment" class="headerlink" title="What you should remember from this assignment:"></a>What you should remember from this assignment:</h1><p>• Different initializations lead to different results<br>• Random initialization is used to break symmetry and make sure different<br>hidden units can learn different things<br>• Don’t intialize to values that are too large<br>• He initialization works well for networks with ReLU activations.</p>
<p><u><font color=red>Gradient Descent =&gt; Stochastic Gradient Descent (SGD) =&gt;mini-batch Gradient Descent</font></u></p>
<p><font color=red><u>SGD is equivalent to mini-batch gradient descent where each mini-batch has just 1 example.</u></font></p>
<h1 id="What-you-should-remember-1"><a href="#What-you-should-remember-1" class="headerlink" title="What you should remember:"></a>What you should remember:</h1><p>• The difference between <strong>gradient descent, mini-batch gradient descent and stochastic</strong><br><strong>gradient descent</strong> is the number of examples you use to perform one update step.<br>• You have to tune a learning rate <strong>hyperparameter</strong> α.<br>• With a well-turned mini-batch size, usually it outperforms either gradient descent<br>or stochastic gradient descent (particularly when the training set is large).</p>
<h1 id="What-you-should-remember-2"><a href="#What-you-should-remember-2" class="headerlink" title="What you should remember:"></a>What you should remember:</h1><p>• Shuffling and Partitioning are the two steps required to build mini-batches<br>• Powers of two are often chosen to be the mini-batch size, e.g., 16, 32, 64, 128.</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>发音</title>
    <url>/2021/06/06/%E9%9F%B3%E6%A0%87/</url>
    <content><![CDATA[<ul>
<li><strong>/e/ 和 /æ/ ，</strong>两个音标在日常生活中常常容易搞错，关键的区别在于<strong>口型的大小</strong>。</li>
</ul>
<blockquote>
<p>  <strong>/e/</strong>      <strong>/æ/</strong></p>
<p>  b<strong>e</strong>d 床    b<strong>a</strong>d 坏的</p>
<p>  r<strong>e</strong>d 红色   r<strong>a</strong>t 老鼠</p>
</blockquote>
<a id="more"></a>

<ul>
<li>发 <strong>/ə/</strong> 时，<strong>嘴巴放松</strong>，微微打开一点，比刚才的**/e/<strong>开口小。和拼音的</strong>e<strong>相比，发音更</strong>短促**，不能拖音。</li>
</ul>
<blockquote>
<p>  <strong>/e/</strong>      <strong>/ə/</strong></p>
<p> <strong>e</strong>ffort 努力    <strong>a</strong>fford 承担</p>
<p> l<strong>e</strong>t 让     pil<strong>o</strong>t 飞行员</p>
</blockquote>
<ul>
<li>发 <strong>/ɜːr/</strong> 时，先发长元音**/ɜ:/<strong>，再快速过渡到</strong>卷舌音/r/**。</li>
</ul>
<blockquote>
<p><strong>/ɜːr/</strong>      <strong>/e/</strong></p>
<p>h<strong>ear</strong>d 听见    h<strong>ea</strong>d 头</p>
<p>l<strong>ear</strong>n 学习    l<strong>e</strong>sson 课程</p>
</blockquote>
<ul>
<li>发 <strong>/ʌ/</strong> 时，不能把嘴张得太大，只要打开到**/ɑː/的一半大小<strong>就可以，发音要</strong>短促有力**。</li>
</ul>
<blockquote>
<p>  <strong>/ɑː/</strong>      <strong>/ʌ/</strong></p>
<p>   b<strong>o</strong>dy 身体   b<strong>u</strong>ddy 伙伴</p>
<p> l<strong>a</strong>tte 拿铁    l<strong>o</strong>ve 爱</p>
</blockquote>
<ul>
<li>发 <strong>/ʊ/</strong> 时，嘴唇不需要像**/uː/<strong>那样用力圈成小圆，只需要微微地让</strong>双唇往前突一下<strong>，发音要</strong>短促有力**。</li>
</ul>
<blockquote>
<p>  <strong>/u:/</strong>      <strong>/ʊ/</strong></p>
<p>  f<strong>oo</strong>d 食物    g<strong>oo</strong>d 好的</p>
<p>   p<strong>oo</strong>l 泳池    p<strong>u</strong>t 放下</p>
</blockquote>
<ul>
<li>发 <strong>/i:/</strong> 时，<strong>拖长发音</strong>，同时<strong>把嘴角向两边拉</strong>。发 <strong>/ɪ/**时，</strong>微微打开一点<strong>嘴巴，舌尖向下</strong>抵在下齿<strong>那里发音，发音要</strong>短而有力**。</li>
</ul>
<blockquote>
<p>  <strong>/i:/</strong>      <strong>/ɪ/</strong></p>
<p>  <strong>ea</strong>t 吃     <strong>i</strong>t 它</p>
<p> l<strong>ea</strong>ve 离开    l<strong>i</strong>ve 居住</p>
</blockquote>
<ul>
<li></li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕神经网络框架（numpy）</title>
    <url>/2021/04/23/%E6%89%8B%E6%92%95%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%EF%BC%88numpy%EF%BC%89/</url>
    <content><![CDATA[<p>@<a href="%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4">TOC</a></p>
<p><strong><em>任何神经网络肯定都有这些基本操作过程，每一小步中又会有各种不同的策略。</em></strong><br><em>我是跟着<strong>吴恩达</strong>大佬做的一些实践，对神经网络的理解特别有用</em></p>
<h1 id="loaddata"><a href="#loaddata" class="headerlink" title="loaddata"></a>loaddata</h1><p>这一步包括归一化、小批量读取等等操作。这里只做一些最简单的处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def load_dataset():</span><br><span class="line">    train_dataset &#x3D; h5py.File(&#39;D:&#x2F;PyWorkspace&#x2F;DeepLearning&#x2F;datasets&#x2F;train_catvnoncat.h5&#39;, &quot;r&quot;)</span><br><span class="line">    train_set_x_orig &#x3D; np.array(train_dataset[&quot;train_set_x&quot;][:])  # your train set features</span><br><span class="line">    train_set_y_orig &#x3D; np.array(train_dataset[&quot;train_set_y&quot;][:])  # your train set labels</span><br><span class="line"></span><br><span class="line">    test_dataset &#x3D; h5py.File(&#39;D:&#x2F;PyWorkspace&#x2F;DeepLearning&#x2F;datasets&#x2F;test_catvnoncat.h5&#39;, &quot;r&quot;)</span><br><span class="line">    test_set_x_orig &#x3D; np.array(test_dataset[&quot;test_set_x&quot;][:])  # your test set features</span><br><span class="line">    test_set_y_orig &#x3D; np.array(test_dataset[&quot;test_set_y&quot;][:])  # your test set labels</span><br><span class="line"></span><br><span class="line">    classes &#x3D; np.array(test_dataset[&quot;list_classes&quot;][:])  # the list of classes</span><br><span class="line"></span><br><span class="line">    train_set_y_orig &#x3D; train_set_y_orig.reshape((1, train_set_y_orig.shape[0]))</span><br><span class="line">    test_set_y_orig &#x3D; test_set_y_orig.reshape((1, test_set_y_orig.shape[0]))</span><br><span class="line"></span><br><span class="line">    train_set_x_flatten &#x3D; train_set_x_orig.reshape(train_set_x_orig.shape[0], -1).T</span><br><span class="line">    test_set_x_flatten &#x3D; test_set_x_orig.reshape(test_set_x_orig.shape[0], -1).T</span><br><span class="line">    train_set_x &#x3D; train_set_x_flatten &#x2F; 255.</span><br><span class="line">    test_set_x &#x3D; test_set_x_flatten &#x2F; 255.</span><br><span class="line"></span><br><span class="line">    return train_set_x, train_set_y_orig, test_set_x, test_set_y_orig, classes</span><br></pre></td></tr></table></figure>

<h1 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h1><p>初始化主要就是初始化每一层之间的那些权重，即 <strong><em>w</em></strong> 和 <strong><em>b</em></strong> ，TensorFlow等框架的高级API会根据神经元的个数推算每层之间 <strong><em>w</em></strong> 和 <strong><em>b</em></strong> 的形状。</p>
<p>初始化有不同的策略，比如，随机初始化、何凯明提出的一种初始化等等。这里一次性把所有参数都初始化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GRADED FUNCTION: initialize_parameters_he</span><br><span class="line">def initialize_parameters_he(layers_dims):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Arguments:</span><br><span class="line">    layer_dims -- python array (list) containing the size of each layer.</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">    parameters -- python dictionary containing your parameters &quot;W1&quot;, &quot;b1&quot;, ..., &quot;WL&quot;, &quot;bL&quot;:</span><br><span class="line">                    W1 -- weight matrix of shape (layers_dims[1], layers_dims[0])</span><br><span class="line">                    b1 -- bias vector of shape (layers_dims[1], 1)</span><br><span class="line">                    ...</span><br><span class="line">                    WL -- weight matrix of shape (layers_dims[L], layers_dims[L-1])</span><br><span class="line">                    bL -- bias vector of shape (layers_dims[L], 1)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    np.random.seed(3)</span><br><span class="line">    parameters &#x3D; &#123;&#125;</span><br><span class="line">    L &#x3D; len(layers_dims) - 1  # integer representing the number of layers</span><br><span class="line"></span><br><span class="line">    for l in range(1, L + 1):</span><br><span class="line">        ### START CODE HERE ### (≈ 2 lines of code)</span><br><span class="line">        parameters[&#39;W&#39; + str(l)] &#x3D; np.random.randn(layers_dims[l], layers_dims[l - 1]) * np.sqrt(2.0 &#x2F; layers_dims[l - 1])</span><br><span class="line">        parameters[&#39;b&#39; + str(l)] &#x3D; np.zeros((layers_dims[l], 1))</span><br><span class="line">        ### END CODE HERE ###</span><br><span class="line"></span><br><span class="line">    return parameters</span><br></pre></td></tr></table></figure>

<h1 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h1><p>前向传播比较简单，就是：<br>                *<em>W * X + b*</em><br>矩阵相乘的过程，只是激活单元非线性函数再做一个处理。<br>最终到输出层，输出值与真实标签算一个损失。</p>
<p>算损失又有不同的策略，常见的交叉熵损失，平方损失等等。</p>
<p><strong><em>注意：绝对值损失不怎么用的原因就是因为不好求导，而平方便于求导</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def compute_cost(AL, Y):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Implement the cost function defined by equation (7).</span><br><span class="line">    Arguments:</span><br><span class="line">    AL -- probability vector corresponding to your label predictions,</span><br><span class="line">    shape (1, number of examples)</span><br><span class="line">    Y -- true &quot;label&quot; vector (for example: containing 0 if non-cat, 1</span><br><span class="line">    if cat), shape (1, number of examples)</span><br><span class="line">    Returns:</span><br><span class="line">    cost -- cross-entropy cost</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    m &#x3D; Y.shape[1]</span><br><span class="line">    # Compute loss from aL and y.</span><br><span class="line">    ### START CODE HERE ### (￿ 1 lines of code)</span><br><span class="line">    cost &#x3D; -(np.dot(Y,np.log(AL.T))+np.dot(1-Y,np.log(1-AL).T))&#x2F;m</span><br><span class="line">    ### END CODE HERE ###</span><br><span class="line">    cost &#x3D; np.squeeze(cost) # To make sure your cost&#39;s shape is what we expect (e.g. this turns [[17]] into 17)</span><br><span class="line">    assert(cost.shape &#x3D;&#x3D; ())</span><br><span class="line">    return cost</span><br></pre></td></tr></table></figure>

<h1 id="backward"><a href="#backward" class="headerlink" title="backward"></a>backward</h1><p>反向传播应该是神经网络里最难的部分，各种神经网络框架也都屏蔽了反向传播的过程，自动微分机制。</p>
<p>主要用到的数学知识是链式法则，将误差从最后输出层逐渐传播到输入层。</p>
<p>这里不做理论推导，但要知道反向传播的四大公式：<br><img src="https://img-blog.csdnimg.cn/20210423202441706.png" alt="在这里插入图片描述"><br>BP1算出最后一层的误差<br>BP2即可实现传递误差<br>BP3与BP4主要用来更新各层之间的权重。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def L_model_backward(AL, Y, caches):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Implement the backward propagation for the [LINEAR-&gt;RELU] * (L-1) -&gt; LINEAR -&gt; SIGMOID group</span><br><span class="line"></span><br><span class="line">    Arguments:</span><br><span class="line">    AL -- probability vector, output of the forward propagation (L_model_forward())</span><br><span class="line">    Y -- true &quot;label&quot; vector (containing 0 if non-cat, 1 if cat)</span><br><span class="line">    caches -- list of caches containing:</span><br><span class="line">                every cache of linear_activation_forward() with &quot;relu&quot; (it&#39;s caches[l], for l in range(L-1) i.e l &#x3D; 0...L-2)</span><br><span class="line">                the cache of linear_activation_forward() with &quot;sigmoid&quot; (it&#39;s caches[L-1])</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">    grads -- A dictionary with the gradients</span><br><span class="line">             grads[&quot;dA&quot; + str(l)] &#x3D; ...</span><br><span class="line">             grads[&quot;dW&quot; + str(l)] &#x3D; ...</span><br><span class="line">             grads[&quot;db&quot; + str(l)] &#x3D; ...</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    grads &#x3D; &#123;&#125;</span><br><span class="line">    L &#x3D; len(caches)  # the number of layers</span><br><span class="line">    m &#x3D; AL.shape[1]</span><br><span class="line">    Y &#x3D; Y.reshape(AL.shape)  # after this line, Y is the same shape as AL</span><br><span class="line"></span><br><span class="line">    # Initializing the backpropagation</span><br><span class="line">    ### START CODE HERE ### (1 line of code)</span><br><span class="line">    dAL &#x3D; - (np.divide(Y, AL) - np.divide(1 - Y, 1 - AL))</span><br><span class="line">    ### END CODE HERE ###</span><br><span class="line"></span><br><span class="line">    # Lth layer (SIGMOID -&gt; LINEAR) gradients. Inputs: &quot;AL, Y, caches&quot;. Outputs: &quot;grads[&quot;dAL&quot;], grads[&quot;dWL&quot;], grads[&quot;dbL&quot;]</span><br><span class="line">    ### START CODE HERE ### (approx. 2 lines)</span><br><span class="line">    current_cache &#x3D; caches[L - 1]</span><br><span class="line">    grads[&quot;dA&quot; + str(L)], grads[&quot;dW&quot; + str(L)], grads[&quot;db&quot; + str(L)] &#x3D; linear_activation_backward(dAL, current_cache,</span><br><span class="line">                                                                                                  &#39;sigmoid&#39;)</span><br><span class="line">    ### END CODE HERE ###</span><br><span class="line"></span><br><span class="line">    for l in reversed(range(L - 1)):</span><br><span class="line">        # lth layer: (RELU -&gt; LINEAR) gradients.</span><br><span class="line">        # Inputs: &quot;grads[&quot;dA&quot; + str(l + 2)], caches&quot;.</span><br><span class="line">        # Outputs: &quot;grads[&quot;dA&quot; + str(l + 1)] , grads[&quot;dW&quot; + str(l + 1)] , grads[&quot;db&quot; + str(l + 1)]</span><br><span class="line">        ### START CODE HERE ### (approx. 5 lines)</span><br><span class="line">        current_cache &#x3D; caches[l]</span><br><span class="line">        dA_prev_temp, dW_temp, db_temp &#x3D; linear_activation_backward(grads[&quot;dA&quot; + str(l + 2)], current_cache, &#39;relu&#39;)</span><br><span class="line">        grads[&quot;dA&quot; + str(l + 1)] &#x3D; dA_prev_temp</span><br><span class="line">        grads[&quot;dW&quot; + str(l + 1)] &#x3D; dW_temp</span><br><span class="line">        grads[&quot;db&quot; + str(l + 1)] &#x3D; db_temp</span><br><span class="line">        ### END CODE HERE ###</span><br><span class="line"></span><br><span class="line">    return grads</span><br></pre></td></tr></table></figure>

<h1 id="update"><a href="#update" class="headerlink" title="update"></a>update</h1><p>迭代过程中更新参数，逐渐优化模型。优化的策略又有多种，梯度下降、随机梯度下降、小批量梯度下降等等。<br>它们之间的区别主要是用于正向传播的数据量。<br>其中，**<em>小批量的小批量取一，则可理解为随机梯度下降。**</em></p>
<p>大名鼎鼎的优化器有moment、Adam等等，具体知识自行学习。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GRADED FUNCTION: update_parameters</span><br><span class="line">def update_parameters(parameters, grads, learning_rate):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Update parameters using gradient descent</span><br><span class="line">    Arguments:</span><br><span class="line">    parameters -- python dictionary containing your parameters</span><br><span class="line">    grads -- python dictionary containing your gradients, output of</span><br><span class="line">    L_model_backward , →</span><br><span class="line">    Returns:</span><br><span class="line">    parameters -- python dictionary containing your updated parameters</span><br><span class="line">    parameters[&quot;W&quot; + str(l)] &#x3D; ...</span><br><span class="line">    parameters[&quot;b&quot; + str(l)] &#x3D; ...</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    L &#x3D; len(parameters) &#x2F;&#x2F; 2 # number of layers in the neural network</span><br><span class="line">    # Update rule for each parameter. Use a for loop.</span><br><span class="line">    ### START CODE HERE ### (￿ 3 lines of code)</span><br><span class="line">    for l in range(L):</span><br><span class="line">        parameters[&quot;W&quot; + str(l+1)] &#x3D; parameters[&quot;W&quot; + str(l+1)] - learning_rate * grads[&quot;dW&quot; + str(l + 1)]</span><br><span class="line">        parameters[&quot;b&quot; + str(l+1)] &#x3D; parameters[&quot;b&quot; + str(l+1)] - learning_rate * grads[&quot;db&quot; + str(l + 1)]</span><br><span class="line">    ### END CODE HERE ###</span><br><span class="line">    return parameters</span><br></pre></td></tr></table></figure>

<p>是不是感觉也没那么难。这里分享一下代码，及吴恩达教程。仅供参考，自行完善。<br>链接：<a href="https://pan.baidu.com/s/1iGQZyL1HVQak_f7AJD_KRQ">https://pan.baidu.com/s/1iGQZyL1HVQak_f7AJD_KRQ</a><br>提取码：k0hu<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p>
]]></content>
      <tags>
        <tag>神经网络</tag>
        <tag>深度学习</tag>
        <tag>python</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow训练好的模型移植到tensorrt</title>
    <url>/2021/03/25/TensorFlow%E8%AE%AD%E7%BB%83%E5%A5%BD%E7%9A%84%E6%A8%A1%E5%9E%8B%E7%A7%BB%E6%A4%8D%E5%88%B0tensorrt/</url>
    <content><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>需要把深度学习模型搭载到无人机上完成一些探测任务。<br>大疆妙算上预装了tensorrt4，打算将TensorFlow训练好的模型搭载上去。</p>
<h2 id="tensorrt"><a href="#tensorrt" class="headerlink" title="tensorrt"></a>tensorrt</h2><p><a href="https://docs.nvidia.com/deeplearning/tensorrt/archives/#trt_4">tensorrt</a>是个推理阶段的加速框架，支持一些层的操作，不是所有的层（比如<strong>dropout</strong>），不过也可以自定义没有的<strong>op</strong>(算子)，它支持caffe、TensorFlow等。</p>
<h2 id="TensorFlow-gt-tensorrt"><a href="#TensorFlow-gt-tensorrt" class="headerlink" title="TensorFlow=&gt; tensorrt"></a>TensorFlow=&gt; tensorrt</h2><p>用TensorFlow训练保存的模型一般为ckpt的，把他转为tensorrt支持的操作是：</p>
<p><strong>ckpt=&gt;pb=&gt;uff</strong></p>
<p><em>注意：这个过程需要TensorFlow计算图的输入和输出的名字。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X &#x3D; tf.placeholder(tf.float32, [None, 784], name&#x3D;&#39;x-input&#39;)  </span><br><span class="line"># name就是自己起的名字，不起的话，TensorFlow会自己起</span><br></pre></td></tr></table></figure>
<p> <strong>这个代码可以看有哪些节点，一般，第一个就是输入的名字，softmax或者输出层那里就是输出的名字，可以对着代码看一看。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def getinout(input_checkpoint):</span><br><span class="line">    saver &#x3D; tf.train.import_meta_graph(input_checkpoint + &#39;.meta&#39;, clear_devices&#x3D;True)</span><br><span class="line">    graph &#x3D; tf.get_default_graph()</span><br><span class="line">    input_graph_def &#x3D; graph.as_graph_def()</span><br><span class="line">    with tf.Session() as sess:</span><br><span class="line">        file &#x3D; open(&#39;.&#x2F;nodes.txt&#39;, &#39;a+&#39;)</span><br><span class="line"></span><br><span class="line">        for n in tf.get_default_graph().as_graph_def().node:</span><br><span class="line">            file.write(n.name + &#39;\n&#39;)</span><br><span class="line"></span><br><span class="line">        file.close()</span><br></pre></td></tr></table></figure>
<p> <strong>这个代码可以将ckpt转为pb。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def freeze_graph(input_checkpoint, output_graph):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    :param input_checkpoint:</span><br><span class="line">    :param output_graph: PB模型保存路径</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    # checkpoint &#x3D; tf.train.get_checkpoint_state(model_folder) #检查目录下ckpt文件状态是否可用</span><br><span class="line">    # input_checkpoint &#x3D; checkpoint.model_checkpoint_path #得ckpt文件路径</span><br><span class="line"></span><br><span class="line">    # 指定输出的节点名称,该节点名称必须是原模型中存在的节点</span><br><span class="line">    output_node_names &#x3D; &quot;Softmax&quot;</span><br><span class="line">    saver &#x3D; tf.train.import_meta_graph(input_checkpoint + &#39;.meta&#39;, clear_devices&#x3D;True)</span><br><span class="line"></span><br><span class="line">    with tf.Session() as sess:</span><br><span class="line">        saver.restore(sess, input_checkpoint)  # 恢复图并得到数据</span><br><span class="line">        output_graph_def &#x3D; tf.graph_util.convert_variables_to_constants(  # 模型持久化，将变量值固定</span><br><span class="line">            sess&#x3D;sess,</span><br><span class="line">            input_graph_def&#x3D;sess.graph_def,  # 等于:sess.graph_def</span><br><span class="line">            output_node_names&#x3D;output_node_names.split(&quot;,&quot;))  # 如果有多个输出节点，以逗号隔开</span><br><span class="line"></span><br><span class="line">        with tf.gfile.GFile(output_graph, &quot;wb&quot;) as f:  # 保存模型</span><br><span class="line">            f.write(output_graph_def.SerializeToString())  # 序列化输出</span><br><span class="line">        print(&quot;%d ops in the final graph.&quot; % len(output_graph_def.node))  # 得到当前图有几个操作节点</span><br></pre></td></tr></table></figure>
<p><strong>这个代码可以加载pb测试</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from tensorflow.examples.tutorials.mnist import input_data</span><br><span class="line">import numpy as np</span><br><span class="line">import uff</span><br><span class="line"></span><br><span class="line"># 下载数据集 数字1到10</span><br><span class="line">mnist &#x3D; input_data.read_data_sets(&#39;MNIST_data&#39;, one_hot&#x3D;True)</span><br><span class="line"></span><br><span class="line">def freeze_graph_test(pb_path):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    :param pb_path:pb文件的路径</span><br><span class="line">    :param image_path:测试图片的路径</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    with tf.Graph().as_default():</span><br><span class="line">        output_graph_def &#x3D; tf.GraphDef()</span><br><span class="line">        with open(pb_path, &quot;rb&quot;) as f:</span><br><span class="line">            output_graph_def.ParseFromString(f.read())</span><br><span class="line">            tf.import_graph_def(output_graph_def, name&#x3D;&quot;&quot;)</span><br><span class="line">        with tf.Session() as sess:</span><br><span class="line">            sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">            # 定义输入的张量名称,对应网络结构的输入张量</span><br><span class="line">            # input:0作为输入图像,keep_prob:0作为dropout的参数,测试时值为1,is_training:0训练参数</span><br><span class="line">            input_image_tensor &#x3D; sess.graph.get_tensor_by_name(&quot;x-input:0&quot;)</span><br><span class="line">            # 定义输出的张量名称</span><br><span class="line">            output_tensor_name &#x3D; sess.graph.get_tensor_by_name(&quot;Softmax:0&quot;)</span><br><span class="line"></span><br><span class="line">            # 读取测试图片，num可以随便改</span><br><span class="line">            # THIS WILL LOAD ONE TRAINING EXAMPLE</span><br><span class="line">            num &#x3D; 600</span><br><span class="line">            x_train &#x3D; mnist.test.images[num , :].reshape(1, 784)</span><br><span class="line">            y_train &#x3D; mnist.test.labels[num , :]</span><br><span class="line"></span><br><span class="line">            np.set_printoptions(precision&#x3D;1)</span><br><span class="line">            np.set_printoptions(suppress&#x3D;True)</span><br><span class="line">            # THIS GETS OUR LABEL AS A INTEGER</span><br><span class="line">            label &#x3D; y_train.argmax()</span><br><span class="line">            </span><br><span class="line">            out &#x3D; sess.run(output_tensor_name, feed_dict&#x3D;&#123;input_image_tensor: x_train&#125;)</span><br><span class="line">            print(&quot;out:&#123;&#125;&quot;.format(out))</span><br><span class="line">            score &#x3D; tf.nn.softmax(out, name&#x3D;&#39;pre&#39;)</span><br><span class="line">            class_id &#x3D; tf.argmax(score, 1)</span><br><span class="line">            print(&quot;pre class_id:&#123;&#125;&quot;.format(sess.run(class_id)))</span><br><span class="line">            # plt.title(&#39;Prediction: %d Label: %s&#39; % (1, label))</span><br><span class="line">            plt.imshow(x_train.reshape([28, 28]), cmap&#x3D;plt.get_cmap(&#39;gray_r&#39;))</span><br><span class="line">            plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # 输出pb模型的路径</span><br><span class="line">    out_pb_path &#x3D; &quot;models&#x2F;frozen_model.pb&quot;</span><br><span class="line"></span><br><span class="line">    freeze_graph_test(pb_path&#x3D;out_pb_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>可视化模型</strong><br><a href="https://netron.app/">在线可视化模型</a>,导入ckpt或者pb就可以看类似流程图的计算图。<br><img src="https://img-blog.csdnimg.cn/2021032521174467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20210325211827239.png" alt="在这里插入图片描述"><br>这是pb的图，比ckpt简洁太多了！</p>
<h4 id="pb-gt-uff"><a href="#pb-gt-uff" class="headerlink" title="pb=&gt;uff"></a>pb=&gt;uff</h4><p>教程说是用tensorrt带的<strong>convert-to-uff</strong>就转了。。。我TM找了半天根本没有，后来也发现秒算上的tensorrt根本就没有Python模块，都是c++的API。<br>**<em>解决：**</em><br>英伟达官网下载了一个win10的tensorrt7，<br><img src="https://img-blog.csdnimg.cn/20210325205317607.png" alt="在这里插入图片描述"><br>这里面有两个轮子，安装好之后，去uff的安装目录下就会有<strong>convert_to_uff.py</strong>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(tf-gpu) D:\Anaconda\envs\tf-gpu\Lib\site-packages\uff\bin&gt;python convert_to_uff.py frozen_model.pb</span><br></pre></td></tr></table></figure>
<p>这样就有了uff文件了。</p>
<h2 id="tensorrt样例"><a href="#tensorrt样例" class="headerlink" title="tensorrt样例"></a>tensorrt样例</h2><p>tensorrt下的<strong>samples</strong>里有加载TensorFlow模型的样例<strong>sampleUffMNIST</strong>。改一改里面加载<strong>uff</strong>文件的<strong>cpp</strong>代码基本就行了。<br>就在这个目录下<strong>make</strong>一下，就会在tensorrt的<strong>bin</strong>目录下生成可执行的文件了。<br>跑一下，试一试成功没有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@+  :@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@%&#x3D; :. --%@@@@@</span><br><span class="line">@@@@@@@@@@@@@%. -@&#x3D; - :@@@@@</span><br><span class="line">@@@@@@@@@@@@@: -@@#%@@ #@@@@</span><br><span class="line">@@@@@@@@@@@@: #@@@@@@@-#@@@@</span><br><span class="line">@@@@@@@@@@@&#x3D; #@@@@@@@@&#x3D;%@@@@</span><br><span class="line">@@@@@@@@@@&#x3D; #@@@@@@@@@:@@@@@</span><br><span class="line">@@@@@@@@@+ -@@@@@@@@@%.@@@@@</span><br><span class="line">@@@@@@@@@::@@@@@@@@@@+-@@@@@</span><br><span class="line">@@@@@@@@-.%@@@@@@@@@@.*@@@@@</span><br><span class="line">@@@@@@@@ *@@@@@@@@@@@ *@@@@@</span><br><span class="line">@@@@@@@% %@@@@@@@@@%.-@@@@@@</span><br><span class="line">@@@@@@@:*@@@@@@@@@+. %@@@@@@</span><br><span class="line">@@@@@@# @@@@@@@@@# .*@@@@@@@</span><br><span class="line">@@@@@@# @@@@@@@@&#x3D;  +@@@@@@@@</span><br><span class="line">@@@@@@# @@@@@@%. .+@@@@@@@@@</span><br><span class="line">@@@@@@# @@@@@*. -%@@@@@@@@@@</span><br><span class="line">@@@@@@# ---    &#x3D;@@@@@@@@@@@@</span><br><span class="line">@@@@@@#      *%@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@%: -&#x3D;%@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">10 eltCount</span><br><span class="line">--- OUTPUT ---</span><br><span class="line">0 &#x3D;&gt; 3.41521	 : ***</span><br><span class="line">1 &#x3D;&gt; -11.118	 : </span><br><span class="line">2 &#x3D;&gt; -2.60688	 : </span><br><span class="line">3 &#x3D;&gt; -5.37433	 : </span><br><span class="line">4 &#x3D;&gt; -14.5769	 : </span><br><span class="line">5 &#x3D;&gt; -0.0877042	 : </span><br><span class="line">6 &#x3D;&gt; -1.25683	 : </span><br><span class="line">7 &#x3D;&gt; -11.7811	 : </span><br><span class="line">8 &#x3D;&gt; -5.30992	 : </span><br><span class="line">9 &#x3D;&gt; -8.00871	 : </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@+ @@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@. @@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@- @@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@#  @@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@#  *@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@  :@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@&#x3D; .@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@#  %@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@% .@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@%  %@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@%  %@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@&#x3D; +@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@* -@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@*  @@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@  @@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@  *@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@  *@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@  *@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@  *@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@* @@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">10 eltCount</span><br><span class="line">--- OUTPUT ---</span><br><span class="line">0 &#x3D;&gt; -10.9159	 : </span><br><span class="line">1 &#x3D;&gt; 3.85835	 : ***</span><br><span class="line">2 &#x3D;&gt; -5.38455	 : </span><br><span class="line">3 &#x3D;&gt; -3.43404	 : </span><br><span class="line">4 &#x3D;&gt; -5.66351	 : </span><br><span class="line">5 &#x3D;&gt; -5.13578	 : </span><br><span class="line">6 &#x3D;&gt; -3.38536	 : </span><br><span class="line">7 &#x3D;&gt; -7.77694	 : </span><br><span class="line">8 &#x3D;&gt; -0.558315	 : </span><br><span class="line">9 &#x3D;&gt; -4.30673	 : </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样，自己训练的TensorFlow模型就能在无人机上跑起来了！</p>
]]></content>
      <tags>
        <tag>tensorflow</tag>
        <tag>深度学习</tag>
        <tag>tensorrt</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib画图</title>
    <url>/2021/03/20/matplotlib%E7%94%BB%E5%9B%BE/</url>
    <content><![CDATA[<p>结合注释看吧！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">fig &#x3D; plt.figure()</span><br><span class="line">#参数的意思是画N x N的图，第三个参数用来索引第几张图</span><br><span class="line">ax &#x3D; fig.add_subplot(1,1,1)</span><br><span class="line">#自定义自己的坐标刻度</span><br><span class="line">ax.set_xticks([0,2,4,6,8,10,12,14,16,18,20])</span><br><span class="line">ax.set_yticks([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0])</span><br><span class="line">#用点画图，两个list个数当然要相等，注意，list里数字不要有什么引号，我被坑了半天，</span><br><span class="line">#因为echarts画图时，string&#x2F;float这些可以混用</span><br><span class="line">ax.plot([0,1,2,4,6,8,10,12,14,16,18,20],[0.1162, 0.74,0.86, 0.89,0.91, 0.91,0.92,0.92,0.92,0.93,0.93,0.93])</span><br><span class="line">#多画几条线，会自动区分颜色</span><br><span class="line">ax.plot([0,1,2,4,6,8,10,12,14,16,18,20],[0.1562, 0.79,0.86, 0.90,0.92, 0.93,0.93,0.94,0.94,0.94,0.95,0.95])</span><br><span class="line">#按ax的顺序，给上小标记</span><br><span class="line">plt.legend((&#39;one&#39;,&#39;two&#39;))</span><br><span class="line">#设置标题</span><br><span class="line"># fig.suptitle(&#39;figure title demo&#39;, fontsize &#x3D; 14, fontweight&#x3D;&#39;bold&#39;)</span><br><span class="line"># # ax.set_title(&quot;axes title&quot;)</span><br><span class="line">#设置横纵坐标</span><br><span class="line">ax.set_xlabel(&quot;Epoch&quot;)</span><br><span class="line">ax.set_ylabel(&quot;Test Accuracy&quot;)</span><br><span class="line">#保存</span><br><span class="line">plt.savefig(&#39;mmlp.png&#39;)</span><br><span class="line">plt.savefig(&#39;mmlp.pdf&#39;)</span><br><span class="line">plt.show()</span><br><span class="line">plt.close()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>python</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>RNN</title>
    <url>/2021/02/04/RNN/</url>
    <content><![CDATA[<p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/RNN-unrolled.png" alt="An unrolled recurrent neural network."></p>
<p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-SimpleRNN.png" alt="img"></p>
<p><img src="https://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-chain.png" alt="A LSTM neural network."></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>anaconda的使用</title>
    <url>/2021/01/03/anaconda%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>世上最难过的事就是想法有了，代码写不出来。。。</p>
</blockquote>
<h2 id="anaconda其实和springboot差不多，"><a href="#anaconda其实和springboot差不多，" class="headerlink" title="anaconda其实和springboot差不多，"></a><strong>anaconda其实和springboot差不多，</strong></h2><p>用过springboot的朋友就知道，springboot导入一个starter依赖，其实就帮你自动导入了一堆的依赖jar包，省去了当年ssh、ssm等自己整合依赖包的麻烦。</p>
<h2 id="python与anaconda的关系"><a href="#python与anaconda的关系" class="headerlink" title="python与anaconda的关系"></a>python与anaconda的关系</h2><p>python等各种编程语言一个永恒的话题就是版本问题，想当年就是因为版本不兼容引发的各种错误，一找就是一天。<br>Java里spring系列就是很好的全家桶。<br>python里，anaconda就是很好的全家桶。<br>用人家写的python项目，版本可能不一样，这时候就可以用anaconda很方便的创建需要的虚拟环境。<br>pycharm里设置用相应的环境运行代码就行了，简直不要太爽！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda create -n 名字 python&#x3D;3.6（版本）</span><br><span class="line">activate 虚拟环境名字</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>python</tag>
        <tag>anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow梯度处理</title>
    <url>/2021/01/03/tensorflow%E6%A2%AF%E5%BA%A6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="最简单那种自带的梯度裁剪就不说了，这里说的是TensorFlow没有我们想要的操作。"><a href="#最简单那种自带的梯度裁剪就不说了，这里说的是TensorFlow没有我们想要的操作。" class="headerlink" title="最简单那种自带的梯度裁剪就不说了，这里说的是TensorFlow没有我们想要的操作。"></a>最简单那种自带的梯度裁剪就不说了，这里说的是TensorFlow没有我们想要的操作。</h3><h1 id="minimize"><a href="#minimize" class="headerlink" title="minimize()"></a>minimize()</h1><p><code>minimize()</code>实际上包含了两个步骤，即</p>
<p>  <code>compute_gradients</code>,用于计算梯度，</p>
<p>  和</p>
<p>  <code>apply_gradients</code>，用于使用计算得到的梯度来更新对应的variable。</p>
<p>  建议使用<a href="https://blog.csdn.net/songsongL/article/details/112151892">anaconda</a>创建虚拟环境，以免玩坏了，或者出现各种bug。初次玩总会遇到莫名其妙的问题！</p>
<h3 id="利用TensorFlow自定义op的机制（要在Linux环境下进行）定义自己处理梯度的方法，相当于在上面两步间插入一个自定义的操作，把处理后的值apply就行。"><a href="#利用TensorFlow自定义op的机制（要在Linux环境下进行）定义自己处理梯度的方法，相当于在上面两步间插入一个自定义的操作，把处理后的值apply就行。" class="headerlink" title="利用TensorFlow自定义op的机制（要在Linux环境下进行）定义自己处理梯度的方法，相当于在上面两步间插入一个自定义的操作，把处理后的值apply就行。"></a>利用TensorFlow自定义op的机制（要在Linux环境下进行）定义自己处理梯度的方法，相当于在上面两步间插入一个自定义的操作，把处理后的值apply就行。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;zero_out.cc 文件</span><br><span class="line">#include &quot;tensorflow&#x2F;core&#x2F;framework&#x2F;op.h&quot;</span><br><span class="line">#include &quot;tensorflow&#x2F;core&#x2F;framework&#x2F;shape_inference.h&quot;</span><br><span class="line">#include &quot;tensorflow&#x2F;core&#x2F;framework&#x2F;op_kernel.h&quot;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;ctime&gt; </span><br><span class="line">using namespace tensorflow;</span><br><span class="line"></span><br><span class="line">double RefactorinGradient(double num) &#123;</span><br><span class="line">&#x2F;&#x2F;something</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">REGISTER_OP(&quot;ZeroOut&quot;)</span><br><span class="line">    .Input(&quot;to_zero: float&quot;)</span><br><span class="line">    .Output(&quot;zeroed: float&quot;)</span><br><span class="line">    .SetShapeFn([](::tensorflow::shape_inference::InferenceContext* c) &#123;</span><br><span class="line">      c-&gt;set_output(0, c-&gt;input(0));</span><br><span class="line">      return Status::OK();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">class ZeroOutOp : public OpKernel &#123;</span><br><span class="line"> public:</span><br><span class="line">  explicit ZeroOutOp(OpKernelConstruction* context) : OpKernel(context) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  void Compute(OpKernelContext* context) override &#123;</span><br><span class="line">    &#x2F;&#x2F; 将输入 tensor 从 context 中取出。</span><br><span class="line">    const Tensor&amp; input_tensor &#x3D; context-&gt;input(0);</span><br><span class="line">    auto input &#x3D; input_tensor.flat&lt;float&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建一个 ouput_tensor, 使用 context-&gt;allocate_ouput() 给它分配空间。</span><br><span class="line">    Tensor* output_tensor &#x3D; NULL;</span><br><span class="line">    OP_REQUIRES_OK(context, context-&gt;allocate_output(0, input_tensor.shape(),</span><br><span class="line">                                                     &amp;output_tensor));</span><br><span class="line">    auto output_flat &#x3D; output_tensor-&gt;flat&lt;float&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Set all but the first element of the output tensor to 0.</span><br><span class="line">    const int N &#x3D; input.size();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">      output_flat(i) &#x3D; RefactorinGradient(input(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">REGISTER_KERNEL_BUILDER(Name(&quot;ZeroOut&quot;).Device(DEVICE_CPU), ZeroOutOp);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TF_CFLAGS&#x3D;( $(python -c &#39;import tensorflow as tf; print(&quot; &quot;.join(tf.sysconfig.get_compile_flags()))&#39;) )</span><br><span class="line"></span><br><span class="line">TF_LFLAGS&#x3D;( $(python -c &#39;import tensorflow as tf; print(&quot; &quot;.join(tf.sysconfig.get_link_flags()))&#39;) )</span><br><span class="line"></span><br><span class="line">sudo g++ -std&#x3D;c++11 -shared zero_out.cc -o zero_out.so -fPIC -D_GLIBCXX_USE_CXX11_ABI&#x3D;0 $&#123;TF_CFLAGS[@]&#125; $&#123;TF_LFLAGS[@]&#125; -O2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>百度的paddlepaddle深度学习框架可以在Python端自定义，相对简单一点，但性能肯定是没有c++的好</em></p>
]]></content>
      <tags>
        <tag>tensorflow</tag>
        <tag>深度学习</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow</title>
    <url>/2021/01/02/tensorflow/</url>
    <content><![CDATA[<h1 id="1-tf-clip-by-value"><a href="#1-tf-clip-by-value" class="headerlink" title="1.tf.clip_by_value"></a>1.tf.clip_by_value</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.clip_by_value(   </span><br><span class="line">    t,    </span><br><span class="line">    clip_value_min, </span><br><span class="line">    clip_value_max,   </span><br><span class="line">    name=<span class="literal">None</span> </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>Returns:<code>A clipped Tensor.</code></p>
<p>输入一个张量t，把t中的每一个元素的值都压缩在clip_value_min和clip_value_max之间。小于min的让它等于min，大于max的元素的值等于max。</p>
<h1 id="2-tf-clip-by-norm"><a href="#2-tf-clip-by-norm" class="headerlink" title="2.tf.clip_by_norm"></a>2.tf.clip_by_norm</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.clip_by_norm(  </span><br><span class="line">    t,    </span><br><span class="line">    clip_norm,    </span><br><span class="line">    axes=<span class="literal">None</span>,  </span><br><span class="line">    name=<span class="literal">None</span> </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Returns:<code>A clipped Tensor.</code></p>
<p>指对梯度进行裁剪，通过控制梯度的最大范式，防止梯度爆炸的问题，是一种比较常用的梯度规约的方式。</p>
<ul>
<li><p><strong>t</strong>: 输入tensor，也可以是list</p>
</li>
<li><p><strong>clip_norm</strong>: 一个具体的数，如果<br>$$<br>l_2norm(t)≤l_2norm(clipnorm)<br>$$<br> 则t不变化；否则<br>$$<br>t=\frac{t∗clipnorm}{l_2norm(t)}<br>$$</p>
</li>
</ul>
<h1 id="3-minimize"><a href="#3-minimize" class="headerlink" title="3.minimize()"></a>3.minimize()</h1><p>  由源代码可以知道<code>minimize()</code>实际上包含了两个步骤，即</p>
<p>  <code>compute_gradients</code>,用于计算梯度，</p>
<p>  和</p>
<p>  <code>apply_gradients</code>，用于使用计算得到的梯度来更新对应的variable。</p>
<h1 id="4-EXAMPLE"><a href="#4-EXAMPLE" class="headerlink" title="4.EXAMPLE"></a>4.EXAMPLE</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">x = tf.Variable(initial_value=<span class="number">50.</span>, dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">w = tf.Variable(initial_value=<span class="number">10.</span>, dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">y = w*x</span><br><span class="line"></span><br><span class="line">opt = tf.train.GradientDescentOptimizer(<span class="number">0.5</span>)</span><br><span class="line">grads_vals = opt.compute_gradients(y, [w])</span><br><span class="line"></span><br><span class="line"><span class="comment">#list包括的是：梯度和更新变量的元组对</span></span><br><span class="line">capped_gvs = [(tf.clip_by_value(grad, <span class="number">2</span>, <span class="number">2</span>), var)</span><br><span class="line">             <span class="keyword">for</span> grad, var <span class="keyword">in</span> grads_vals]</span><br><span class="line"></span><br><span class="line"> <span class="comment">#执行对应变量的更新梯度操作</span></span><br><span class="line">training_op = opt.apply_gradients(capped_gvs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):  </span><br><span class="line">        print(sess.run(grads_vals))</span><br><span class="line">        print(sess.run(capped_gvs))</span><br><span class="line">        sess.run(training_op)</span><br><span class="line">        print(sess.run([x, w, y]))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p>[(50.0, 10.0)]<br>[(2.0, 10.0)]<br>[50.0, 9.0, 450.0]<br>[(50.0, 9.0)]<br>[(2.0, 9.0)]<br>[50.0, 8.0, 400.0]<br>[(50.0, 8.0)]<br>[(2.0, 8.0)]<br>[50.0, 7.0, 350.0]<br>[(50.0, 7.0)]<br>[(2.0, 7.0)]<br>[50.0, 6.0, 300.0]<br>[(50.0, 6.0)]<br>[(2.0, 6.0)]</p>
<p>…</p>
<p>…</p>
</blockquote>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>边框</title>
    <url>/2020/11/21/%E8%BE%B9%E6%A1%86/</url>
    <content><![CDATA[  <p style=border-style:none>无边框</p>
  <p style=border-style:dotted>点线式边框</p>
  <p style=border-style:dashed>破折线式边框</p>
  <p style=border-style:solid>直线式边框</p>
  <p style=border-style:double>双线式边框</p>
  <p style=border-style:groove>槽线式边框</p>
  <p style=border-style:ridge>脊线式边框</p>
  <p style=border-style:inset>内嵌效果的边框</p>
  <p style=border-style:outset>突起效果的边框</p>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>ENGLISH</title>
    <url>/2020/11/19/ENGLISH/</url>
    <content><![CDATA[<a id="more"></a>

<p>eliminate        消除、排除</p>
<p>annual leave bonus        年假奖金</p>
<p>startup company        创业公司</p>
<p>driver’s theory exam        驾照理论考试</p>
<p>underrestmate        低估</p>
<p>I’ve got accepted to the…        被录取</p>
<p>I have a good chance of winning a scholarship</p>
<p>awesome         很棒</p>
<p>percentage        百分比</p>
<p>reproduce quickly        繁殖快</p>
<p>insect        昆虫</p>
<p>insert        </p>
<p>fight infections        对抗感染</p>
<p>pervasive</p>
<p>the pervasiveness of …        常态、什么什么的普遍性</p>
<p>fostering businesses         促进企业</p>
<p>extraction        提取</p>
<p>limited scope        有限的范围</p>
<p>divided into four categories        分为四类</p>
<p>unauthorised disclosure of information         未经授权的披露信息</p>
<p>leakage        泄漏</p>
<p>disclosure        披露</p>
<p>drawn extensive attention        引起广泛关注</p>
<p>ambiguous        模棱两可</p>
<p>supervised and <em>unsupervised</em>        监督和非监督</p>
<p>mapping function <em>f</em> (<em>X</em>)        映射函数</p>
<p>presents some challenges such as…        提出了/带来了一些挑战</p>
<p>proposed two approaches        提出了两种方法</p>
<p> render two important definition        给出两个重要的定义</p>
<p>statistical distribution        统计分布</p>
<p>store or buffered        存储、缓存</p>
<p>presented a report        提交了一份报告</p>
<p>tourism sector        旅游业</p>
<p>Scalability        可伸缩性</p>
<p>different loads        不同的负载</p>
<p>infrastructure        基础设施</p>
<p>encrypted/ decrypt        加密/解密</p>
<p>An emerging fifield        一个新兴的领域</p>
<p>genome sequencing        基金组测序</p>
<p>semihonest        半诚实的</p>
<p>fake        假的</p>
<p>extensive research        广泛的研究</p>
<p>prerequisite        先决条件</p>
<p>confidential information        机密信息</p>
<p>reluctant        不情愿的</p>
<p>illustrates        阐明</p>
<p>relevance        相关性</p>
<p>Some methods suggested that         一些方法表明</p>
<p>distortion        失真</p>
<p>novel idea         新思路</p>
<p>opens up several promising avenues        开辟了几个有希望的途径</p>
<p>workers strikes        工人罢工</p>
<p>mission        使命、任务</p>
<p>keep in touch with everyone through Facebook</p>
<p>peek at        窥视</p>
<p>adversary        对手、敌手</p>
<p>vice versa.        反之亦然</p>
<p>intelligence community        情报部门</p>
<p>counterintelligence        反情报</p>
<p>high-definition        高清</p>
<p>mission        任务</p>
<p>intuition    直觉</p>
<p>==============================================================</p>
<p>take sth into consideration        考虑。。。在内</p>
<p>inject new growth momentum for</p>
<p>tourist attractions nationwide        全国旅游景点</p>
<p>deputy director        副职位</p>
<p>other-worldly        超凡脱俗</p>
<p>architectural project        建筑项目</p>
<p>sustain        持久的、持续的</p>
<p>pass down multiple generations        代代相传</p>
<p>nonpartisan        无党派的</p>
<p>bipartisan         两党的</p>
<p>poll        投票、民意调查</p>
<p>plunged from A to B        暴跌 ; 骤降</p>
<p>abysmal        糟糕的</p>
<p>pandemic        流行病</p>
<p>potential fraud        潜在欺骗</p>
<p>postpone deadline        推迟截止时间</p>
<p>restriction        限制、约束</p>
<p>stop-gap measure        权宜之计/折中方案</p>
<p>trade-off</p>
<p>unemployment aid        失业救济金</p>
<p>coronavirus pandemic        病毒流行</p>
<p>news conference        新闻发布会</p>
<p>harass        骚扰</p>
<p>misled        误导</p>
<p>testimony        证词</p>
<p>have much room for improvement        有很大的改进空间</p>
<p>have no room for flexibility         没有灵活的空间</p>
<p>temperamental        反复无常的、性情的</p>
<p>stereotype        刻板印象</p>
<p>fluctuate        流动、波动</p>
<p>monopoly        垄断</p>
<p>====================================================</p>
<p>take it for granted        想当然</p>
<p>find fault with        找茬</p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/11/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>猫狗识别</title>
    <url>/2020/07/18/%E7%8C%AB%E7%8B%97%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>整理的网上资源，方便大家学习，也不知道哪哪看到的了！</p>
<h1 id="tensorflow"><a href="#tensorflow" class="headerlink" title="tensorflow"></a>tensorflow</h1><p><img src="https://img-blog.csdnimg.cn/20200718095713376.png" alt="在这里插入图片描述"><br>input_data.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import os</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">#读取所有的训练集</span><br><span class="line">def get_files(file_dir):</span><br><span class="line">    cats &#x3D; []</span><br><span class="line">    label_cats &#x3D; []</span><br><span class="line">    dogs &#x3D; []</span><br><span class="line">    label_dogs &#x3D; []</span><br><span class="line">    for file in os.listdir(file_dir):</span><br><span class="line">        name &#x3D; file.split(sep&#x3D;&#39;.&#39;)</span><br><span class="line">        if &#39;cat&#39; in name[0]:</span><br><span class="line">            cats.append(file_dir + file)</span><br><span class="line">            label_cats.append(0)</span><br><span class="line">        elif &#39;dog&#39; in name[0]:</span><br><span class="line">            dogs.append(file_dir + file)</span><br><span class="line">            label_dogs.append(1)</span><br><span class="line">        image_list &#x3D; np.hstack((cats, dogs))</span><br><span class="line">        label_list &#x3D; np.hstack((label_cats, label_dogs))</span><br><span class="line">    # print(&#39;There are %d cats\nThere are %d dogs&#39; %(len(cats), len(dogs)))</span><br><span class="line">	#两行多列</span><br><span class="line">    temp &#x3D; np.array([image_list, label_list])</span><br><span class="line">   # 转置矩阵，两列多行</span><br><span class="line">    temp &#x3D; temp.transpose()</span><br><span class="line">    # 打乱顺序</span><br><span class="line">    np.random.shuffle(temp)</span><br><span class="line"></span><br><span class="line">    # 取出第一个元素为 image 第二个元素为 label</span><br><span class="line">    image_list &#x3D; list(temp[:, 0])</span><br><span class="line">    label_list &#x3D; list(temp[:, 1])</span><br><span class="line">    label_list &#x3D; [int(i) for i in label_list]</span><br><span class="line">    return image_list, label_list</span><br><span class="line"></span><br><span class="line">#自定义训练批次</span><br><span class="line"># image_W ,image_H 指定图片大小，batch_size 每批读取的个数 ，capacity队列中 最多容纳元素的个数</span><br><span class="line">def get_batch(image, label, image_W, image_H, batch_size, capacity):</span><br><span class="line">    # 转换数据</span><br><span class="line">    image &#x3D; tf.cast(image, tf.string)</span><br><span class="line">    label &#x3D; tf.cast(label, tf.int32)</span><br><span class="line"></span><br><span class="line">    # 将image 和 label 放倒队列里</span><br><span class="line">    input_queue &#x3D; tf.train.slice_input_producer([image, label])</span><br><span class="line">    label &#x3D; input_queue[1]</span><br><span class="line">    # 读取图片的全部信息</span><br><span class="line">    image_contents &#x3D; tf.read_file(input_queue[0])</span><br><span class="line">    # 把图片解码，3 为彩色图片</span><br><span class="line">    image &#x3D; tf.image.decode_jpeg(image_contents, channels&#x3D;3)</span><br><span class="line">    # 将图片以图片中心进行裁剪或者扩充为 指定的image_W，image_H</span><br><span class="line">    image &#x3D; tf.image.resize_image_with_crop_or_pad(image, image_W, image_H)</span><br><span class="line">    # 对数据进行标准化,就是减去它的均值，除以他的方差</span><br><span class="line">    image &#x3D; tf.image.per_image_standardization(image)</span><br><span class="line"></span><br><span class="line">    # 生成批次 </span><br><span class="line">    image_batch, label_batch &#x3D; tf.train.batch([image, label], batch_size&#x3D;batch_size, num_threads&#x3D;64, capacity&#x3D;capacity)</span><br><span class="line"></span><br><span class="line">    # 重新定义下 label_batch 的形状</span><br><span class="line">    label_batch &#x3D; tf.reshape(label_batch, [batch_size])</span><br><span class="line">    # 转化图片</span><br><span class="line">    image_batch &#x3D; tf.cast(image_batch, tf.float32)</span><br><span class="line">    return image_batch, label_batch</span><br></pre></td></tr></table></figure>
<p>model.py:<br><img src="https://img-blog.csdnimg.cn/20200718101126891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># 结构</span><br><span class="line"># conv1   卷积层 1</span><br><span class="line"># pooling1_lrn  池化层 1</span><br><span class="line"># conv2  卷积层 2</span><br><span class="line"># pooling2_lrn 池化层 2</span><br><span class="line"># local3 全连接层 1</span><br><span class="line"># local4 全连接层 2</span><br><span class="line"># softmax 全连接层 3</span><br><span class="line">def inference(images, batch_size, n_classes):</span><br><span class="line">    with tf.variable_scope(&#39;conv1&#39;) as scope:</span><br><span class="line">        # 3*3 的卷积核，图片厚度是3，16个featuremap</span><br><span class="line">        #即卷积后变细长</span><br><span class="line">        weights &#x3D; tf.get_variable(&#39;weights&#39;,</span><br><span class="line">                                  shape&#x3D;[3, 3, 3, 16],</span><br><span class="line">                                  dtype&#x3D;tf.float32,</span><br><span class="line">                                  initializer&#x3D;tf.truncated_normal_initializer(stddev&#x3D;0.1, dtype&#x3D;tf.float32))</span><br><span class="line">        biases &#x3D; tf.get_variable(&#39;biases&#39;,</span><br><span class="line">                                 shape&#x3D;[16],</span><br><span class="line">                                 dtype&#x3D;tf.float32,</span><br><span class="line">                                 initializer&#x3D;tf.constant_initializer(0.1))</span><br><span class="line">        conv &#x3D; tf.nn.conv2d(images, weights, strides&#x3D;[1, 1, 1, 1], padding&#x3D;&#39;SAME&#39;)</span><br><span class="line">        pre_activation &#x3D; tf.nn.bias_add(conv, biases)</span><br><span class="line">        conv1 &#x3D; tf.nn.relu(pre_activation, name&#x3D;scope.name)</span><br><span class="line"></span><br><span class="line">    with tf.variable_scope(&#39;pooling1_lrn&#39;) as scope:</span><br><span class="line">        pool1 &#x3D; tf.nn.max_pool(conv1, ksize&#x3D;[1, 3, 3, 1], strides&#x3D;[1, 2, 2, 1], padding&#x3D;&#39;SAME&#39;, name&#x3D;&#39;pooling1&#39;)</span><br><span class="line">        norm1 &#x3D; tf.nn.lrn(pool1, depth_radius&#x3D;4, bias&#x3D;1.0, alpha&#x3D;0.001 &#x2F; 9.0, beta&#x3D;0.75, name&#x3D;&#39;norm1&#39;)</span><br><span class="line"></span><br><span class="line">    with tf.variable_scope(&#39;conv2&#39;) as scope:</span><br><span class="line">        weights &#x3D; tf.get_variable(&#39;weights&#39;,</span><br><span class="line">                                  shape&#x3D;[3, 3, 16, 16],</span><br><span class="line">                                  dtype&#x3D;tf.float32,</span><br><span class="line">                                  initializer&#x3D;tf.truncated_normal_initializer(stddev&#x3D;0.1, dtype&#x3D;tf.float32))</span><br><span class="line">        biases &#x3D; tf.get_variable(&#39;biases&#39;,</span><br><span class="line">                                 shape&#x3D;[16],</span><br><span class="line">                                 dtype&#x3D;tf.float32,</span><br><span class="line">                                 initializer&#x3D;tf.constant_initializer(0.1))</span><br><span class="line">        conv &#x3D; tf.nn.conv2d(norm1, weights, strides&#x3D;[1, 1, 1, 1], padding&#x3D;&#39;SAME&#39;)</span><br><span class="line">        pre_activation &#x3D; tf.nn.bias_add(conv, biases)</span><br><span class="line">        conv2 &#x3D; tf.nn.relu(pre_activation, name&#x3D;&#39;conv2&#39;)</span><br><span class="line"></span><br><span class="line">        # pool2 and norm2</span><br><span class="line">    with tf.variable_scope(&#39;pooling2_lrn&#39;) as scope:</span><br><span class="line">        norm2 &#x3D; tf.nn.lrn(conv2, depth_radius&#x3D;4, bias&#x3D;1.0, alpha&#x3D;0.001 &#x2F; 9.0, beta&#x3D;0.75, name&#x3D;&#39;norm2&#39;)</span><br><span class="line">        pool2 &#x3D; tf.nn.max_pool(norm2, ksize&#x3D;[1, 3, 3, 1], strides&#x3D;[1, 1, 1, 1], padding&#x3D;&#39;SAME&#39;, name&#x3D;&#39;pooling2&#39;)</span><br><span class="line"></span><br><span class="line">    with tf.variable_scope(&#39;local3&#39;) as scope:</span><br><span class="line">        reshape &#x3D; tf.reshape(pool2, shape&#x3D;[batch_size, -1])</span><br><span class="line">        dim &#x3D; reshape.get_shape()[1].value</span><br><span class="line">        weights &#x3D; tf.get_variable(&#39;weights&#39;,</span><br><span class="line">                                  shape&#x3D;[dim, 128],</span><br><span class="line">                                  dtype&#x3D;tf.float32,</span><br><span class="line">                                  initializer&#x3D;tf.truncated_normal_initializer(stddev&#x3D;0.005, dtype&#x3D;tf.float32))</span><br><span class="line">        biases &#x3D; tf.get_variable(&#39;biases&#39;,</span><br><span class="line">                                 shape&#x3D;[128],</span><br><span class="line">                                 dtype&#x3D;tf.float32,</span><br><span class="line">                                 initializer&#x3D;tf.constant_initializer(0.1))</span><br><span class="line">    local3 &#x3D; tf.nn.relu(tf.matmul(reshape, weights) + biases, name&#x3D;scope.name)</span><br><span class="line"></span><br><span class="line">    # local4</span><br><span class="line">    with tf.variable_scope(&#39;local4&#39;) as scope:</span><br><span class="line">        weights &#x3D; tf.get_variable(&#39;weights&#39;,</span><br><span class="line">                                  shape&#x3D;[128, 128],</span><br><span class="line">                                  dtype&#x3D;tf.float32,</span><br><span class="line">                                  initializer&#x3D;tf.truncated_normal_initializer(stddev&#x3D;0.005, dtype&#x3D;tf.float32))</span><br><span class="line">        biases &#x3D; tf.get_variable(&#39;biases&#39;,</span><br><span class="line">                                 shape&#x3D;[128],</span><br><span class="line">                                 dtype&#x3D;tf.float32,</span><br><span class="line">                                 initializer&#x3D;tf.constant_initializer(0.1))</span><br><span class="line">        local4 &#x3D; tf.nn.relu(tf.matmul(local3, weights) + biases, name&#x3D;&#39;local4&#39;)</span><br><span class="line"></span><br><span class="line">        # softmax</span><br><span class="line">    with tf.variable_scope(&#39;softmax_linear&#39;) as scope:</span><br><span class="line">        weights &#x3D; tf.get_variable(&#39;softmax_linear&#39;,</span><br><span class="line">                                  shape&#x3D;[128, n_classes],</span><br><span class="line">                                  dtype&#x3D;tf.float32,</span><br><span class="line">                                  initializer&#x3D;tf.truncated_normal_initializer(stddev&#x3D;0.005, dtype&#x3D;tf.float32))</span><br><span class="line">        biases &#x3D; tf.get_variable(&#39;biases&#39;,</span><br><span class="line">                                 shape&#x3D;[n_classes],</span><br><span class="line">                                 dtype&#x3D;tf.float32,</span><br><span class="line">                                 initializer&#x3D;tf.constant_initializer(0.1))</span><br><span class="line">        softmax_linear &#x3D; tf.add(tf.matmul(local4, weights), biases, name&#x3D;&#39;softmax_linear&#39;)</span><br><span class="line"></span><br><span class="line">    return softmax_linear</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def losses(logits, labels):</span><br><span class="line">    with tf.variable_scope(&#39;loss&#39;) as scope:</span><br><span class="line">        cross_entropy &#x3D; tf.nn.sparse_softmax_cross_entropy_with_logits \</span><br><span class="line">            (logits&#x3D;logits, labels&#x3D;labels, name&#x3D;&#39;xentropy_per_example&#39;)</span><br><span class="line">        loss &#x3D; tf.reduce_mean(cross_entropy, name&#x3D;&#39;loss&#39;)</span><br><span class="line">        tf.summary.scalar(scope.name + &#39;&#x2F;loss&#39;, loss)</span><br><span class="line">    return loss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def trainning(loss, learning_rate):</span><br><span class="line">    with tf.name_scope(&#39;optimizer&#39;):</span><br><span class="line">        optimizer &#x3D; tf.train.AdamOptimizer(learning_rate&#x3D;learning_rate)</span><br><span class="line">        global_step &#x3D; tf.Variable(0, name&#x3D;&#39;global_step&#39;, trainable&#x3D;False)</span><br><span class="line">        train_op &#x3D; optimizer.minimize(loss, global_step&#x3D;global_step)</span><br><span class="line">    return train_op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def evaluation(logits, labels):</span><br><span class="line">    with tf.variable_scope(&#39;accuracy&#39;) as scope:</span><br><span class="line">        correct &#x3D; tf.nn.in_top_k(logits, labels, 1)</span><br><span class="line">        correct &#x3D; tf.cast(correct, tf.float16)</span><br><span class="line">        accuracy &#x3D; tf.reduce_mean(correct)</span><br><span class="line">        tf.summary.scalar(scope.name + &#39;&#x2F;accuracy&#39;, accuracy)</span><br><span class="line">    return accuracy</span><br></pre></td></tr></table></figure>
<p>training.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line">import input_data</span><br><span class="line">import model</span><br><span class="line"></span><br><span class="line">N_CLASSES &#x3D; 2  #［1，0］ 或者 ［0，1］猫和狗的概率</span><br><span class="line">IMG_W &#x3D; 208  # 定义图片的大小</span><br><span class="line">IMG_H &#x3D; 208</span><br><span class="line">BATCH_SIZE &#x3D; 32  # 每批数据的大小</span><br><span class="line">CAPACITY &#x3D; 256</span><br><span class="line">MAX_STEP &#x3D; 1000  # 训练的步数</span><br><span class="line">learning_rate &#x3D; 0.0001  # 学习率，建议刚开始的 learning_rate &lt;&#x3D; 0.0001</span><br><span class="line"></span><br><span class="line">def run_training():</span><br><span class="line">    # 数据集</span><br><span class="line">    train_dir &#x3D; &#39;F:&#x2F;dataset_kaggledogvscat&#x2F;train&#x2F;&#39; </span><br><span class="line">    # 训练模型保存路径</span><br><span class="line">    logs_train_dir &#x3D; &#39;F:&#x2F;dataset_kaggledogvscat&#x2F;save&#x2F;&#39;</span><br><span class="line"></span><br><span class="line">    # 获取图片和标签集</span><br><span class="line">    train, train_label &#x3D; input_data.get_files(train_dir)</span><br><span class="line">    # 生成批次</span><br><span class="line">    train_batch, train_label_batch &#x3D; input_data.get_batch(train,</span><br><span class="line">                                                          train_label,</span><br><span class="line">                                                          IMG_W,</span><br><span class="line">                                                          IMG_H,</span><br><span class="line">                                                          BATCH_SIZE,</span><br><span class="line">                                                          CAPACITY)</span><br><span class="line">    # 进入模型</span><br><span class="line">    train_logits &#x3D; model.inference(train_batch, BATCH_SIZE, N_CLASSES)</span><br><span class="line">    # 获取 loss</span><br><span class="line">    train_loss &#x3D; model.losses(train_logits, train_label_batch)</span><br><span class="line">    # 训练</span><br><span class="line">    train_op &#x3D; model.trainning(train_loss, learning_rate)</span><br><span class="line">    # 获取准确率</span><br><span class="line">    train__acc &#x3D; model.evaluation(train_logits, train_label_batch)</span><br><span class="line">    # 合并 summary</span><br><span class="line">    summary_op &#x3D; tf.summary.merge_all()</span><br><span class="line">    sess &#x3D; tf.Session()</span><br><span class="line">    # 保存summary</span><br><span class="line">    train_writer &#x3D; tf.summary.FileWriter(logs_train_dir, sess.graph)</span><br><span class="line">    saver &#x3D; tf.train.Saver()</span><br><span class="line"></span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    coord &#x3D; tf.train.Coordinator()</span><br><span class="line">    threads &#x3D; tf.train.start_queue_runners(sess&#x3D;sess, coord&#x3D;coord)</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        for step in np.arange(MAX_STEP):</span><br><span class="line">            if coord.should_stop():</span><br><span class="line">                break</span><br><span class="line">            _, tra_loss, tra_acc &#x3D; sess.run([train_op, train_loss, train__acc])</span><br><span class="line"></span><br><span class="line">            if step % 50 &#x3D;&#x3D; 0:</span><br><span class="line">                print(&#39;Step %d, train loss &#x3D; %.2f, train accuracy &#x3D; %.2f%%&#39; % (step, tra_loss, tra_acc * 100.0))</span><br><span class="line">                summary_str &#x3D; sess.run(summary_op)</span><br><span class="line">                train_writer.add_summary(summary_str, step)</span><br><span class="line"></span><br><span class="line">            if step % 50 &#x3D;&#x3D; 0 or (step + 1) &#x3D;&#x3D; MAX_STEP:</span><br><span class="line">                # 每隔X步保存一下模型</span><br><span class="line">                checkpoint_path &#x3D; os.path.join(logs_train_dir, &#39;model.ckpt&#39;)</span><br><span class="line">                saver.save(sess, checkpoint_path, global_step&#x3D;step)</span><br><span class="line"></span><br><span class="line">    except tf.errors.OutOfRangeError:</span><br><span class="line">        print(&#39;Done training -- epoch limit reached&#39;)</span><br><span class="line">    finally:</span><br><span class="line">        coord.request_stop()</span><br><span class="line">    coord.join(threads)</span><br><span class="line">    sess.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># train</span><br><span class="line">run_training()</span><br></pre></td></tr></table></figure>
<p>test.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding&#x3D;utf-8</span><br><span class="line">import tensorflow as tf</span><br><span class="line">from PIL import Image</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import input_data</span><br><span class="line">import numpy as np</span><br><span class="line">import model</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 选取一张图片</span><br><span class="line">def get_one_image(train):</span><br><span class="line">    files &#x3D; os.listdir(train)</span><br><span class="line">    n &#x3D; len(files)</span><br><span class="line">    ind &#x3D; np.random.randint(0, n)</span><br><span class="line">    img_dir &#x3D; os.path.join(train, files[ind])</span><br><span class="line">    image &#x3D; Image.open(img_dir)</span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    plt.show()</span><br><span class="line">    image &#x3D; image.resize([208, 208])</span><br><span class="line">    image &#x3D; np.array(image)</span><br><span class="line">    return image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def evaluate_one_image():</span><br><span class="line">    train &#x3D; &#39;F:&#x2F;dataset_kaggledogvscat&#x2F;my&#x2F;&#39;</span><br><span class="line">    image_array &#x3D; get_one_image(train)</span><br><span class="line"></span><br><span class="line">    with tf.Graph().as_default():</span><br><span class="line">        BATCH_SIZE &#x3D; 1  </span><br><span class="line">        N_CLASSES &#x3D; 2 </span><br><span class="line">        # 转化图片格式</span><br><span class="line">        image &#x3D; tf.cast(image_array, tf.float32)</span><br><span class="line">        # 图片标准化</span><br><span class="line">        image &#x3D; tf.image.per_image_standardization(image)</span><br><span class="line">        # 图片-&gt;tensor</span><br><span class="line">        image &#x3D; tf.reshape(image, [1, 208, 208, 3])</span><br><span class="line">        logit &#x3D; model.inference(image, BATCH_SIZE, N_CLASSES)</span><br><span class="line">        # 因为 inference 的返回没有用激活函数，所以在这里对结果用softmax 激活</span><br><span class="line">        logit &#x3D; tf.nn.softmax(logit)</span><br><span class="line"></span><br><span class="line">        #占位符</span><br><span class="line">        x &#x3D; tf.placeholder(tf.float32, shape&#x3D;[208, 208, 3])</span><br><span class="line"></span><br><span class="line">        # 我门存放模型的路径</span><br><span class="line">        logs_train_dir &#x3D; &#39;F:&#x2F;dataset_kaggledogvscat&#x2F;save&#x2F;&#39;</span><br><span class="line">     </span><br><span class="line">        saver &#x3D; tf.train.Saver()</span><br><span class="line"></span><br><span class="line">        with tf.Session() as sess:</span><br><span class="line"></span><br><span class="line">            print(&quot;从指定的路径中加载模型。。。。&quot;)</span><br><span class="line">            ckpt &#x3D; tf.train.get_checkpoint_state(logs_train_dir)</span><br><span class="line">            if ckpt and ckpt.model_checkpoint_path:</span><br><span class="line">                global_step &#x3D; ckpt.model_checkpoint_path.split(&#39;&#x2F;&#39;)[-1].split(&#39;-&#39;)[-1]</span><br><span class="line">                saver.restore(sess, ckpt.model_checkpoint_path)</span><br><span class="line">                print(&#39;模型加载成功, 训练的步数为 %s&#39; % global_step)</span><br><span class="line">            else:</span><br><span class="line">                print(&#39;模型加载失败，，，文件没有找到&#39;)</span><br><span class="line">                # 将图片输入到模型计算</span><br><span class="line">            prediction &#x3D; sess.run(logit, feed_dict&#x3D;&#123;x: image_array&#125;)</span><br><span class="line">            # 获取输出结果中最大概率的索引</span><br><span class="line">            max_index &#x3D; np.argmax(prediction)</span><br><span class="line">            if max_index &#x3D;&#x3D; 0:</span><br><span class="line">                print(&#39;猫的概率 %.6f&#39; % prediction[:, 0])</span><br><span class="line">            else:</span><br><span class="line">                print(&#39;狗的概率 %.6f&#39; % prediction[:, 1]) </span><br><span class="line"># 测试</span><br><span class="line">evaluate_one_image()</span><br></pre></td></tr></table></figure>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="https://img-blog.csdnimg.cn/20200718103141965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020071810321316.png" alt="在这里插入图片描述"><br>插入：<br><a href="https://zhuanlan.zhihu.com/p/52055580">通俗理解tf.name_scope()、tf.variable_scope()</a><br>下面是测试代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">get_variable函数共有十一个参数，常用的有：名称name、变量规格shape、变量类型dtype、变量初始化方式initializer。该函数的作用是创建新的tensorflow变量，常见的initializer有：常量初始化器tf.constant_initializer、正太分布初始化器tf.random_normal_initializer、截断正态分布初始化器tf.truncated_normal_initializer、均匀分布初始化器tf.random_uniform_initializer。</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">with tf.variable_scope(&#39;V1&#39;, reuse&#x3D;None):</span><br><span class="line">    a1 &#x3D; tf.get_variable(name&#x3D;&#39;a1&#39;, shape&#x3D;[1], initializer&#x3D;tf.constant_initializer(1))</span><br><span class="line">    a2 &#x3D; tf.Variable(tf.random_normal(shape&#x3D;[2, 3], mean&#x3D;0, stddev&#x3D;1), name&#x3D;&#39;a2&#39;)</span><br><span class="line">with tf.variable_scope(&#39;V1&#39;, reuse&#x3D;True):</span><br><span class="line">    a3 &#x3D; tf.get_variable(name&#x3D;&#39;a1&#39;, shape&#x3D;[1], initializer&#x3D;tf.constant_initializer(1))</span><br><span class="line">    a4 &#x3D; tf.Variable(tf.random_normal(shape&#x3D;[2, 3], mean&#x3D;0, stddev&#x3D;1), name&#x3D;&#39;a2&#39;)</span><br><span class="line"></span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    sess.run(tf.initialize_all_variables())</span><br><span class="line">    print(a1.name)</span><br><span class="line">    print(a2.name)</span><br><span class="line">    print(a3.name)</span><br><span class="line">    print(a4.name)</span><br><span class="line"></span><br><span class="line">with tf.name_scope(&quot;my_name_scope&quot;):</span><br><span class="line">    v1 &#x3D; tf.get_variable(&quot;var1&quot;, [1], dtype&#x3D;tf.float32)</span><br><span class="line">    v2 &#x3D; tf.Variable(1, name&#x3D;&quot;var2&quot;, dtype&#x3D;tf.float32)</span><br><span class="line">    a &#x3D; tf.add(v1, v2)</span><br><span class="line">    print(v1.name)</span><br><span class="line">    print(v2.name)</span><br><span class="line">    print(a.name)</span><br><span class="line"></span><br><span class="line">with tf.variable_scope(&quot;my_variable_scope&quot;):</span><br><span class="line">    v1 &#x3D; tf.get_variable(&quot;var1&quot;, [1], dtype&#x3D;tf.float32)</span><br><span class="line">    v2 &#x3D; tf.Variable(1, name&#x3D;&quot;var2&quot;, dtype&#x3D;tf.float32)</span><br><span class="line">    a &#x3D; tf.add(v1, v2)</span><br><span class="line">    print(v1.name)</span><br><span class="line">    print(v2.name)</span><br><span class="line">    print(a.name)</span><br></pre></td></tr></table></figure>
<h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><p><a href="https://blog.csdn.net/songsongL/article/details/107138380">数据集分享</a></p>
<h1 id="keras"><a href="#keras" class="headerlink" title="keras"></a>keras</h1><p><a href="https://keras.io/getting_started/">文档十分详细</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from keras import layers</span><br><span class="line">from keras import models</span><br><span class="line">import os</span><br><span class="line">#设置文件目录</span><br><span class="line">base_dir &#x3D; &#39;F:&#x2F;kaggle-cats-and-dogs&#x2F;cats_and_dogs_small&#x2F;&#39;</span><br><span class="line">trainDir &#x3D; os.path.join(base_dir , &#39;train&#x2F;&#39;)</span><br><span class="line">valDir &#x3D; os.path.join(base_dir , &#39;validation&#x2F;&#39;)</span><br><span class="line">testDir &#x3D; os.path.join(base_dir , &#39;test&#x2F;&#39;)</span><br><span class="line">#训练集</span><br><span class="line">trainCatDir &#x3D; os.path.join(trainDir, &#39;cats&#39;)</span><br><span class="line">trainDogDir &#x3D; os.path.join(trainDir, &#39;dogs&#39;)</span><br><span class="line">#验证集</span><br><span class="line">valCatDir &#x3D; os.path.join(valDir , &#39;cats&#39;)</span><br><span class="line">valDogDir &#x3D; os.path.join(valDir , &#39;dogs&#39;)</span><br><span class="line">#测试集</span><br><span class="line">testCatDir &#x3D; os.path.join(trainDir , &#39;cats&#39;)</span><br><span class="line">testDogDir &#x3D; os.path.join(trainDir , &#39;dogs&#39;)</span><br><span class="line"></span><br><span class="line">#创建模型</span><br><span class="line">model &#x3D; models.Sequential()</span><br><span class="line">#卷积层，输出特征图的深度为32，提取信息的窗口大小(3,3),卷积核的大小也为(3,3),激活函数relu,输入图片大小(150,150,3)</span><br><span class="line">model.add(layers.Conv2D(32, (3, 3), activation&#x3D;&#39;relu&#39;,input_shape&#x3D;(150, 150, 3)))</span><br><span class="line">#池化层，窗口大小为(2,2)，缩小特征图的尺寸</span><br><span class="line">model.add(layers.MaxPooling2D((2, 2)))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(64, (3, 3), activation&#x3D;&#39;relu&#39;))</span><br><span class="line">model.add(layers.MaxPooling2D((2, 2)))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(128, (3, 3), activation&#x3D;&#39;relu&#39;))</span><br><span class="line">model.add(layers.MaxPooling2D((2, 2)))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(128, (3, 3), activation&#x3D;&#39;relu&#39;))</span><br><span class="line">model.add(layers.MaxPooling2D((2, 2)))</span><br><span class="line"></span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line">model.add(layers.Dropout(rate&#x3D;0.5))</span><br><span class="line">#扁平层,将多维的输入转化为一维的输出</span><br><span class="line">model.add(layers.Dense(512, activation&#x3D;&#39;relu&#39;))</span><br><span class="line">#全连接层，将提取的特征组合，得出结果</span><br><span class="line">model.add(layers.Dense(1, activation&#x3D;&#39;sigmoid&#39;))</span><br><span class="line"></span><br><span class="line">#设置损失函数，优化器，模型在训练和测试时的性能指标</span><br><span class="line">from keras import optimizers</span><br><span class="line"></span><br><span class="line">model.compile(loss&#x3D;&#39;binary_crossentropy&#39;,</span><br><span class="line">  optimizer&#x3D;optimizers.RMSprop(lr&#x3D;1e-4),</span><br><span class="line">  metrics&#x3D;[&#39;acc&#39;])</span><br><span class="line"></span><br><span class="line">#配置图片生成器</span><br><span class="line">from keras.preprocessing.image import ImageDataGenerator</span><br><span class="line">#将图片像素缩小为[0,1]之间的浮点数</span><br><span class="line">train_datagen &#x3D; ImageDataGenerator(</span><br><span class="line">            rescale&#x3D;1.&#x2F;255,</span><br><span class="line">            rotation_range&#x3D;40,          #图像随机旋转的最大角度</span><br><span class="line">            width_shift_range&#x3D;0.2,      #图片在水平位置上偏移的最大百分比值</span><br><span class="line">            height_shift_range&#x3D;0.2,     #数值位置上</span><br><span class="line">            shear_range&#x3D;0.2,            #随机错位切换的角度</span><br><span class="line">            zoom_range&#x3D;0.2,             #图片随机缩放的范围</span><br><span class="line">            horizontal_flip&#x3D;True        #随机将一半的图片进行水平翻转</span><br><span class="line">)</span><br><span class="line">#验证集的数据不能增强</span><br><span class="line">test_datagen &#x3D; ImageDataGenerator(rescale&#x3D;1.&#x2F;255)</span><br><span class="line"></span><br><span class="line">#创建图片生成器</span><br><span class="line">train_generator &#x3D; train_datagen.flow_from_directory(</span><br><span class="line">         trainDir,                  #图片地址</span><br><span class="line">         target_size&#x3D;(150, 150),    #将图片调整为(150,150)大小</span><br><span class="line">         batch_size&#x3D;32,             #设置批量数据的大小为32</span><br><span class="line">         class_mode&#x3D;&#39;binary&#39;        #设置返回标签的类型</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">val_generator &#x3D; test_datagen.flow_from_directory(</span><br><span class="line">         valDir,</span><br><span class="line">         target_size&#x3D;(150, 150),</span><br><span class="line">         batch_size&#x3D;32,</span><br><span class="line">         class_mode&#x3D;&#39;binary&#39;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#拟合模型</span><br><span class="line">history &#x3D; model.fit_generator(</span><br><span class="line">      train_generator,</span><br><span class="line">      steps_per_epoch&#x3D;100,  #迭代进入下一轮次需要抽取的批次</span><br><span class="line">      epochs&#x3D;100,           #数据迭代的轮数</span><br><span class="line">      validation_data&#x3D;val_generator,</span><br><span class="line">      validation_steps&#x3D;50   #验证集用于评估的批次</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#保存模型</span><br><span class="line">model.save(&#39;cats_and_dogs_small_1.h5&#39;)</span><br><span class="line"></span><br><span class="line">#画出结果</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">#查看变量，发现history.history中就只有这四个值，分别是准确度，验证集准确度，损失，验证集损失</span><br><span class="line">acc &#x3D; history.history[&#39;acc&#39;]</span><br><span class="line">val_acc &#x3D; history.history[&#39;val_acc&#39;]</span><br><span class="line">loss &#x3D; history.history[&#39;loss&#39;]</span><br><span class="line">val_loss &#x3D; history.history[&#39;val_loss&#39;]</span><br><span class="line">epochs &#x3D; range(1, len(acc) + 1)</span><br><span class="line"></span><br><span class="line">#正确率</span><br><span class="line">plt.figure(1)</span><br><span class="line">plt.plot(epochs, acc, &#39;bo&#39;, label&#x3D;&#39;Training acc&#39;)</span><br><span class="line">plt.plot(epochs, val_acc, &#39;b&#39;, label&#x3D;&#39;Validation acc&#39;)</span><br><span class="line">plt.title(&#39;Training and validation accuracy&#39;)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>加载模型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line">from keras.models import load_model</span><br><span class="line"></span><br><span class="line">model &#x3D; load_model(&#39;cats_and_dogs_small_1.h5&#39;)  #选取自己的.h模型名称</span><br><span class="line">#path &#x3D; r&#39;cats_and_dogs_small\test\dogs\dog.1501.jpg&#39;</span><br><span class="line">path &#x3D; r&#39;F:\dataset_kaggledogvscat\my\1 (7).jpg&#39;</span><br><span class="line">img &#x3D; cv2.imread(path)</span><br><span class="line"></span><br><span class="line">def format_pucture(file_path, shape):</span><br><span class="line">    from keras.preprocessing import image</span><br><span class="line">    img &#x3D; image.load_img(file_path, target_size&#x3D;shape)</span><br><span class="line">    array &#x3D; image.img_to_array(img)</span><br><span class="line">    array &#x3D; array.reshape((1,) + shape) &#x2F; 255</span><br><span class="line">    return array</span><br><span class="line"></span><br><span class="line">pucture &#x3D; format_pucture(path, (150, 150, 3))</span><br><span class="line">predict &#x3D; model.predict(pucture)</span><br><span class="line">res &#x3D; predict[0][0]</span><br><span class="line">print(res)</span><br><span class="line">if res &lt; 0.5:</span><br><span class="line">    print(&quot;this is a cat&quot;)</span><br><span class="line">else:</span><br><span class="line">    if res &gt; 0.5:</span><br><span class="line">        print(&quot;this is a dog&quot;)</span><br><span class="line"></span><br><span class="line">cv2.imshow(&quot;Image1&quot;, img)</span><br><span class="line">cv2.waitKey(0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h1><p><img src="https://img-blog.csdnimg.cn/20200718105659283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="数据集-1"><a href="#数据集-1" class="headerlink" title="数据集"></a>数据集</h1><p><a href="https://blog.csdn.net/songsongL/article/details/107138380">数据集分享</a></p>
]]></content>
      <tags>
        <tag>神经网络</tag>
        <tag>tensorflow</tag>
        <tag>深度学习</tag>
        <tag>python</tag>
        <tag>Keras</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/07/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p><strong><em>我觉得动态规划主要有两点：</em></strong></p>
<p> <strong><em>1. 当前这个点要与不要<br> 2. 由小推向大（也就是所谓子问题），以空间换时间。</em></strong></p>
<h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><p>例：有5个物品，w = [2,2,6,5,4]，v = [6,3,5,4,6]，背包的容量为10。</p>
<p> <em>1. 一个物品一个物品的慢慢放<br> 2. 拿到一个物品到底是放还是不放</em></p>
<p>当前物品不放，则价值为上一次放的情况；如果放了，则价值为把前i-1个物品放入（当前容量-这个物品容量）的价值加当前物品的价值。显然，谁大要谁。</p>
<p>|  |  0|1  | 2 | 3 |  4|5  | 6 |7  | 8 | 9 |10<br>|–|–|–|–|–|–|–|–|–|–|–|–|–|–|–|–|<br>|0  |0  |0  |0  | 0 | 0 | 0 |0  | 0 | 0 | 0 |0  |<br>| 1 | 0 | 0 |6  |6  | 6 | 6 |6  | 6 | 6 | 6 |6  |<br>| 2 | 0 |0  | ？ |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |<br>| 3 | 0 | 0 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |<br>| 4 | 0 | 0 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |<br>| 5 | 0 | 0 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | </p>
<p>初始化：i个物品装入容量0的背包中，价值肯定0；0个物品放入容量j的背包，价值也是0 。<br>dp[1][?]处放第一个物品，放不下，价值是放0物品时得0；放进去价值是6；<br>dp[2][?]处放第二个物品，放不下，价值和上一行的一样；？处放得下，放，价值为前（2-1）个物品放入（2-2）容量中，得，0+3 = 3；不放，就是上一次的6,；所以？处不放新物品。<br>以此类推。。。<br>最后放到第5个物品，便能得到最大价值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &#x2F;**</span><br><span class="line"> * @param c : 表示背包容量</span><br><span class="line"> * @param n : 表示商品个数</span><br><span class="line"> * @param w : 表示商品重量</span><br><span class="line"> * @param p : 表示商品价值</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static int KnapSack(int c,int n,int w[],int p[])&#123;</span><br><span class="line">    &#x2F;&#x2F;c[i][m] 表示前i件物品放入容量为m的背包时的最大价值</span><br><span class="line">    int[][] dp &#x3D; new int[n+1][c+1];</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0;i&lt;n+1;i++)&#123;</span><br><span class="line">        dp[i][0] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int j&#x3D;0;j&lt;c+1;j++)&#123;</span><br><span class="line">        dp[0][j] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;n+1;i++)&#123;</span><br><span class="line">        for(int j&#x3D;1;j&lt;c+1;j++)&#123;</span><br><span class="line">            if(w[i-1] &lt;&#x3D; j)&#123;   &#x2F;&#x2F;放得下，谁大要谁</span><br><span class="line">                dp[i][j] &#x3D; Math.max(dp[i-1][j],dp[i-1][j-w[i-1]]+p[i-1]);</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;  &#x2F;&#x2F;放不下，就是上一次的情况</span><br><span class="line">                dp[i][j] &#x3D; dp[i-1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n][c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>例：给定两个字符串 “abcbdb”和 “acbbabdbb”，返回这两个字符串的最长公共子序列的长度。<br> <em>1. 从字符串开头慢慢比<br> 2. 当前字符相等了，公共长度则为上一次的加1；不等了，要么不要字符1要么不要字符2，显然，谁的结果长要谁。</em></p>
<p>|  | |”” |a | c | b |  b|a  | b |d | b| b |<br>|–|–|–|–|–|–|–|–|–|–|–|–|–|–|<br>|  |  |0|1  | 2 | 3 |  4|5  | 6 |7  | 8 | 9 |<br>|”” |0  |0  |0  |0  | 0 | 0 | 0 |0  | 0 | 0 | 0 |0  |<br>|a| 1 | 0 | 1 |1  |1 | 1 | 1 |1 | 1 | 1 | 1<br>|b| 2 | 0 |1  | ？ |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |<br>|c| 3 | 0 | 1 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |<br>|b| 4 | 0 | 1 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |<br>|d| 5 | 0 | 1 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |<br>|b| 6 | 0 | 1 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | </p>
<p>初始化：有一方为空，公共长度都是0；<br>dp[1][?]处第一个字符的比较结果，a==a，则长度为：上一次（即左上对角线）[0][0]+1 = 1; a != c,不要a（即上一行）则长度为0；不要c（即左一列）则长度为1。所以公共长度为1<br>dp[2][?]处第二个字符的比较结果，b != a，不要b（即上一行），长度为1；不要a（即左一列）长度为0 。所以公共长度为1 。<br>以此类推。。。<br>最后字符比较完，便能得到最长结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int longestCommonSubsequence(String str1, String str2) &#123;</span><br><span class="line">        if (str1 &#x3D;&#x3D; null || str2 &#x3D;&#x3D; null || str1.length() &#x3D;&#x3D; 0 || str2.length() &#x3D;&#x3D; 0)</span><br><span class="line">            return 0;</span><br><span class="line">        int[][] dp &#x3D; new int[str1.length() + 1][str2.length() + 1];</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; str1.length(); i++) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; str2.length(); j++) &#123;</span><br><span class="line">                if (str1.charAt(i - 1) &#x3D;&#x3D; str2.charAt(j - 1))	&#x2F;&#x2F;当前相等</span><br><span class="line">                    dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;		&#x2F;&#x2F;上一次加这一个</span><br><span class="line">                else												&#x2F;&#x2F;不等</span><br><span class="line">                    dp[i][j] &#x3D; Math.max(dp[i - 1][j], dp[i][j - 1]);	&#x2F;&#x2F;谁长要谁</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[str1.length()][str2.length()];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><p>例：给你两个单词 word1 = “horse”和word2 = “ros”，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p><em>1. 从字符串开头慢慢比<br> 2. 当前字符相等了，则编辑距离和上一次一样；不等了，则进行如下的三种编辑，显然，谁小要谁。</em></p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符 </li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<p>|  | |”” |h | o | r | s | e|<br>|–|–|–|–|–|–|–|–|–|<br>|  |  |0|1  | 2 | 3 |  4|5  | 6 |7  | 8 | 9 |<br>|”” |0  |0  |1  |2  | 3 | 4 | 5|<br>|r| 1 | 1 | 1|?<br>|o| 2 | 2 |1  |  |  |  |  |<br>|s| 3 | 3 | 1 |  |  |  |  |  |  </p>
<p>初始化：一个字符编辑成一个字符串，这个简单。<br>dp[1][?]处第一个字符的编辑距离，r != h，则进行编辑：不要r（即上一行）（对于另一个字符串而言就是加上h，效果一样）则编辑距离为1+1=2；不要h（即左一列）则编辑距离为1+1=2。替换，编辑距离为上一次加1，即0+1 = 1 。所以编辑距离为1，替换一次就行。<br>以此类推。。。<br>最后字符比较完，便能得到最小编辑距离。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        int n1 &#x3D; word1.length();</span><br><span class="line">        int n2 &#x3D; word2.length();</span><br><span class="line"></span><br><span class="line">        int[][] dp &#x3D; new int[n1 + 1][n2 + 1];</span><br><span class="line">        &#x2F;&#x2F; 第一行</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; n2; j++) dp[0][j] &#x3D; dp[0][j - 1] + 1;</span><br><span class="line">        &#x2F;&#x2F; 第一列</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n1; i++) dp[i][0] &#x3D; dp[i - 1][0] + 1;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n1; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; n2; j++) &#123;</span><br><span class="line">                if (word1.charAt(i - 1) &#x3D;&#x3D; word2.charAt(j - 1)) </span><br><span class="line">                	dp[i][j] &#x3D; dp[i - 1][j - 1];		</span><br><span class="line">                else&#123;</span><br><span class="line">                    int min &#x3D; Math.min(dp[i][j - 1], dp[i - 1][j]);	&#x2F;&#x2F;删或者说加</span><br><span class="line">                    dp[i][j] &#x3D; Math.min(dp[i - 1][j - 1], min ) + 1;	&#x2F;&#x2F;替换</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n1][n2];  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h1><p>例：如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。房屋存放金额[1,2,3,1]，计算不触动警报装置的情况下 ，能够偷窃到的最高金额。</p>
<p><em>1. 一间一间慢慢偷<br> 2. 当前房屋到底偷还是不偷。</em></p>
<p> 当前房屋偷了，则价值上上一次的价值加这一次的价值；如果不偷，则价值为上一次的价值。显然，谁大要谁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int rob(int[] nums) &#123;</span><br><span class="line">       int len &#x3D; nums.length;</span><br><span class="line">       if(len &#x3D;&#x3D; 0) return 0;</span><br><span class="line">       int[] dp &#x3D; new int[len + 1];</span><br><span class="line">       dp[0] &#x3D; 0;</span><br><span class="line">       dp[1] &#x3D; nums[0];</span><br><span class="line">       for(int i &#x3D; 2; i &lt;&#x3D; len; i++) &#123;</span><br><span class="line">           dp[i] &#x3D; Math.max(dp[i-1], dp[i-2] + nums[i-1]);</span><br><span class="line">       &#125;</span><br><span class="line">       return dp[len];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h1><p>例：给定不同面额的硬币 coins = [1, 2, 5]和一个总金额  amount = 11。计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p><em>1. 一块钱一块钱的慢慢换<br> 2. 当前这个硬币到底要不要。</em></p>
<p> 当前硬币不要，则个数没变化；如果要，则个数变为兑换（要兑换的钱减去当前这个面额）的个数加1。显然，谁小要谁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int coinChange(int[] coins, int amount) &#123;</span><br><span class="line">        &#x2F;&#x2F;dp[i]表示钱数为i时最小硬币数</span><br><span class="line">        int dp[] &#x3D; new int[amount + 1];</span><br><span class="line">        &#x2F;&#x2F;初始化钱数为i时的硬币数</span><br><span class="line">        Arrays.fill(dp,amount +1);</span><br><span class="line">        dp[0] &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;钱数为0时的最小硬币数也为0</span><br><span class="line">        for(int i &#x3D; 1;i&lt;&#x3D;amount;i++)&#123;</span><br><span class="line">            for(int coin : coins)&#123;</span><br><span class="line">                if(i &gt;&#x3D; coin)&#123;</span><br><span class="line">                    dp[i] &#x3D; Math.min(dp[i],dp[i-coin]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount]&gt; amount ? -1:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow图像识别</title>
    <url>/2020/07/11/tensorflow%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="model-py-建立模型"><a href="#model-py-建立模型" class="headerlink" title="model.py 建立模型"></a>model.py 建立模型</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def weight_variable(shape):</span><br><span class="line">    # 产生截断正态分布随机数</span><br><span class="line">    initial &#x3D; tf.truncated_normal(shape, stddev&#x3D;0.1)</span><br><span class="line">    return tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">def bias_variable(shape):</span><br><span class="line">    # 误差初始值定义为0.1</span><br><span class="line">    return tf.Variable(tf.constant(0.1, shape&#x3D;shape))</span><br><span class="line"></span><br><span class="line">def MLP(_IMAGE_SIZE&#x3D;28, _IMAGE_CHANNELS &#x3D; 1,_HIDDEN1 &#x3D; 128,_HIDDEN2 &#x3D; 64,_NUM_CLASSES &#x3D; 10):</span><br><span class="line"></span><br><span class="line">    image_pixels &#x3D; _IMAGE_SIZE * _IMAGE_SIZE * _IMAGE_CHANNELS</span><br><span class="line"></span><br><span class="line">    with tf.name_scope(&#39;main_params&#39;):</span><br><span class="line">        x &#x3D; tf.placeholder(tf.float32, shape&#x3D;[None, image_pixels], name&#x3D;&#39;Input&#39;)</span><br><span class="line">        y &#x3D; tf.placeholder(tf.float32, shape&#x3D;[None, _NUM_CLASSES], name&#x3D;&#39;Output&#39;)</span><br><span class="line"></span><br><span class="line">    with tf.variable_scope(&#39;hidden1&#39;):</span><br><span class="line">        w_h &#x3D; weight_variable([image_pixels, _HIDDEN1])</span><br><span class="line">        h &#x3D; tf.nn.relu(tf.matmul(x, w_h))    # hidden layer1</span><br><span class="line"></span><br><span class="line">    with tf.variable_scope(&#39;hidden2&#39;):</span><br><span class="line">        w_h2 &#x3D; weight_variable([_HIDDEN1, _HIDDEN2])</span><br><span class="line">        h2 &#x3D; tf.nn.relu(tf.matmul(h, w_h2))  # hidden layer2</span><br><span class="line"></span><br><span class="line">    with tf.variable_scope(&#39;out&#39;):</span><br><span class="line">        w_out &#x3D; weight_variable([_HIDDEN2, _NUM_CLASSES])</span><br><span class="line">        logit &#x3D; tf.matmul(h2, w_out)           # 输出层</span><br><span class="line"></span><br><span class="line">    return x, y, logit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def CNN(_IMAGE_SIZE &#x3D; 32,_IMAGE_CHANNELS &#x3D; 3,_NUM_CLASSES &#x3D; 10):</span><br><span class="line"></span><br><span class="line">    with tf.name_scope(&#39;main_params&#39;):</span><br><span class="line">        x &#x3D; tf.placeholder(tf.float32, shape&#x3D;[None, _IMAGE_SIZE * _IMAGE_SIZE * _IMAGE_CHANNELS], name&#x3D;&#39;Input&#39;)</span><br><span class="line">        y &#x3D; tf.placeholder(tf.float32, shape&#x3D;[None, _NUM_CLASSES], name&#x3D;&#39;Output&#39;)</span><br><span class="line">        x_image &#x3D; tf.reshape(x, [-1, _IMAGE_SIZE, _IMAGE_SIZE, _IMAGE_CHANNELS], name&#x3D;&#39;images&#39;)</span><br><span class="line"></span><br><span class="line">    with tf.variable_scope(&#39;conv1&#39;) as scope:</span><br><span class="line">        conv &#x3D; tf.layers.conv2d(</span><br><span class="line">            inputs&#x3D;x_image,</span><br><span class="line">            filters&#x3D;32,</span><br><span class="line">            kernel_size&#x3D;[3, 3],</span><br><span class="line">            padding&#x3D;&#39;SAME&#39;,</span><br><span class="line">            activation&#x3D;tf.nn.relu</span><br><span class="line">        )</span><br><span class="line">        pool &#x3D; tf.layers.max_pooling2d(conv, pool_size&#x3D;[2, 2], strides&#x3D;2, padding&#x3D;&#39;SAME&#39;)</span><br><span class="line"></span><br><span class="line">    with tf.variable_scope(&#39;conv2&#39;) as scope:</span><br><span class="line">        conv &#x3D; tf.layers.conv2d(</span><br><span class="line">            inputs&#x3D;pool,</span><br><span class="line">            filters&#x3D;64,</span><br><span class="line">            kernel_size&#x3D;[3, 3],</span><br><span class="line">            padding&#x3D;&#39;SAME&#39;,</span><br><span class="line">            activation&#x3D;tf.nn.relu</span><br><span class="line">        )</span><br><span class="line">        pool &#x3D; tf.layers.max_pooling2d(conv, pool_size&#x3D;[2, 2], strides&#x3D;2, padding&#x3D;&#39;SAME&#39;)</span><br><span class="line"></span><br><span class="line">    with tf.variable_scope(&#39;fully_connected&#39;) as scope:</span><br><span class="line">        flat &#x3D; tf.layers.flatten(pool)</span><br><span class="line">        # flat &#x3D; tf.reshape(pool, [-1, 8 * 8 * 64])</span><br><span class="line">        # flat &#x3D; tf.reshape(pool, [-1, 7 * 7 * 64])</span><br><span class="line">        fc &#x3D; tf.layers.dense(inputs&#x3D;flat, units&#x3D;1500, activation&#x3D;tf.nn.relu)</span><br><span class="line">        drop &#x3D; tf.layers.dropout(fc, rate&#x3D;0.5)</span><br><span class="line">        logit &#x3D; tf.layers.dense(inputs&#x3D;drop, units&#x3D;_NUM_CLASSES, name&#x3D;scope.name)</span><br><span class="line"></span><br><span class="line">    return x, y, logit</span><br><span class="line"></span><br><span class="line">def LeNet(_IMAGE_SIZE &#x3D; 32,_IMAGE_CHANNELS &#x3D; 3,_NUM_CLASSES &#x3D; 10):</span><br><span class="line"></span><br><span class="line">    with tf.name_scope(&#39;main_params&#39;):</span><br><span class="line">        x &#x3D; tf.placeholder(tf.float32, shape&#x3D;[None, _IMAGE_SIZE * _IMAGE_SIZE * _IMAGE_CHANNELS], name&#x3D;&#39;Input&#39;)</span><br><span class="line">        y &#x3D; tf.placeholder(tf.float32, shape&#x3D;[None, _NUM_CLASSES], name&#x3D;&#39;Output&#39;)</span><br><span class="line">        x_image &#x3D; tf.reshape(x, [-1, _IMAGE_SIZE, _IMAGE_SIZE, _IMAGE_CHANNELS], name&#x3D;&#39;images&#39;)</span><br><span class="line"></span><br><span class="line">    with tf.variable_scope(&#39;layer1-conv1&#39;):</span><br><span class="line">        W_conv1 &#x3D; weight_variable([5, 5, 1, 6])</span><br><span class="line">        b_conv1 &#x3D; bias_variable([6])</span><br><span class="line"></span><br><span class="line">        conv1 &#x3D; tf.nn.conv2d(x_image, W_conv1, strides&#x3D;[1, 1, 1, 1], padding&#x3D;&#39;VALID&#39;)</span><br><span class="line">        relu1 &#x3D; tf.nn.relu(tf.nn.bias_add(conv1, b_conv1))</span><br><span class="line"></span><br><span class="line">    with tf.name_scope(&#39;layer2-pool1&#39;):</span><br><span class="line">        pool1 &#x3D; tf.nn.max_pool(relu1, ksize&#x3D;[1, 2, 2, 1], strides&#x3D;[1, 2, 2, 1], padding&#x3D;&#39;VALID&#39;)</span><br><span class="line"></span><br><span class="line">    with tf.variable_scope(&#39;layer3-conv2&#39;):</span><br><span class="line">        W_conv2 &#x3D; weight_variable([5, 5, 6, 16])</span><br><span class="line">        b_conv2 &#x3D; bias_variable([16])</span><br><span class="line">        conv2 &#x3D; tf.nn.conv2d(pool1, W_conv2, strides&#x3D;[1, 1, 1, 1], padding&#x3D;&#39;VALID&#39;)</span><br><span class="line">        relu2 &#x3D; tf.nn.relu(tf.nn.bias_add(conv2, b_conv2))</span><br><span class="line"></span><br><span class="line">    with tf.name_scope(&#39;layer4-pool2&#39;):</span><br><span class="line">        pool2 &#x3D; tf.nn.max_pool(relu2, ksize&#x3D;[1, 2, 2, 1], strides&#x3D;[1, 2, 2, 1], padding&#x3D;&#39;VALID&#39;)</span><br><span class="line"></span><br><span class="line">    with tf.variable_scope(&#39;layer5-fc1&#39;):</span><br><span class="line">        W_fc1 &#x3D; weight_variable([400, 120])</span><br><span class="line">        b_fc1 &#x3D; bias_variable([120])</span><br><span class="line"></span><br><span class="line">        flat &#x3D; tf.layers.flatten(pool2)</span><br><span class="line">        # flat &#x3D; tf.reshape(pool2, [-1, 5 * 5 * 16])</span><br><span class="line"></span><br><span class="line">        fc1 &#x3D; tf.nn.relu(tf.matmul(flat, W_fc1) + b_fc1)</span><br><span class="line"></span><br><span class="line">    with tf.variable_scope(&#39;layer6-fc2&#39;):</span><br><span class="line">        W_fc2 &#x3D; weight_variable([120, 84])</span><br><span class="line">        b_fc2 &#x3D; bias_variable([84])</span><br><span class="line"></span><br><span class="line">        fc2 &#x3D; tf.matmul(fc1, W_fc2) + b_fc2</span><br><span class="line"></span><br><span class="line">    with tf.variable_scope(&#39;layer7-fc3&#39;):</span><br><span class="line">        W_fc3 &#x3D; weight_variable([84, 10])</span><br><span class="line">        b_fc3 &#x3D; bias_variable([10])</span><br><span class="line"></span><br><span class="line">        logit &#x3D; tf.matmul(fc2, W_fc3) + b_fc3</span><br><span class="line"></span><br><span class="line">    return x,y,logit</span><br><span class="line"></span><br><span class="line">def loss(logit, labels):</span><br><span class="line"></span><br><span class="line">  with tf.name_scope(&#39;cross_entropy&#39;):</span><br><span class="line">    # Operation to determine the cross entropy between logits and labels</span><br><span class="line">    loss &#x3D; tf.reduce_mean(</span><br><span class="line">      tf.nn.softmax_cross_entropy_with_logits_v2(</span><br><span class="line">        logits&#x3D;logit, labels&#x3D;labels, name&#x3D;&#39;cross_entropy&#39;))</span><br><span class="line"></span><br><span class="line">  return loss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def training(loss, learning_rate):</span><br><span class="line"></span><br><span class="line">  global_step &#x3D; tf.Variable(0, name&#x3D;&#39;global_step&#39;, trainable&#x3D;False)</span><br><span class="line"></span><br><span class="line">  # 优化器</span><br><span class="line">  optimizer &#x3D; tf.train.AdamOptimizer(learning_rate, 0.9)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # 参数更新</span><br><span class="line">  train_op &#x3D; optimizer.minimize(loss, global_step&#x3D;global_step)</span><br><span class="line"></span><br><span class="line">  return train_op,global_step</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def evaluation(logits, labels):</span><br><span class="line"></span><br><span class="line">  with tf.name_scope(&#39;Accuracy&#39;):</span><br><span class="line">    # Operation comparing prediction with true label</span><br><span class="line">    correct_prediction &#x3D; tf.equal(tf.argmax(logits,1), tf.argmax(labels,1))</span><br><span class="line"></span><br><span class="line">    # Operation calculating the accuracy of the predictions</span><br><span class="line">    accuracy &#x3D;  tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line"></span><br><span class="line">    # Summary operation for the accuracy</span><br><span class="line">    # tf.summary.scalar(&#39;train_accuracy&#39;, accuracy)</span><br><span class="line"></span><br><span class="line">  return accuracy</span><br><span class="line"></span><br><span class="line">def lr(epoch):</span><br><span class="line">    learning_rate &#x3D; 1e-3</span><br><span class="line">    if epoch &gt; 80:</span><br><span class="line">        learning_rate *&#x3D; 0.5e-3</span><br><span class="line">    elif epoch &gt; 60:</span><br><span class="line">        learning_rate *&#x3D; 1e-3</span><br><span class="line">    elif epoch &gt; 40:</span><br><span class="line">        learning_rate *&#x3D; 1e-2</span><br><span class="line">    elif epoch &gt; 20:</span><br><span class="line">        learning_rate *&#x3D; 1e-1</span><br><span class="line">    return learning_rate</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="train-py-训练过程"><a href="#train-py-训练过程" class="headerlink" title="train.py 训练过程"></a>train.py 训练过程</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># import os</span><br><span class="line"># os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] &#x3D; &quot;-1&quot;  # 这一行注释掉就是使用gpu，不注释就是使用cpu</span><br><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line">from tensorflow.examples.tutorials.mnist import input_data</span><br><span class="line"></span><br><span class="line">import model</span><br><span class="line">from model import LeNet, MLP, CNN, lr</span><br><span class="line"></span><br><span class="line">from data import get_data_set</span><br><span class="line"></span><br><span class="line">train_x, train_y &#x3D; get_data_set(&quot;train&quot;)</span><br><span class="line">test_x, test_y &#x3D; get_data_set(&quot;test&quot;)</span><br><span class="line"></span><br><span class="line">mnist &#x3D; input_data.read_data_sets(&quot;MNIST_data&#x2F;&quot;, one_hot&#x3D;True)  # 读取MNIST手写数字识别数据集</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">epoch &#x3D; 2</span><br><span class="line">batch_size &#x3D; 64</span><br><span class="line"></span><br><span class="line">def train():</span><br><span class="line"></span><br><span class="line">    # tensorflow变量占位符，在执行运算时才传入数据</span><br><span class="line">    # X, Y, logit &#x3D; MLP(_IMAGE_SIZE&#x3D;32, _IMAGE_CHANNELS &#x3D; 3)</span><br><span class="line">    X, Y, logit &#x3D; CNN(_IMAGE_SIZE&#x3D;28, _IMAGE_CHANNELS &#x3D; 1)</span><br><span class="line">    # X, Y, logit &#x3D; LeNet(_IMAGE_SIZE&#x3D;32, _IMAGE_CHANNELS &#x3D; 3)</span><br><span class="line"></span><br><span class="line">    # 计算损失</span><br><span class="line">    loss &#x3D; model.loss(logit, Y)</span><br><span class="line"></span><br><span class="line">    # softmx &#x3D; tf.argmax(tf.nn.softmax(logit),1)</span><br><span class="line">    # 计算准确率</span><br><span class="line">    accuracy &#x3D; model.evaluation(logit, Y)</span><br><span class="line"></span><br><span class="line">    # 优化器</span><br><span class="line">    train_op,global_step &#x3D; model.training(loss, learning_rate&#x3D;0.001)</span><br><span class="line"></span><br><span class="line">    saver &#x3D; tf.train.Saver()</span><br><span class="line">    with tf.Session(config&#x3D;tf.ConfigProto(log_device_placement&#x3D;True)) as sess:</span><br><span class="line">        sess.run(tf.global_variables_initializer())  # 初始化各种变量</span><br><span class="line"></span><br><span class="line">        for i in range(epoch):</span><br><span class="line"></span><br><span class="line">            # num &#x3D; len(train_x) &#x2F;&#x2F; batch_size</span><br><span class="line">            num &#x3D; mnist.train.num_examples &#x2F;&#x2F; batch_size</span><br><span class="line"></span><br><span class="line">            for step in range(num):</span><br><span class="line"></span><br><span class="line">                # batch_x &#x3D; train_x[step * batch_size: (step + 1) * batch_size]</span><br><span class="line">                # batch_y &#x3D; train_y[step * batch_size: (step + 1) * batch_size]</span><br><span class="line"></span><br><span class="line">                batch_x, batch_y &#x3D; mnist.train.next_batch(batch_size)  # 读取相应一批的图片和标签数量</span><br><span class="line"></span><br><span class="line">                _,i_global,batch_loss, batch_acc &#x3D; sess.run([train_op,global_step,loss, accuracy], feed_dict&#x3D;&#123;X: batch_x, Y: batch_y&#125;)  # 通过神经网络训练</span><br><span class="line"></span><br><span class="line">                if step % 128 &#x3D;&#x3D; 0:  # 输出训练记录</span><br><span class="line">                    msg &#x3D; &quot;Global step: &#123;:&gt;5&#125; - acc: &#123;:.4f&#125; - loss: &#123;:.4f&#125;&quot;</span><br><span class="line">                    print(msg.format(i_global, batch_acc, batch_loss))</span><br><span class="line"></span><br><span class="line">            print(&quot;Epoch: &#123;&#125;&quot;.format(i), &quot;Testing Accuracy: &#123;:0.5f&#125;&quot;.format(sess.run(accuracy,feed_dict&#x3D;&#123;X: mnist.test.images, Y: mnist.test.labels&#125;)))</span><br><span class="line"></span><br><span class="line">            # i &#x3D; 0</span><br><span class="line">            # predicted_class &#x3D; []</span><br><span class="line">            # while i &lt; len(test_x):</span><br><span class="line">            #     j &#x3D; min(i + batch_size, len(test_x))</span><br><span class="line">            #     batch_xs &#x3D; test_x[i:j, :]</span><br><span class="line">            #     batch_ys &#x3D; test_y[i:j, :]</span><br><span class="line">            #     predicted_class.append(sess.run(accuracy, feed_dict&#x3D;&#123;X: batch_xs, Y: batch_ys&#125;))</span><br><span class="line">            #     i &#x3D; j</span><br><span class="line"></span><br><span class="line">            # acc &#x3D; np.mean(predicted_class)</span><br><span class="line">            # print(&quot;Accuracy on Test-Set: &#123;0:.2f&#125;)&quot;.format(acc))</span><br><span class="line"></span><br><span class="line">        saver.save(sess, &#39;.&#x2F;models&#x2F;model.ckpt&#39;)</span><br><span class="line">train()</span><br></pre></td></tr></table></figure>

<h1 id="load-py-加载预测"><a href="#load-py-加载预测" class="headerlink" title="load.py 加载预测"></a>load.py 加载预测</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import tensorflow as tf</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from tensorflow.examples.tutorials.mnist import input_data</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">from model import MLP, CNN</span><br><span class="line"></span><br><span class="line">mnist &#x3D; input_data.read_data_sets(&#39;MNIST_data&#39;, one_hot&#x3D;True)</span><br><span class="line"></span><br><span class="line">def display_compare(num):</span><br><span class="line"></span><br><span class="line">    x_train &#x3D; mnist.test.images[num, :].reshape(1, 784)</span><br><span class="line">    y_train &#x3D; mnist.test.labels[num, :]</span><br><span class="line"></span><br><span class="line">    np.set_printoptions(precision&#x3D;1)</span><br><span class="line">    np.set_printoptions(suppress&#x3D;True)</span><br><span class="line"></span><br><span class="line">    label &#x3D; y_train.argmax()</span><br><span class="line"></span><br><span class="line">    result &#x3D; sess.run(logit, feed_dict&#x3D;&#123;X: x_train&#125;)</span><br><span class="line"></span><br><span class="line">    prediction &#x3D; result.argmax()</span><br><span class="line">    plt.title(&#39;Prediction: %d Label: %s&#39; % (prediction, label))</span><br><span class="line">    plt.imshow(x_train.reshape([28, 28]), cmap&#x3D;plt.get_cmap(&#39;gray_r&#39;))</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_file &#x3D; tf.train.latest_checkpoint(&#39;.&#x2F;models&#x2F;&#39;)</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line"></span><br><span class="line">    with tf.Session() as sess:</span><br><span class="line"></span><br><span class="line">        X, Y, logit &#x3D; CNN(_IMAGE_SIZE&#x3D;28, _IMAGE_CHANNELS &#x3D; 1)</span><br><span class="line"></span><br><span class="line">        saver &#x3D; tf.train.Saver()</span><br><span class="line">        saver.restore(sess, module_file)</span><br><span class="line"></span><br><span class="line">        while True:</span><br><span class="line">            n &#x3D; int(input(&#39;请输入想要查看的图像&#39;))</span><br><span class="line">            display_compare(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200711144748565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200711150916366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="data-py-加载cifar10数据集"><a href="#data-py-加载cifar10数据集" class="headerlink" title="data.py 加载cifar10数据集"></a>data.py 加载cifar10数据集</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pickle</span><br><span class="line">import numpy as np</span><br><span class="line">import os</span><br><span class="line">from urllib.request import urlretrieve</span><br><span class="line">import tarfile</span><br><span class="line">import zipfile</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_data_set(name&#x3D;&quot;train&quot;):</span><br><span class="line">    x &#x3D; None</span><br><span class="line">    y &#x3D; None</span><br><span class="line"></span><br><span class="line">    # maybe_download_and_extract()</span><br><span class="line"></span><br><span class="line">    folder_name &#x3D; &quot;.&#x2F;cifar_10&quot;</span><br><span class="line"></span><br><span class="line">    # f &#x3D; open(&#39;.&#x2F;data_set&#x2F;&#39;+folder_name+&#39;&#x2F;batches.meta&#39;, &#39;rb&#39;)</span><br><span class="line">    # f.close()</span><br><span class="line"></span><br><span class="line">    if name is &quot;train&quot;:</span><br><span class="line">        for i in range(5):</span><br><span class="line">            f &#x3D; open(folder_name+&#39;&#x2F;data_batch_&#39; + str(i + 1), &#39;rb&#39;)</span><br><span class="line">            datadict &#x3D; pickle.load(f, encoding&#x3D;&#39;latin1&#39;)</span><br><span class="line">            f.close()</span><br><span class="line"></span><br><span class="line">            _X &#x3D; datadict[&quot;data&quot;]</span><br><span class="line">            _Y &#x3D; datadict[&#39;labels&#39;]</span><br><span class="line"></span><br><span class="line">            _X &#x3D; np.array(_X, dtype&#x3D;float) &#x2F; 255.0</span><br><span class="line">            _X &#x3D; _X.reshape([-1, 3, 32, 32])</span><br><span class="line">            _X &#x3D; _X.transpose([0, 2, 3, 1])</span><br><span class="line">            _X &#x3D; _X.reshape(-1, 32*32*3)</span><br><span class="line"></span><br><span class="line">            if x is None:</span><br><span class="line">                x &#x3D; _X</span><br><span class="line">                y &#x3D; _Y</span><br><span class="line">            else:</span><br><span class="line">                x &#x3D; np.concatenate((x, _X), axis&#x3D;0)</span><br><span class="line">                y &#x3D; np.concatenate((y, _Y), axis&#x3D;0)</span><br><span class="line"></span><br><span class="line">    elif name is &quot;test&quot;:</span><br><span class="line">        f &#x3D; open(folder_name+&#39;&#x2F;test_batch&#39;, &#39;rb&#39;)</span><br><span class="line">        datadict &#x3D; pickle.load(f, encoding&#x3D;&#39;latin1&#39;)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">        x &#x3D; datadict[&quot;data&quot;]</span><br><span class="line">        y &#x3D; np.array(datadict[&#39;labels&#39;])</span><br><span class="line"></span><br><span class="line">        x &#x3D; np.array(x, dtype&#x3D;float) &#x2F; 255.0</span><br><span class="line">        x &#x3D; x.reshape([-1, 3, 32, 32])</span><br><span class="line">        x &#x3D; x.transpose([0, 2, 3, 1])</span><br><span class="line">        x &#x3D; x.reshape(-1, 32*32*3)</span><br><span class="line"></span><br><span class="line">    return x, dense_to_one_hot(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dense_to_one_hot(labels_dense, num_classes&#x3D;10):</span><br><span class="line">    num_labels &#x3D; labels_dense.shape[0]</span><br><span class="line">    index_offset &#x3D; np.arange(num_labels) * num_classes</span><br><span class="line">    labels_one_hot &#x3D; np.zeros((num_labels, num_classes))</span><br><span class="line">    labels_one_hot.flat[index_offset + labels_dense.ravel()] &#x3D; 1</span><br><span class="line"></span><br><span class="line">    return labels_one_hot</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># def _print_download_progress(count, block_size, total_size):</span><br><span class="line">#     pct_complete &#x3D; float(count * block_size) &#x2F; total_size</span><br><span class="line">#     msg &#x3D; &quot;\r- Download progress: &#123;0:.1%&#125;&quot;.format(pct_complete)</span><br><span class="line">#     sys.stdout.write(msg)</span><br><span class="line">#     sys.stdout.flush()</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># def maybe_download_and_extract():</span><br><span class="line">#     main_directory &#x3D; &quot;.&#x2F;data_set&#x2F;&quot;</span><br><span class="line">#     cifar_10_directory &#x3D; main_directory+&quot;cifar_10&#x2F;&quot;</span><br><span class="line">#     if not os.path.exists(main_directory):</span><br><span class="line">#         os.makedirs(main_directory)</span><br><span class="line">#</span><br><span class="line">#         url &#x3D; &quot;http:&#x2F;&#x2F;www.cs.toronto.edu&#x2F;~kriz&#x2F;cifar-10-python.tar.gz&quot;</span><br><span class="line">#         filename &#x3D; url.split(&#39;&#x2F;&#39;)[-1]</span><br><span class="line">#         file_path &#x3D; os.path.join(main_directory, filename)</span><br><span class="line">#         zip_cifar_10 &#x3D; file_path</span><br><span class="line">#         file_path, _ &#x3D; urlretrieve(url&#x3D;url, filename&#x3D;file_path, reporthook&#x3D;_print_download_progress)</span><br><span class="line">#</span><br><span class="line">#         print()</span><br><span class="line">#         print(&quot;Download finished. Extracting files.&quot;)</span><br><span class="line">#         if file_path.endswith(&quot;.zip&quot;):</span><br><span class="line">#             zipfile.ZipFile(file&#x3D;file_path, mode&#x3D;&quot;r&quot;).extractall(main_directory)</span><br><span class="line">#         elif file_path.endswith((&quot;.tar.gz&quot;, &quot;.tgz&quot;)):</span><br><span class="line">#             tarfile.open(name&#x3D;file_path, mode&#x3D;&quot;r:gz&quot;).extractall(main_directory)</span><br><span class="line">#         print(&quot;Done.&quot;)</span><br><span class="line">#</span><br><span class="line">#         os.rename(main_directory+&quot;.&#x2F;cifar-10-batches-py&quot;, cifar_10_directory)</span><br><span class="line">#         os.remove(zip_cifar_10)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1eGk_NXuvQK-5-LeYP6Bzyg">https://pan.baidu.com/s/1eGk_NXuvQK-5-LeYP6Bzyg</a>  提取码：vqog<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p>
</blockquote>
]]></content>
      <tags>
        <tag>神经网络</tag>
        <tag>tensorflow</tag>
        <tag>深度学习</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>实现搜索词补全功能</title>
    <url>/2020/07/10/%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E8%AF%8D%E8%A1%A5%E5%85%A8%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>百度搜索栏下方的提示效果如下：<br><img src="https://img-blog.csdnimg.cn/20200710095820979.png" alt="在这里插入图片描述"><br>实现路线：</p>
<ul>
<li>ajax异步请求</li>
<li>trie树数据结构</li>
</ul>
<h1 id="trie"><a href="#trie" class="headerlink" title="trie"></a>trie</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package songsong.host.food.util;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">    public Map&lt;String, Node&gt; nexts; &#x2F;&#x2F; 子节点</span><br><span class="line">    public int end;</span><br><span class="line"></span><br><span class="line">    public Node() &#123;</span><br><span class="line">        this.nexts &#x3D; new HashMap&lt;String, Node&gt;();</span><br><span class="line">        this.end &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Trie &#123;</span><br><span class="line">    private Node root;</span><br><span class="line">    private List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    public Trie()&#123;</span><br><span class="line">       root  &#x3D; new Node();</span><br><span class="line">       list &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        if (word &#x3D;&#x3D; null)</span><br><span class="line">            return;</span><br><span class="line">        Node node &#x3D; root;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">            String str &#x3D; &quot;&quot; + word.charAt(i);</span><br><span class="line">            if (node.nexts.get(str) &#x3D;&#x3D; null)</span><br><span class="line">                node.nexts.put(str, new Node());</span><br><span class="line">            node &#x3D; node.nexts.get(str);</span><br><span class="line">        &#125;</span><br><span class="line">        node.end &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean startWith(String preWord) &#123;</span><br><span class="line">        Node node &#x3D; root;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; preWord.length(); i++) &#123;</span><br><span class="line">            String str &#x3D; &quot;&quot; + preWord.charAt(i);</span><br><span class="line">            if (node.nexts.get(str) &#x3D;&#x3D; null)</span><br><span class="line">                return false;</span><br><span class="line">            node &#x3D; node.nexts.get(str);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; getData(String preword) &#123;</span><br><span class="line">        list.clear();</span><br><span class="line">        if (!startWith(preword))</span><br><span class="line">            return null;</span><br><span class="line">        else &#123;</span><br><span class="line">            StringBuilder str &#x3D; new StringBuilder(&quot;&quot;);</span><br><span class="line">            str.append(preword);</span><br><span class="line">            Node node &#x3D; root;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; preword.length(); i++)</span><br><span class="line">                node &#x3D; node.nexts.get(&quot;&quot; + preword.charAt(i));</span><br><span class="line">            dfs(node, str);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(Node root, StringBuilder str) &#123;</span><br><span class="line">        if (root.end &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            list.add(str.toString());</span><br><span class="line">            if (root.nexts.size() &#x3D;&#x3D; 0)</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line">        Node node &#x3D; root;</span><br><span class="line">        for (String s : node.nexts.keySet()) &#123;</span><br><span class="line">            str.append(s);</span><br><span class="line">            dfs(node.nexts.get(s), str);</span><br><span class="line">            str.delete(str.length() - 1, str.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;ok&quot;);</span><br><span class="line">&#x2F;&#x2F;        Trie test &#x3D; new Trie();</span><br><span class="line">&#x2F;&#x2F;        test.insert(&quot;what&quot;);</span><br><span class="line">&#x2F;&#x2F;        test.insert(&quot;what do you do&quot;);</span><br><span class="line">&#x2F;&#x2F;        test.insert(&quot;what is your name&quot;);</span><br><span class="line">&#x2F;&#x2F;        test.insert(&quot;宫保鸡丁&quot;);</span><br><span class="line">&#x2F;&#x2F;        test.insert(&quot;烧烤&quot;);</span><br><span class="line">&#x2F;&#x2F;        test.insert(&quot;鱼香肉丝&quot;);</span><br><span class="line">&#x2F;&#x2F;        test.insert(&quot;红烧鸡&quot;);</span><br><span class="line">&#x2F;&#x2F;        test.insert(&quot;红焖鸡&quot;);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;输入a&quot;);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(test.getData(&quot;a&quot;));</span><br><span class="line">&#x2F;&#x2F;        System.out.println(test.startWith(&quot;a&quot;));</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有了这就好说了，启动浏览器的时候，直接从数据库的search表里把关键字拿出来构建trie树，当然可以将关键字进行排序等处理，拿热搜等等。ajax异步请求，搜索栏发生变化，补全提示词实时变化。</p>
<h1 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;实现打开浏览器就加载热搜,并构建trie树</span><br><span class="line">	@RequestMapping(&quot;&#x2F;search&quot;)</span><br><span class="line">	public void search(HttpServletResponse response)&#123;</span><br><span class="line">		&#x2F;&#x2F;查询前X的热搜：</span><br><span class="line">		List&lt;Search&gt; searcheList&#x3D;commonService.selectAllSearch(100);</span><br><span class="line">		&#x2F;&#x2F;构建trie树</span><br><span class="line">		for (int i &#x3D; 0;i&lt;searcheList.size();i++) &#123;</span><br><span class="line">			test.insert(searcheList.get(i).getWords());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;给前端写回json数据</span><br><span class="line">	private void writeBack(HttpServletResponse response,Object o)&#123;</span><br><span class="line">        &#x2F;&#x2F;解决：拒绝引用</span><br><span class="line">        String json &#x3D; JSON.toJSONString(o, SerializerFeature.DisableCircularReferenceDetect);</span><br><span class="line">        response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        response.setContentType(&quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line">			response.getWriter().print(json);</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;补全提示</span><br><span class="line">	@RequestMapping(&quot;&#x2F;search&#x2F;&#123;word&#125;&quot;)</span><br><span class="line">	public void search(HttpServletResponse response,@PathVariable(&quot;word&quot;) String word)&#123;</span><br><span class="line">		&#x2F;&#x2F;查询联想词</span><br><span class="line">		List&lt;String&gt; words &#x3D; test.getData(word);</span><br><span class="line">		writeBack(response,words);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="search-js"><a href="#search-js" class="headerlink" title="search.js"></a>search.js</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url : &quot;&#x2F;common&#x2F;search&#x2F;&quot;,</span><br><span class="line">        type : &#39;get&#39;,</span><br><span class="line">        dataType : &#39;json&#39;,</span><br><span class="line">        success : function(data) &#123;</span><br><span class="line">            alert(&quot;构建trie成功！&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(function()&#123;</span><br><span class="line">    $(&#39;#keyword&#39;).blur(function() &#123;</span><br><span class="line">        setTimeout(function() &#123;  &#x2F;&#x2F;进行延时处理，时间单位为千分之一秒</span><br><span class="line">            clearContent();</span><br><span class="line">        &#125;, 500)</span><br><span class="line">    &#125;).focus(function()&#123;</span><br><span class="line">        if($(this).val() !&#x3D; &#39;&#39;)&#123;</span><br><span class="line">            getMoreContents();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#x2F;&#x2F;激活新加进来的元素点击事件</span><br><span class="line">    $(&#39;body&#39;).on(&quot;click&quot;, &quot;#content_table_body tr&quot;, function () &#123;</span><br><span class="line">        var td &#x3D; $(this).find(&quot;td&quot;);</span><br><span class="line">        var data &#x3D; td.eq(0).text();</span><br><span class="line">        $(&quot;#keyword&quot;).val(data.toString());</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function getMoreContents() &#123;</span><br><span class="line">    setLocation();</span><br><span class="line">    var content &#x3D; $(&quot;#keyword&quot;).val();</span><br><span class="line">    if (content &#x3D;&#x3D; &quot;&quot;) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    submit(content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;清空数据</span><br><span class="line">function clearContent() &#123;</span><br><span class="line">    $(&quot;#popdiv&quot;).attr(&quot;style&quot;,&quot;display: none&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function setLocation() &#123;</span><br><span class="line">    &#x2F;&#x2F;关联信息的显示位置</span><br><span class="line">    var content &#x3D; document.getElementById(&quot;keyword&quot;);</span><br><span class="line">    var width &#x3D; content.offsetWidth;&#x2F;&#x2F;输入框的宽度</span><br><span class="line">    $(&quot;#popdiv&quot;).attr(&quot;style&quot;,&quot;position:absolute;z-index: 9999&quot;);</span><br><span class="line"></span><br><span class="line">    document.getElementById(&quot;content_table&quot;).style.width &#x3D; width + &quot;px&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function submit(word) &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url : &quot;&#x2F;common&#x2F;search&#x2F;&quot;+word,</span><br><span class="line">        type : &#39;get&#39;,</span><br><span class="line">        dataType : &#39;json&#39;,</span><br><span class="line">        success : function(data) &#123;</span><br><span class="line">            $(&quot;#content_table_body&quot;).html(&quot;&quot;);</span><br><span class="line">            $.each(data, function (i, item) &#123;</span><br><span class="line">                $(&quot;#content_table_body&quot;).append(searchTable(item));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function searchTable(item)&#123;</span><br><span class="line">    var tr &#x3D; &#39;&lt;tr&gt;&lt;td&gt;&#39;</span><br><span class="line">        + item</span><br><span class="line">        +&#39;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&#39;;</span><br><span class="line">    return tr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="部分html"><a href="#部分html" class="headerlink" title="部分html"></a>部分html</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; th:href&#x3D;&quot;@&#123;&#x2F;css&#x2F;bootstrap.min.css&#125;&quot;&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; th:src&#x3D;&quot;@&#123;&#x2F;js&#x2F;jquery-3.2.1.min.js&#125;&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; th:src&#x3D;&quot;@&#123;&#x2F;js&#x2F;bootstrap.min.js&#125;&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; th:src&#x3D;&quot;@&#123;&#x2F;js&#x2F;search.js&#125;&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;col-lg-5 col-md-8 col-sm-5 m-auto&quot; id&#x3D;&quot;search&quot;&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;&#x2F;common&#x2F;search&#x2F;s&quot;  method&#x3D;&quot;post&quot; class&#x3D;&quot;input-group input-group-lg mt-3&quot;&gt;</span><br><span class="line">					&lt;!--onblur&#x3D;&quot;keywordBlur()&quot; onfocus&#x3D;&quot;getMoreContents()&quot;--&gt;</span><br><span class="line">	&lt;input type&#x3D;&quot;text&quot; autocomplete&#x3D;&#39;off&#39; class&#x3D;&quot;form-control input-lg&quot; id&#x3D;&quot;keyword&quot; name&#x3D;&quot;keyword&quot; onkeyup&#x3D;&quot;getMoreContents()&quot; placeholder&#x3D;&quot;请输入...&quot; &#x2F;&gt;</span><br><span class="line">	&lt;button type&#x3D;&quot;submit&quot; class&#x3D;&quot;btn btn-primary&quot;&gt;搜 索&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;popdiv&quot; class&#x3D;&quot;bg-light text-dark&quot;&gt;</span><br><span class="line">		&lt;table id&#x3D;&quot;content_table&quot; class&#x3D;&quot;table table-hover bg-secondary text-white&quot;&gt;</span><br><span class="line">			&lt;tbody id&#x3D;&quot;content_table_body&quot;&gt;</span><br><span class="line"></span><br><span class="line">			&lt;&#x2F;tbody&gt;</span><br><span class="line">		&lt;&#x2F;table&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="https://img-blog.csdnimg.cn/20200710104440920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200710104447905.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200710104503293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>ajax</tag>
        <tag>trie</tag>
        <tag>智能提示</tag>
      </tags>
  </entry>
  <entry>
    <title>python+django搭建web</title>
    <url>/2020/07/09/python+django%E6%90%AD%E5%BB%BAweb/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>安装Django和pycharm就不说了。<br><img src="https://img-blog.csdnimg.cn/20200709210734130.png" alt="在这里插入图片描述"><br><a href="https://docs.djangoproject.com/en/3.0/intro/tutorial01/">Django官网教程，很详细</a><br><em>注：我一开始用的pycharm社区版，引入bootstrap等文件没有代码补全。然后用破解版pycharm就可以了。（推”程序员的时光”微信公众号有破解教程）</em></p>
<h1 id="创建Django项目"><a href="#创建Django项目" class="headerlink" title="创建Django项目"></a>创建Django项目</h1><p>cd进入存储项目的地方，运行下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">django-admin startproject mytest</span><br></pre></td></tr></table></figure>
<p>生成一些算是配置文件吧<br><img src="https://img-blog.csdnimg.cn/2020070921133199.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200709211414737.png" alt="在这里插入图片描述"><br>在manage.py所在目录运行下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>
<p>浏览器访问：<a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a>  ，出现下图，空项目算是完成了。<br><img src="https://img-blog.csdnimg.cn/2020070921182132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h1><h2 id="创建应用程序-实现记录体温"><a href="#创建应用程序-实现记录体温" class="headerlink" title="创建应用程序,实现记录体温"></a>创建应用程序,实现记录体温</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py startapp 应用名</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200709212319399.png" alt="在这里插入图片描述"></p>
<h2 id="用pycharm打开应用程序"><a href="#用pycharm打开应用程序" class="headerlink" title="用pycharm打开应用程序"></a>用pycharm打开应用程序</h2><p>打开models.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Temperature(models.Model):</span><br><span class="line">    morning &#x3D; models.CharField(max_length&#x3D;10)</span><br><span class="line">    noon &#x3D; models.CharField(max_length&#x3D;10)</span><br><span class="line">    evening &#x3D; models.CharField(max_length&#x3D;10)</span><br><span class="line">    time &#x3D; models.CharField(max_length&#x3D;100)</span><br></pre></td></tr></table></figure>

<h2 id="更换mysql"><a href="#更换mysql" class="headerlink" title="更换mysql"></a>更换mysql</h2><p>在<strong>init</strong>.py中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">pymysql.version_info &#x3D; (1, 3, 13, &quot;final&quot;, 0)</span><br><span class="line"></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>

<p>项目的settings.py文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DATABASES &#x3D; &#123;</span><br><span class="line">    &#39;default&#39;: &#123;</span><br><span class="line">        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,</span><br><span class="line">        &#39;NAME&#39;: &#39;test&#39;,        #数据库名字</span><br><span class="line">        &#39;USER&#39;: &#39;root&#39;,          #账号</span><br><span class="line">        &#39;PASSWORD&#39;: &#39;123456&#39;,      #密码</span><br><span class="line">        &#39;HOST&#39;: &#39;127.0.0.1&#39;,    #IP</span><br><span class="line">        &#39;PORT&#39;: &#39;3306&#39;,                   #端口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#要将应用程序包含在我们的项目中</span><br><span class="line">INSTALLED_APPS &#x3D; [</span><br><span class="line">    &#39;应用名.apps.应用名Config&#39;,</span><br><span class="line">    &#39;django.contrib.admin&#39;,</span><br><span class="line">    &#39;django.contrib.auth&#39;,</span><br><span class="line">    &#39;django.contrib.contenttypes&#39;,</span><br><span class="line">    &#39;django.contrib.sessions&#39;,</span><br><span class="line">    &#39;django.contrib.messages&#39;,</span><br><span class="line">    &#39;django.contrib.staticfiles&#39;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">#改为中国时区</span><br><span class="line">LANGUAGE_CODE &#x3D; &#39;zh-hans&#39;</span><br><span class="line"> </span><br><span class="line">TIME_ZONE &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line"> </span><br><span class="line">USE_I18N &#x3D; True</span><br><span class="line"> </span><br><span class="line">USE_L10N &#x3D; True</span><br><span class="line"> </span><br><span class="line">USE_TZ &#x3D; False</span><br></pre></td></tr></table></figure>

<p>执行如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations 应用名</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>
<p>去MySQL看，会生成数据库表<br>在migrations文件夹下会有0001等的编号，可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py sqlmigrate 应用名 0001</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>
<h2 id="Django有自动的后台管理"><a href="#Django有自动的后台管理" class="headerlink" title="Django有自动的后台管理"></a>Django有自动的后台管理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br><span class="line">Username: admin</span><br><span class="line">Password: **********</span><br><span class="line">Password (again): *********</span><br><span class="line">Superuser created successfully.</span><br></pre></td></tr></table></figure>
<p>打开admin.py：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from django.contrib import admin</span><br><span class="line">from . import models</span><br><span class="line"></span><br><span class="line">admin.site.register(models.Temperature)</span><br></pre></td></tr></table></figure>

<p>进入管理界面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br><span class="line"> http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;admin&#x2F;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200709215733882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="请求路径"><a href="#请求路径" class="headerlink" title="请求路径"></a>请求路径</h2><p>打开urls.py文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line"></span><br><span class="line">from django.conf.urls import url</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">app_name &#x3D; &#39;polls&#39;</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^$&#39;, views.show),  # 页面展示</span><br><span class="line">    url(r&#39;^add&#x2F;&#39;, views.addTemperature),</span><br><span class="line">    url(r&#39;^index&#x2F;&#39;, views.index2),</span><br><span class="line">    url(r&#39;^look&#39;, views.look),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>打开项目的（不是应用程序的）urls.py文件：<br>将应用的请求路径包含进去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    path(&#39;polls&#x2F;&#39;, include(&#39;polls.urls&#39;)),</span><br><span class="line">    path(&#39;admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>我这里则为，所有应用请求都是<a href="http://127.0.0.1:8000/polls/">http://127.0.0.1:8000/polls/</a>…<br>管理为：<a href="http://127.0.0.1:8000/admin">http://127.0.0.1:8000/admin</a></p>
<h2 id="html页面"><a href="#html页面" class="headerlink" title="html页面"></a>html页面</h2><p>templates文件下新建一个与应用同名的文件（我也不知道为什么这样？？），然后在下面新建<br>index.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">      &lt;link href&#x3D;&quot;&#x2F;static&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">       &lt;script src&#x3D;&quot;&#x2F;static&#x2F;js&#x2F;jquery-3.2.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">       &lt;script src&#x3D;&quot;&#x2F;static&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap-datetimepicker&#x2F;4.17.47&#x2F;css&#x2F;bootstrap-datetimepicker.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">       &lt;script src&#x3D;&quot;&#x2F;static&#x2F;js&#x2F;moment-with-locales.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap-datetimepicker&#x2F;4.17.47&#x2F;js&#x2F;bootstrap-datetimepicker.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;container-fluid&quot;&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;h1 class&#x3D;&quot;row col-2 m-auto&quot;&gt;体温录入&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;form action&#x3D;&quot;&#x2F;polls&#x2F;add&#x2F;&quot; method&#x3D;&quot;post&quot; class&#x3D;&quot;col-4 m-auto&quot;&gt;</span><br><span class="line">             &#123;% csrf_token %&#125;</span><br><span class="line">          &lt;div class&#x3D;&quot;input-group mb-3&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;input-group-prepend&quot;&gt;</span><br><span class="line">              &lt;span class&#x3D;&quot;input-group-text&quot;&gt;上午&lt;&#x2F;span&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;morning&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;请输入温度&quot;&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">          &lt;div class&#x3D;&quot;input-group mb-3&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;input-group-prepend&quot;&gt;</span><br><span class="line">              &lt;span class&#x3D;&quot;input-group-text&quot;&gt;中午&lt;&#x2F;span&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;noon&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;请输入温度&quot;&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div class&#x3D;&quot;input-group mb-3&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;input-group-prepend&quot;&gt;</span><br><span class="line">              &lt;span class&#x3D;&quot;input-group-text&quot;&gt;下午&lt;&#x2F;span&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;evening&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;请输入温度&quot;&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div class&#x3D;&quot;row&quot;&gt;</span><br><span class="line">                &lt;div class&#x3D;&#39;col-sm-6&#39;&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;form-group&quot;&gt;</span><br><span class="line">                        &lt;label&gt;选择日期+时间：&lt;&#x2F;label&gt;</span><br><span class="line">                        &lt;!--指定 date标记--&gt;</span><br><span class="line">                        &lt;div class&#x3D;&#39;input-group date&#39; id&#x3D;&#39;datetimepicker2&#39;&gt;</span><br><span class="line">                            &lt;input type&#x3D;&#39;text&#39; name&#x3D;&quot;time&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;获取时间&quot; &#x2F;&gt;</span><br><span class="line">                            &lt;span class&#x3D;&quot;input-group-addon&quot;&gt;</span><br><span class="line">                                &lt;span class&#x3D;&quot;glyphicon glyphicon-calendar&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">                            &lt;&#x2F;span&gt;</span><br><span class="line">                        &lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">             &lt;script&gt;</span><br><span class="line">                $(function () &#123;</span><br><span class="line">                    $(&#39;#datetimepicker2&#39;).datetimepicker(&#123;</span><br><span class="line">                        format: &#39;YYYY-MM-DD hh:mm&#39;,</span><br><span class="line">                        locale: moment.locale(&#39;zh-cn&#39;)</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">             &lt;button type&#x3D;&quot;submit&quot; class&#x3D;&quot;col-12 btn btn-primary&quot;&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;form&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>success.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;&#x2F;static&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">       &lt;script src&#x3D;&quot;&#x2F;static&#x2F;js&#x2F;jquery-3.2.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">       &lt;script src&#x3D;&quot;&#x2F;static&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">      &lt;script src&#x3D;&quot;&#x2F;static&#x2F;js&#x2F;echarts.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">     &lt;script src&#x3D;&quot;&#x2F;static&#x2F;js&#x2F;chart.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;container-fluid&quot;&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;h1 class&#x3D;&quot;col-4 m-auto text-center text-success&quot;&gt;体温记录成功&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;col-12 m-auto&quot; id&#x3D;&quot;box&quot; style&#x3D;&quot;width: 1000px;height: 500px;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>chart.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function () &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &quot;&#x2F;polls&#x2F;look&quot;,</span><br><span class="line">        type: &#39;get&#39;,</span><br><span class="line">        dataType: &#39;json&#39;,</span><br><span class="line">        success: function (data) &#123;</span><br><span class="line">            &#x2F;&#x2F; alert(&quot;成功！&quot;)</span><br><span class="line">            &#x2F;&#x2F; alert(&quot;上午&quot;+data.list[0].morning+&quot;下午&quot;+data.list[0].noon+&quot;时间&quot;+data.list[0].time)</span><br><span class="line">            lineChart(data.list);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: function () &#123;</span><br><span class="line">            alert(&quot;失败！&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">&#x2F;&#x2F;初始化ehcharts实例</span><br><span class="line">    var myChart&#x3D;echarts.init(document.getElementById(&quot;box&quot;));</span><br><span class="line">    &#x2F;&#x2F;指定图表的配置项和数据</span><br><span class="line">    var option&#x3D;&#123;</span><br><span class="line">        &#x2F;&#x2F;标题</span><br><span class="line">        title:&#123;</span><br><span class="line">          text:&#39;生鲜销量统计&#39;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F;工具箱</span><br><span class="line">        &#x2F;&#x2F;保存图片</span><br><span class="line">        toolbox:&#123;</span><br><span class="line">            show:true,</span><br><span class="line">            feature:&#123;</span><br><span class="line">                saveAsImage:&#123;</span><br><span class="line">                    show:true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F;图例-每一条数据的名字叫销量</span><br><span class="line">        legend:&#123;</span><br><span class="line">            data:[&#39;销量&#39;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F;x轴</span><br><span class="line">        xAxis:&#123;</span><br><span class="line">            data:[&quot;苹果&quot;,&quot;橘子&quot;,&quot;橙子&quot;,&quot;香蕉&quot;,&quot;菠萝&quot;,&quot;榴莲&quot;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F;y轴没有显式设置，根据值自动生成y轴</span><br><span class="line">        yAxis:&#123;&#125;,</span><br><span class="line">        &#x2F;&#x2F;数据-data是最终要显示的数据</span><br><span class="line">        series:[&#123;</span><br><span class="line">            name:&#39;销量&#39;,</span><br><span class="line">            type:&#39;line&#39;,</span><br><span class="line">            data:[40,20,35,60,55,10]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;使用刚刚指定的配置项和数据项显示图表</span><br><span class="line">    myChart.setOption(option);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;JS成功后的代码</span><br><span class="line">function lineChart(result)&#123;</span><br><span class="line">    &#x2F;&#x2F;获取dom容器</span><br><span class="line">    var myChart &#x3D; echarts.init(document.getElementById(&#39;box&#39;));</span><br><span class="line">    option &#x3D; &#123;</span><br><span class="line">        title: &#123;</span><br><span class="line">            text: &#39;体温变化图&#39;,</span><br><span class="line">            &#x2F;&#x2F; subtext: &#39;数据来源个人采集&#39;,</span><br><span class="line">        &#125;,</span><br><span class="line">        grid: &#123;</span><br><span class="line">            left: &#39;3%&#39;,</span><br><span class="line">            right: &#39;4%&#39;,</span><br><span class="line">            bottom: &#39;3%&#39;,</span><br><span class="line">            containLabel: true</span><br><span class="line">        &#125;,</span><br><span class="line">        toolbox: &#123;</span><br><span class="line">            feature: &#123;</span><br><span class="line">                saveAsImage: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        legend: &#123;</span><br><span class="line">            data: [&#39;上午&#39;, &#39;下午&#39;, &#39;晚上&#39;]</span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: &#123; &#x2F;&#x2F;跟随鼠标显示数值</span><br><span class="line">            trigger: &#39;axis&#39;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;保存图片</span><br><span class="line">        toolbox: &#123;</span><br><span class="line">            feature: &#123;</span><br><span class="line">                saveAsImage: &#123;</span><br><span class="line">                    name:&#39;体温表&#39;, &#x2F;&#x2F;图片名</span><br><span class="line">                    pixelRatio:2</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        xAxis: &#123;</span><br><span class="line">            name:&quot;时间&quot;,</span><br><span class="line">            type: &#39;category&#39;,</span><br><span class="line">            data:(function()&#123;</span><br><span class="line">                var res &#x3D; [];</span><br><span class="line">                for(var i&#x3D;0;i&lt;result.length;i++) &#123;</span><br><span class="line">                    res.push(result[i].time);</span><br><span class="line">                &#125;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;)()</span><br><span class="line">        &#125;,</span><br><span class="line">        yAxis: &#123;</span><br><span class="line">            name:&quot;摄氏度&quot;,</span><br><span class="line">            type: &#39;value&#39;,</span><br><span class="line">             scale : true,</span><br><span class="line">            max : 40,</span><br><span class="line">            min : 35,</span><br><span class="line">            splitNumber : 10,</span><br><span class="line">            boundaryGap : [ 0.2, 0.2 ]</span><br><span class="line">        &#125;,</span><br><span class="line">        series: [</span><br><span class="line">            &#123;</span><br><span class="line">                name:&quot;上午&quot;,</span><br><span class="line">                type: &#39;line&#39;,</span><br><span class="line">                data:(function()&#123;</span><br><span class="line">                    var res &#x3D; [];</span><br><span class="line">                    for(var i&#x3D;0;i&lt;result.length;i++) &#123;</span><br><span class="line">                        res.push(result[i].morning);</span><br><span class="line">                    &#125;</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;)()</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name: &#39;下午&#39;,</span><br><span class="line">                type: &#39;line&#39;,</span><br><span class="line">                data:(function()&#123;</span><br><span class="line">                    var res &#x3D; [];</span><br><span class="line">                    for(var i&#x3D;0;i&lt;result.length;i++) &#123;</span><br><span class="line">                        res.push(result[i].noon);</span><br><span class="line">                    &#125;</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;)()</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name: &#39;晚上&#39;,</span><br><span class="line">                type: &#39;line&#39;,</span><br><span class="line">                data:(function()&#123;</span><br><span class="line">                    var res &#x3D; [];</span><br><span class="line">                    for(var i&#x3D;0;i&lt;result.length;i++) &#123;</span><br><span class="line">                        res.push(result[i].evening);</span><br><span class="line">                    &#125;</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;)()</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 使用刚指定的配置项和数据显示图表。</span><br><span class="line">    myChart.setOption(option);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><em>注意：没有的js百度下载一下！</em></strong></p>
<h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><p>打开应用的views.py文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">from django.http import HttpResponse, Http404, HttpResponseRedirect, JsonResponse</span><br><span class="line">from django.template import loader</span><br><span class="line">from django.shortcuts import get_object_or_404, render, redirect</span><br><span class="line">from django.urls import reverse</span><br><span class="line">from django.views import generic</span><br><span class="line"></span><br><span class="line">from .models import  Temperature</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    pass</span><br><span class="line">    return render(request, &#39;应用名&#x2F;index.html&#39;)</span><br><span class="line"></span><br><span class="line">def addTemperature(request):</span><br><span class="line"></span><br><span class="line">    morning &#x3D; request.POST.get(&#39;morning&#39;, &quot;&quot;);</span><br><span class="line">    noon &#x3D; request.POST.get(&#39;noon&#39;, &quot;&quot;);</span><br><span class="line">    evening &#x3D; request.POST.get(&#39;evening&#39;, &quot;&quot;);</span><br><span class="line">    time &#x3D; request.POST.get(&#39;time&#39;, &quot;&quot;);</span><br><span class="line">    temperature &#x3D; Temperature(morning&#x3D;morning, noon&#x3D;noon,evening&#x3D;evening,time &#x3D; time);</span><br><span class="line">    temperature.save();</span><br><span class="line"></span><br><span class="line">    return render(request, &#39;应用名&#x2F;success.html&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def look(request):</span><br><span class="line">    data &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    book &#x3D; Temperature.objects.values()</span><br><span class="line"></span><br><span class="line">    data[&#39;list&#39;] &#x3D; list(book)</span><br><span class="line"></span><br><span class="line">    return JsonResponse(data)</span><br><span class="line">    # if request.is_ajax():</span><br><span class="line">    #</span><br><span class="line">    #     &quot;&quot;&quot;以json形式返回列表&quot;&quot;&quot;</span><br><span class="line">    #     # 1. 获取所有对象</span><br><span class="line">    #     # objects.all()  queryset类型的对象，不能直接json</span><br><span class="line">    #     queryset &#x3D; Temperature.objects.all().values(&#39;morning&#39;,&quot;noon&quot;,&#39;time&#39;,)</span><br><span class="line">    #     # 2. 将数据序列化成json格式   date类型的数据不能直接系列化 ensure_ascii&#x3D;False 修改乱码的现象</span><br><span class="line">    #     ret &#x3D; json.dumps(list(queryset), ensure_ascii&#x3D;False)</span><br><span class="line">    #     # 3. 返回</span><br><span class="line">    #     response &#x3D; JsonResponse(&#123;&quot;ret&quot;:ret&#125;)</span><br><span class="line">    #     return response</span><br><span class="line">    #return HttpResponse(&#123;&quot;temp&quot;:ret&#125;)</span><br><span class="line">    # a &#x3D; Temperature.objects.all()</span><br><span class="line">    # return render(request, &#39;polls&#x2F;success.html&#39;,&#123;</span><br><span class="line">    #     &#39;data&#39;:a</span><br><span class="line">    # &#125;)</span><br><span class="line"></span><br><span class="line">def show(request):</span><br><span class="line">    return render(request, &#39;应用名&#x2F;success.html&#39;)</span><br></pre></td></tr></table></figure>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;polls&#x2F;index&#x2F;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020070922212264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;polls&#x2F;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200709222221904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>大概流程就是这样！</p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟微信抢红包</title>
    <url>/2020/04/22/%E6%A8%A1%E6%8B%9F%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package qianghongbao;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class HongBao &#123;</span><br><span class="line">    private double remainMoney;  &#x2F;&#x2F;剩余的钱</span><br><span class="line">    private int remainSize;      &#x2F;&#x2F;剩余的红包数量</span><br><span class="line"></span><br><span class="line">    public HongBao(double total, int count) &#123;</span><br><span class="line">        this.remainMoney &#x3D; total;</span><br><span class="line">        this.remainSize &#x3D; count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getRemainMoney() &#123;</span><br><span class="line">        return remainMoney;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getRemainSize() &#123;</span><br><span class="line">        return remainSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getRandomMoney()&#123;</span><br><span class="line"></span><br><span class="line">        double money;</span><br><span class="line">        if(remainSize &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            remainSize--;</span><br><span class="line">            money &#x3D; (double)Math.round(remainMoney * 100 )&#x2F;100;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(remainSize &gt; 1)&#123;</span><br><span class="line">            double min &#x3D; 0.01;</span><br><span class="line">            double max &#x3D; remainMoney &#x2F; remainSize * 2;</span><br><span class="line">            money &#x3D; new Random().nextDouble() * max;</span><br><span class="line">            money &#x3D; money &lt;&#x3D; min ? min : money;</span><br><span class="line">            money &#x3D; Math.floor(money * 100) &#x2F; 100;</span><br><span class="line">            remainSize--;</span><br><span class="line">            remainMoney -&#x3D; money;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            money &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F;        System.out.println(Thread.currentThread().getName()+</span><br><span class="line">&#x2F;&#x2F;                &quot;抢到&quot;+money+&quot;元，红包剩余&quot;+remainSize+&quot;个&quot;);</span><br><span class="line">        return money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package qianghongbao;</span><br><span class="line"></span><br><span class="line">public class UserThread implements Runnable&#123;</span><br><span class="line">    private HongBao hongBao;</span><br><span class="line">    private double max &#x3D; -1;</span><br><span class="line">    String king &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public UserThread(HongBao hongBao) &#123;</span><br><span class="line">        this.hongBao &#x3D; hongBao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getKing() &#123;</span><br><span class="line">        return king;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line">            double money &#x3D; hongBao.getRandomMoney();</span><br><span class="line">            if(money &gt; max)&#123;</span><br><span class="line">                max &#x3D; money;</span><br><span class="line">                king &#x3D; Thread.currentThread().getName();</span><br><span class="line">            &#125;</span><br><span class="line">            if(money &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                System.out.println(&quot;时刻&quot;+System.currentTimeMillis()+&quot;,&quot;+</span><br><span class="line">                        Thread.currentThread().getName() + &quot;:你们是坐在路由器上抢的吗！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                System.out.println(&quot;时刻&quot;+System.currentTimeMillis()+&quot;,&quot;+</span><br><span class="line">                        Thread.currentThread().getName() +</span><br><span class="line">                        &quot;:抢到 &quot; + money + &quot;元,红包剩余&quot;+hongBao.getRemainSize()+&quot;个&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package qianghongbao;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class QiangHongBao &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">        System.out.println(&quot;请输入红包金额红包个数&quot;);</span><br><span class="line">        Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">        double total &#x3D; sc.nextDouble();</span><br><span class="line">        int count &#x3D; sc.nextInt();</span><br><span class="line"></span><br><span class="line">        HongBao hongBao &#x3D;new HongBao(total,count);</span><br><span class="line">        UserThread user &#x3D; new UserThread(hongBao);</span><br><span class="line">        System.out.println(&quot;请输入模拟抢红包人数&quot;);</span><br><span class="line">        int num &#x3D; sc.nextInt();</span><br><span class="line">        for(int i&#x3D;0;i&lt;num;i++) &#123;</span><br><span class="line">            new Thread(user).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        System.out.println(&quot;运气王：&quot;+user.getKing());</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200422140648771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>多线程</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码分析——BeanFactory体系</title>
    <url>/2020/03/31/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94BeanFactory%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/2020033122152054.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>**</strong>以下内容转载自：***<br>/**</p>
<ul>
<li>  <strong><em>————————如果觉得本博文还行，别忘了推荐一下哦，谢谢！</em></strong></li>
<li>  <strong><em>作者：钱书康</em></strong></li>
<li>  <strong><em>欢迎转载，请保留此段声明。</em></strong></li>
<li>  <strong><em>出处：<a href="http://www.cnblogs.com/zrtqsk/">http://www.cnblogs.com/zrtqsk/</a></em></strong></li>
<li>/***</li>
</ul>
<h1 id="一、BeanFactory的基本类体系结构（接口为主）："><a href="#一、BeanFactory的基本类体系结构（接口为主）：" class="headerlink" title="一、BeanFactory的基本类体系结构（接口为主）："></a>一、BeanFactory的基本类体系结构（接口为主）：</h1><p><img src="https://img-blog.csdnimg.cn/20200331222517144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　　具体：<br>　　1、BeanFactory作为一个主接口不继承任何接口，暂且称为一级接口。<br>　　2、有3个子接口继承了它，进行功能上的增强。这3个子接口称为二级接口。<br>　　3、ConfigurableBeanFactory可以被称为三级接口，对二级接口HierarchicalBeanFactory进行了再次增强，它还继承了另一个外来的接口SingletonBeanRegistry<br>　　4、ConfigurableListableBeanFactory是一个更强大的接口，继承了上述的所有接口，无所不包，称为四级接口。<br>　　（这4级接口是BeanFactory的基本接口体系。继续，下面是继承关系的2个抽象类和2个实现类：）<br>　　5、AbstractBeanFactory作为一个抽象类，实现了三级接口ConfigurableBeanFactory大部分功能。<br>　　6、AbstractAutowireCapableBeanFactory同样是抽象类，继承自AbstractBeanFactory，并额外实现了二级接口AutowireCapableBeanFactory<br>　　7、DefaultListableBeanFactory继承自AbstractAutowireCapableBeanFactory，实现了最强大的四级接口ConfigurableListableBeanFactory，并实现了一个外来接口BeanDefinitionRegistry，它并非抽象类。<br>　　8、最后是最强大的XmlBeanFactory，继承自DefaultListableBeanFactory，重写了一些功能，使自己更强大。<br>总结：BeanFactory的类体系结构看似繁杂混乱，实际上由上而下井井有条，非常容易理解。</p>
<h1 id="二、IOC的始祖——BeanFactory"><a href="#二、IOC的始祖——BeanFactory" class="headerlink" title="二、IOC的始祖——BeanFactory"></a>二、IOC的始祖——BeanFactory</h1><p>来看一下BeanFactory的源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line">public interface BeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用来引用一个实例，或把它和工厂产生的Bean区分开，就是说，如果一个FactoryBean的名字为a，那么，&amp;a会得到那个Factory</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String FACTORY_BEAN_PREFIX &#x3D; &quot;&amp;&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 四个不同形式的getBean方法，获取实例</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object getBean(String name) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;</span><br><span class="line"></span><br><span class="line">    Object getBean(String name, Object... args) throws BeansException;</span><br><span class="line"></span><br><span class="line">    boolean containsBean(String name); &#x2F;&#x2F; 是否存在</span><br><span class="line"></span><br><span class="line">    boolean isSingleton(String name) throws NoSuchBeanDefinitionException;&#x2F;&#x2F; 是否为单实例</span><br><span class="line"></span><br><span class="line">    boolean isPrototype(String name) throws NoSuchBeanDefinitionException;&#x2F;&#x2F; 是否为原型（多实例）</span><br><span class="line"></span><br><span class="line">    boolean isTypeMatch(String name, Class&lt;?&gt; targetType)</span><br><span class="line">            throws NoSuchBeanDefinitionException;&#x2F;&#x2F; 名称、类型是否匹配</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; &#x2F;&#x2F; 获取类型</span><br><span class="line"></span><br><span class="line">    String[] getAliases(String name);&#x2F;&#x2F; 根据实例的名字获取实例的别名</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体：<br>　　1、4个获取实例的方法。getBean的重载方法。<br>　　2、4个判断的方法。判断是否存在，是否为单例、原型，名称类型是否匹配。<br>　　3、1个获取类型的方法、一个获取别名的方法。根据名称获取类型、根据名称获取别名。一目了然！<br>总结：<br>　　这10个方法，很明显，这是一个典型的工厂模式的工厂接口。</p>
<h1 id="三、可将Bean逐一列出的工厂——ListableBeanFactory"><a href="#三、可将Bean逐一列出的工厂——ListableBeanFactory" class="headerlink" title="三、可将Bean逐一列出的工厂——ListableBeanFactory"></a>三、可将Bean逐一列出的工厂——ListableBeanFactory</h1><p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ListableBeanFactory extends BeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    boolean containsBeanDefinition(String beanName); &#x2F;&#x2F; 对于给定的名字是否含有BeanDefinition</span><br><span class="line"></span><br><span class="line">    int getBeanDefinitionCount(); &#x2F;&#x2F; 返回工厂的BeanDefinition总数</span><br><span class="line"></span><br><span class="line">    String[] getBeanDefinitionNames(); &#x2F;&#x2F; 返回工厂中所有Bean的名字</span><br><span class="line"></span><br><span class="line">    String[] getBeanNamesForType(Class&lt;?&gt; type); &#x2F;&#x2F; 返回对于指定类型Bean（包括子类）的所有名字</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 返回指定类型的名字 includeNonSingletons为false表示只取单例Bean，true则不是</span><br><span class="line">     * allowEagerInit为true表示立刻加载，false表示延迟加载。 注意：FactoryBeans都是立刻加载的。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String[] getBeanNamesForType(Class&lt;?&gt; type, boolean includeNonSingletons,</span><br><span class="line">            boolean allowEagerInit);</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(Class&lt;T&gt; type) throws BeansException; &#x2F;&#x2F; 根据类型（包括子类）返回指定Bean名和Bean的Map</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(Class&lt;T&gt; type,</span><br><span class="line">            boolean includeNonSingletons, boolean allowEagerInit)</span><br><span class="line">            throws BeansException;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; getBeansWithAnnotation(</span><br><span class="line">            Class&lt;? extends Annotation&gt; annotationType) throws BeansException; &#x2F;&#x2F; 根据注解类型，查找所有有这个注解的Bean名和Bean的Map</span><br><span class="line"></span><br><span class="line">    &lt;A extends Annotation&gt; A findAnnotationOnBean(String beanName,</span><br><span class="line">            Class&lt;A&gt; annotationType);&#x2F;&#x2F; 根据指定Bean名和注解类型查找指定的Bean</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>具体：<br>　　1、3个跟BeanDefinition有关的总体操作。包括BeanDefinition的总数、名字的集合、指定类型的名字的集合。<br>　　（这里指出，BeanDefinition是Spring中非常重要的一个类，每个BeanDefinition实例都包含一个类在Spring工厂中所有属性。）<br>　　2、2个getBeanNamesForType重载方法。根据指定类型（包括子类）获取其对应的所有Bean名字。<br>　　3、2个getBeansOfType重载方法。根据类型（包括子类）返回指定Bean名和Bean的Map。<br>　　4、2个跟注解查找有关的方法。根据注解类型，查找Bean名和Bean的Map。以及根据指定Bean名和注解类型查找指定的Bean。<br>总结：<br>　　正如这个工厂接口的名字所示，这个工厂接口最大的特点就是可以列出工厂可以生产的所有实例。当然，工厂并没有直接提供返回所有实例的方法，也没这个必要。它可以返回指定类型的所有的实例。而且你可以通过getBeanDefinitionNames()得到工厂所有bean的名字，然后根据这些名字得到所有的Bean。这个工厂接口扩展了BeanFactory的功能，作为上文指出的BeanFactory二级接口，有9个独有的方法，扩展了跟BeanDefinition的功能，提供了BeanDefinition、BeanName、注解有关的各种操作。它可以根据条件返回Bean的集合，这就是它名字的由来——ListableBeanFactory。</p>
<h1 id="四、分层的Bean工厂——HierarchicalBeanFactory"><a href="#四、分层的Bean工厂——HierarchicalBeanFactory" class="headerlink" title="四、分层的Bean工厂——HierarchicalBeanFactory"></a>四、分层的Bean工厂——HierarchicalBeanFactory</h1><p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface HierarchicalBeanFactory extends BeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    BeanFactory getParentBeanFactory();    &#x2F;&#x2F;  返回本Bean工厂的父工厂</span><br><span class="line"></span><br><span class="line">    boolean containsLocalBean(String name);    &#x2F;&#x2F;  本地工厂是否包含这个Bean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 具体：<br>　　1、第一个方法返回本Bean工厂的父工厂。这个方法实现了工厂的分层。<br>　　2、第二个方法判断本地工厂是否包含这个Bean（忽略其他所有父工厂）。这也是分层思想的体现。<br>总结：这个工厂接口非常简单，实现了Bean工厂的分层。这个工厂接口也是继承自BeanFacotory，也是一个二级接口，相对于父接口，它只扩展了一个重要的功能——工厂分层。</p>
<h1 id="五、自动装配的Bean工厂——AutowireCapableBeanFactory"><a href="#五、自动装配的Bean工厂——AutowireCapableBeanFactory" class="headerlink" title="五、自动装配的Bean工厂——AutowireCapableBeanFactory"></a>五、自动装配的Bean工厂——AutowireCapableBeanFactory</h1><p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface AutowireCapableBeanFactory extends BeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    int AUTOWIRE_NO &#x3D; 0;   &#x2F;&#x2F;  这个常量表明工厂没有自动装配的Bean</span><br><span class="line"></span><br><span class="line">    int AUTOWIRE_BY_NAME &#x3D; 1;  &#x2F;&#x2F;表明根据名称自动装配</span><br><span class="line"></span><br><span class="line">    int AUTOWIRE_BY_TYPE &#x3D; 2;  &#x2F;&#x2F;表明根据类型自动装配</span><br><span class="line"></span><br><span class="line">    int AUTOWIRE_CONSTRUCTOR &#x3D; 3;  &#x2F;&#x2F;表明根据构造方法快速装配</span><br><span class="line">    @Deprecated</span><br><span class="line">    int AUTOWIRE_AUTODETECT &#x3D; 4;   &#x2F;&#x2F;表明通过Bean的class的内部来自动装配（有没翻译错...）Spring3.0被弃用。</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T createBean(Class&lt;T&gt; beanClass) throws BeansException;    &#x2F;&#x2F;  根据指定Class创建一个全新的Bean实例</span><br><span class="line"></span><br><span class="line">    void autowireBean(Object existingBean) throws BeansException;  &#x2F;&#x2F;  给定对象，根据注释、后处理器等，进行自动装配</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 根据Bean名的BeanDefinition装配这个未加工的Object，执行回调和各种后处理器。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object configureBean(Object existingBean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 分解Bean在工厂中定义的这个指定的依赖descriptor</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object resolveDependency(DependencyDescriptor descriptor, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 根据给定的类型和指定的装配策略，创建一个新的Bean实例</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object createBean(Class&lt;?&gt; beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 与上面类似，不过稍有不同。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object autowire(Class&lt;?&gt; beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 根据名称或类型自动装配</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)</span><br><span class="line">            throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 也是自动装配</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 初始化一个Bean...</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object initializeBean(Object existingBean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 初始化之前执行BeanPostProcessors</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)</span><br><span class="line">            throws BeansException;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 初始化之后执行BeanPostProcessors</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)</span><br><span class="line">            throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 分解指定的依赖</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object resolveDependency(DependencyDescriptor descriptor, String beanName,</span><br><span class="line">            Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 具体：<br>　　1、总共5个静态不可变常量来指明装配策略，其中一个常量被Spring3.0废弃、一个常量表示没有自动装配，另外3个常量指明不同的装配策略——根据名称、根据类型、根据构造方法。<br>　　2、8个跟自动装配有关的方法，实在是繁杂，具体的意义我们研究类的时候再分辨吧。<br>　　3、2个执行BeanPostProcessors的方法。<br>　　4、2个分解指定依赖的方法<br>总结：这个工厂接口继承自BeanFacotory，它扩展了自动装配的功能，根据类定义BeanDefinition装配Bean、执行前、后处理器等。</p>
<h1 id="六、复杂的配置Bean工厂——ConfigurableBeanFactory"><a href="#六、复杂的配置Bean工厂——ConfigurableBeanFactory" class="headerlink" title="六、复杂的配置Bean工厂——ConfigurableBeanFactory"></a>六、复杂的配置Bean工厂——ConfigurableBeanFactory</h1><p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ConfigurableBeanFactory extends HierarchicalBeanFactory, SingletonBeanRegistry &#123;</span><br><span class="line"></span><br><span class="line">    String SCOPE_SINGLETON &#x3D; &quot;singleton&quot;;  &#x2F;&#x2F;  单例</span><br><span class="line">    String SCOPE_PROTOTYPE &#x3D; &quot;prototype&quot;;  &#x2F;&#x2F;  原型</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 搭配HierarchicalBeanFactory接口的getParentBeanFactory方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void setParentBeanFactory(BeanFactory parentBeanFactory) throws IllegalStateException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 设置、返回工厂的类加载器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void setBeanClassLoader(ClassLoader beanClassLoader);</span><br><span class="line"></span><br><span class="line">    ClassLoader getBeanClassLoader();</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 设置、返回一个临时的类加载器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void setTempClassLoader(ClassLoader tempClassLoader);</span><br><span class="line"></span><br><span class="line">    ClassLoader getTempClassLoader();</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 设置、是否缓存元数据，如果false，那么每次请求实例，都会从类加载器重新加载（热加载）</span><br><span class="line"></span><br><span class="line">     *&#x2F;</span><br><span class="line">    void setCacheBeanMetadata(boolean cacheBeanMetadata);</span><br><span class="line">    </span><br><span class="line">    boolean isCacheBeanMetadata();&#x2F;&#x2F;是否缓存元数据</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Bean表达式分解器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void setBeanExpressionResolver(BeanExpressionResolver resolver);</span><br><span class="line">    </span><br><span class="line">    BeanExpressionResolver getBeanExpressionResolver();</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 设置、返回一个转换服务</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void setConversionService(ConversionService conversionService);</span><br><span class="line"></span><br><span class="line">    ConversionService getConversionService();</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 设置属性编辑登记员...</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void addPropertyEditorRegistrar(PropertyEditorRegistrar registrar);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 注册常用属性编辑器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void registerCustomEditor(Class&lt;?&gt; requiredType, Class&lt;? extends PropertyEditor&gt; propertyEditorClass);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 用工厂中注册的通用的编辑器初始化指定的属性编辑注册器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void copyRegisteredEditorsTo(PropertyEditorRegistry registry);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 设置、得到一个类型转换器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void setTypeConverter(TypeConverter typeConverter);</span><br><span class="line"></span><br><span class="line">    TypeConverter getTypeConverter();</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 增加一个嵌入式的StringValueResolver</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void addEmbeddedValueResolver(StringValueResolver valueResolver);</span><br><span class="line"></span><br><span class="line">    String resolveEmbeddedValue(String value);&#x2F;&#x2F;分解指定的嵌入式的值</span><br><span class="line"></span><br><span class="line">    void addBeanPostProcessor(BeanPostProcessor beanPostProcessor);&#x2F;&#x2F;设置一个Bean后处理器</span><br><span class="line"></span><br><span class="line">    int getBeanPostProcessorCount();&#x2F;&#x2F;返回Bean后处理器的数量</span><br><span class="line"></span><br><span class="line">    void registerScope(String scopeName, Scope scope);&#x2F;&#x2F;注册范围</span><br><span class="line">    String[] getRegisteredScopeNames();&#x2F;&#x2F;返回注册的范围名</span><br><span class="line">    Scope getRegisteredScope(String scopeName);&#x2F;&#x2F;返回指定的范围</span><br><span class="line">    AccessControlContext getAccessControlContext();&#x2F;&#x2F;返回本工厂的一个安全访问上下文</span><br><span class="line"></span><br><span class="line">    void copyConfigurationFrom(ConfigurableBeanFactory otherFactory);&#x2F;&#x2F;从其他的工厂复制相关的所有配置</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 给指定的Bean注册别名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void registerAlias(String beanName, String alias) throws BeanDefinitionStoreException;</span><br><span class="line"></span><br><span class="line">    void resolveAliases(StringValueResolver valueResolver);&#x2F;&#x2F;根据指定的StringValueResolver移除所有的别名</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 返回指定Bean合并后的Bean定义</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BeanDefinition getMergedBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    boolean isFactoryBean(String name) throws NoSuchBeanDefinitionException;&#x2F;&#x2F;判断指定Bean是否为一个工厂Bean</span><br><span class="line"></span><br><span class="line">    void setCurrentlyInCreation(String beanName, boolean inCreation);&#x2F;&#x2F;设置一个Bean是否正在创建</span><br><span class="line"></span><br><span class="line">    boolean isCurrentlyInCreation(String beanName);&#x2F;&#x2F;返回指定Bean是否已经成功创建</span><br><span class="line"></span><br><span class="line">    void registerDependentBean(String beanName, String dependentBeanName);&#x2F;&#x2F;注册一个依赖于指定bean的Bean</span><br><span class="line">    String[] getDependentBeans(String beanName);&#x2F;&#x2F;返回依赖于指定Bean的所欲Bean名</span><br><span class="line">    String[] getDependenciesForBean(String beanName);&#x2F;&#x2F;返回指定Bean依赖的所有Bean名</span><br><span class="line"></span><br><span class="line">    void destroyBean(String beanName, Object beanInstance);&#x2F;&#x2F;销毁指定的Bean</span><br><span class="line"></span><br><span class="line">    void destroyScopedBean(String beanName);&#x2F;&#x2F;销毁指定的范围Bean</span><br><span class="line"></span><br><span class="line">    void destroySingletons();  &#x2F;&#x2F;销毁所有的单例类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在具体介绍之前，先看一下接口SingletonBeanRegistry的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface SingletonBeanRegistry &#123;</span><br><span class="line"></span><br><span class="line">    void registerSingleton(String beanName, Object singletonObject); &#x2F;&#x2F;在容器内注册一个单例类      </span><br><span class="line">    Object getSingleton(String beanName);&#x2F;&#x2F;返回给定名称对应的单例类</span><br><span class="line"></span><br><span class="line">    boolean containsSingleton(String beanName);&#x2F;&#x2F;给定名称是否对应单例类</span><br><span class="line">    String[] getSingletonNames();&#x2F;&#x2F;返回容器内所有单例类的名字</span><br><span class="line"></span><br><span class="line">    int getSingletonCount();&#x2F;&#x2F;返回容器内注册的单例类数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以看到，SingletonBeanRegistry这个接口非常简单，5个方法，实现了单例类注册的功能。<br>ConfigurableBeanFactory同时继承了HierarchicalBeanFactory 和 SingletonBeanRegistry 这两个接口，即同时继承了分层和单例类注册的功能。<br>具体：<br>　　1、2个静态不可变常量分别代表单例类和原型类。<br>　　2、1个设置父工厂的方法，跟HierarchicalBeanFactory接口的getParentBeanFactory方法互补。<br>　　3、4个跟类加载器有关的方法：get/set工厂类加载器和get/set临时类加载器。<br>　　4、2个设置、是否缓存元数据的方法（热加载开关）。<br>　　5、11个处理Bean注册、加载等细节的方法，包括：Bean表达式分解器、转换服务、属性编辑登记员、属性编辑器、属性编辑注册器、类型转换器、嵌入式的字符串分解器<br>　　6、2个处理Bean后处理器的方法。<br>　　7、3个跟注册范围相关的方法。<br>　　8、1个返回安全访问上下文的方法、1个从其他的工厂复制相关的所有配置的方法。<br>　　9、2个跟Bean别名相关的方法、1个返回合并后的Bean定义的方法。<br>　　10、1个判断是否为工厂Bean的方法、2个跟当前Bean创建时机相关的方法。<br>　　11、3个跟Bean依赖相关的方法、3个销毁Bean相关的方法。<br>总结：这个巨大的工厂接口，继承自HierarchicalBeanFactory 和 SingletonBeanRegistry 这两个接口，并额外独有37个方法！！！（看的我都快疯了…）这37个方法包含了工厂创建、注册一个Bean的众多细节。这个工厂名为ConfigurableBeanFactory，真是名不虚传！统计一下此时的ConfigurableBeanFactory的方法数吧。自有的37个方法、HierarchicalBeanFactory的2个方法、SingletonBeanRegistry的5个方法、爷爷接口BeanFactory的10个方法，共有54个方法！虽然方法繁多，还算井井有条！</p>
<h1 id="七、BeanFactory的集大成者——ConfigurableListableBeanFactory"><a href="#七、BeanFactory的集大成者——ConfigurableListableBeanFactory" class="headerlink" title="七、BeanFactory的集大成者——ConfigurableListableBeanFactory"></a>七、BeanFactory的集大成者——ConfigurableListableBeanFactory</h1><p>源码：　　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ConfigurableListableBeanFactory</span><br><span class="line">        extends ListableBeanFactory, AutowireCapableBeanFactory, ConfigurableBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    void ignoreDependencyType(Class&lt;?&gt; type);&#x2F;&#x2F;忽略自动装配的依赖类型</span><br><span class="line"></span><br><span class="line">    void ignoreDependencyInterface(Class&lt;?&gt; ifc);&#x2F;&#x2F;忽略自动装配的接口</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 注册一个可分解的依赖</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void registerResolvableDependency(Class&lt;?&gt; dependencyType, Object autowiredValue);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 判断指定的Bean是否有资格作为自动装配的候选者</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)</span><br><span class="line">            throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 返回注册的Bean定义</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    void freezeConfiguration();&#x2F;&#x2F;暂时冻结所有的Bean配置</span><br><span class="line"></span><br><span class="line">    boolean isConfigurationFrozen();&#x2F;&#x2F;判断本工厂配置是否被冻结</span><br><span class="line"></span><br><span class="line">    void preInstantiateSingletons() throws BeansException;&#x2F;&#x2F;使所有的非延迟加载的单例类都实例化。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 具体：<br>　　1、2个忽略自动装配的的方法。<br>　　2、1个注册一个可分解依赖的方法。<br>　　3、1个判断指定的Bean是否有资格作为自动装配的候选者的方法。<br>　　4、1个根据指定bean名，返回注册的Bean定义的方法。<br>　　5、2个冻结所有的Bean配置相关的方法。<br>　　6、1个使所有的非延迟加载的单例类都实例化的方法。<br>总结：工厂接口ConfigurableListableBeanFactory同时继承了3个接口，ListableBeanFactory、AutowireCapableBeanFactory 和 ConfigurableBeanFactory，扩展之后，加上自有的这8个方法，这个工厂接口总共有83个方法，实在是巨大到不行了。这个工厂接口的自有方法总体上只是对父类接口功能的补充，包含了BeanFactory体系目前的所有方法，可以说是接口的集大成者。</p>
<h1 id="八、额外的接口——BeanDefinitionRegistry"><a href="#八、额外的接口——BeanDefinitionRegistry" class="headerlink" title="八、额外的接口——BeanDefinitionRegistry"></a>八、额外的接口——BeanDefinitionRegistry</h1><p>这个接口基本用来操作定义在工厂内部的BeanDefinition的。我们先来看一下这个接口的父接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface AliasRegistry &#123;</span><br><span class="line"></span><br><span class="line">    void registerAlias(String name, String alias);&#x2F;&#x2F;对指定的名称注册别名</span><br><span class="line"></span><br><span class="line">    void removeAlias(String alias);&#x2F;&#x2F;从当前容器移除指定别名</span><br><span class="line"></span><br><span class="line">    boolean isAlias(String beanName);&#x2F;&#x2F;判断指定名称是否为别名</span><br><span class="line">    String[] getAliases(String name);&#x2F;&#x2F;返回指定名称的所有别名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以看到这4个方法都非常简单，都是用来操作别名的。<br>再来看一下BeanDefinitionRegistry的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface BeanDefinitionRegistry extends AliasRegistry &#123;</span><br><span class="line"></span><br><span class="line">    void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">            throws BeanDefinitionStoreException;&#x2F;&#x2F;给定bean名称，注册一个新的bean定义</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 根据指定Bean名移除对应的Bean定义</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 根据指定bean名得到对应的Bean定义</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 查找，指定的Bean名是否包含Bean定义</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean containsBeanDefinition(String beanName);</span><br><span class="line"></span><br><span class="line">    String[] getBeanDefinitionNames();&#x2F;&#x2F;返回本容器内所有注册的Bean定义名称</span><br><span class="line"></span><br><span class="line">    int getBeanDefinitionCount();&#x2F;&#x2F;返回本容器内注册的Bean定义数目</span><br><span class="line"></span><br><span class="line">    boolean isBeanNameInUse(String beanName);&#x2F;&#x2F;指定Bean名是否被注册过。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这7个方法都是用来操作容器内的BeanDefinition的。</p>
<h1 id="一、BeanFactory的基本类体系结构（类为主）："><a href="#一、BeanFactory的基本类体系结构（类为主）：" class="headerlink" title="一、BeanFactory的基本类体系结构（类为主）："></a>一、BeanFactory的基本类体系结构（类为主）：</h1><p><img src="https://img-blog.csdnimg.cn/20200331222848572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　　上图可与 Spring源码分析——BeanFactory体系之接口详细分析 的图结合分析，一个以接口为主，一个以类为主（PS：Spring的体系结构要分析清楚，不得不曲线救国啊！不然27寸屏幕给我画估计都装不下。）。</p>
<p>具体：</p>
<p>　　1、7层的类体系继承。</p>
<p>　　2、AbstractBeanFactory实现了最重要的ConfigurableBeanFactory接口，DefaultSingletonBeanRegistry实现了SingletonBeanRegistry单例类注册接口，SimpleAliasRegistry实现了AliasRegistry别名注册接口。</p>
<p>　　3、祖先类SimpleAliasRegistry、DefaultSingletonBeanRegistry和子孙类XmlBeanFactory、DefaultListableBeanFactory是完整的类，而中间的类FactoryBeanRegistrySupport、AbstractBeanFactory、AbstractAutowireCapableBeanFactory都是抽象类。</p>
<p>总结：</p>
<p>　　具体上来说，XmlBeanFactory光是父类就有6个了，加上自身，总共7层了。实际上分析接口结构就会看到，作为IOC类工厂而言，XmlBeanFactory的类体系结构实际是从祖先AbstractBeanFactory这个类开始的，因为是它实现了BeanFactory的子接口ConfigurableBeanFactory，虽然它继承自FactoryBeanRegistrySupport，但可以说这只是工厂功能的扩充，扩展了对工厂Bean以及工厂所产生的Bean的操作。</p>
<h1 id="二、简单的别名注册器——SimpleAliasRegistry"><a href="#二、简单的别名注册器——SimpleAliasRegistry" class="headerlink" title="二、简单的别名注册器——SimpleAliasRegistry"></a>二、简单的别名注册器——SimpleAliasRegistry</h1><p>　　上篇已经讲过AliasRegistry，非常简单的4个方法，体现了对别名注册的支持，而SimpleAliasRegistry就是它的简单实现。</p>
<p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SimpleAliasRegistry implements AliasRegistry &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     *用一个支持高并发的ConcurrentHashMap来放置所有的别名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final Map&lt;String, String&gt; aliasMap &#x3D; new ConcurrentHashMap&lt;String, String&gt;(</span><br><span class="line">            16);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; AliasRegistry的接口方法，注册别名。不允许重复注册。</span><br><span class="line">    public void registerAlias(String name, String alias) &#123;</span><br><span class="line">        Assert.hasText(name, &quot;&#39;name&#39; must not be empty&quot;);</span><br><span class="line">        Assert.hasText(alias, &quot;&#39;alias&#39; must not be empty&quot;);</span><br><span class="line">        if (alias.equals(name)) &#123;</span><br><span class="line">            this.aliasMap.remove(alias);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (!allowAliasOverriding()) &#123;</span><br><span class="line">                String registeredName &#x3D; this.aliasMap.get(alias);</span><br><span class="line">                if (registeredName !&#x3D; null &amp;&amp; !registeredName.equals(name)) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;Cannot register alias &#39;&quot;</span><br><span class="line">                            + alias + &quot;&#39; for name &#39;&quot; + name</span><br><span class="line">                            + &quot;&#39;: It is already registered for name &#39;&quot;</span><br><span class="line">                            + registeredName + &quot;&#39;.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            checkForAliasCircle(name, alias);&#x2F;&#x2F;alias不能等于name在map中最后的对应（详见checkForAliasCircle方法）</span><br><span class="line">            this.aliasMap.put(alias, name);&#x2F;&#x2F;alias是key,name是value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回是否允许Alias重写，默认为允许</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean allowAliasOverriding() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; AliasRegistry的接口方法，移除别名，如果别名未注册，则抛出异常</span><br><span class="line">    public void removeAlias(String alias) &#123;</span><br><span class="line">        String name &#x3D; this.aliasMap.remove(alias);</span><br><span class="line">        if (name &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;No alias &#39;&quot; + alias</span><br><span class="line">                    + &quot;&#39; registered&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; AliasRegistry的接口方法，给定名称判断是否为别名</span><br><span class="line">    public boolean isAlias(String name) &#123;</span><br><span class="line">        return this.aliasMap.containsKey(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; AliasRegistry的接口方法</span><br><span class="line">    public String[] getAliases(String name) &#123;</span><br><span class="line">        List&lt;String&gt; result &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        synchronized (this.aliasMap) &#123;</span><br><span class="line">            retrieveAliases(name, result);</span><br><span class="line">        &#125;</span><br><span class="line">        return StringUtils.toStringArray(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 找出名字说对应的所有别名。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void retrieveAliases(String name, List&lt;String&gt; result) &#123;</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : this.aliasMap.entrySet()) &#123;&#x2F;&#x2F;遍历aliasMap</span><br><span class="line">            String registeredName &#x3D; entry.getValue();&#x2F;&#x2F;取aliasMap的每个value</span><br><span class="line">            if (registeredName.equals(name)) &#123;&#x2F;&#x2F;如果value等于指定的这个name</span><br><span class="line">                String alias &#x3D; entry.getKey();&#x2F;&#x2F;取value对应的key</span><br><span class="line">                result.add(alias);&#x2F;&#x2F;将alias加入</span><br><span class="line">                retrieveAliases(alias, result);&#x2F;&#x2F;继续查看以alias为value的key</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 处理所有的别名，如果处理正确，把原来的用解析后的替换</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void resolveAliases(StringValueResolver valueResolver) &#123;</span><br><span class="line">        Assert.notNull(valueResolver, &quot;StringValueResolver must not be null&quot;);</span><br><span class="line">        synchronized (this.aliasMap) &#123;</span><br><span class="line">            Map&lt;String, String&gt; aliasCopy &#x3D; new HashMap&lt;String, String&gt;(</span><br><span class="line">                    this.aliasMap);</span><br><span class="line">            for (String alias : aliasCopy.keySet()) &#123;</span><br><span class="line">                String registeredName &#x3D; aliasCopy.get(alias);&#x2F;&#x2F;取出key对应的value</span><br><span class="line">                String resolvedAlias &#x3D; valueResolver.resolveStringValue(alias);&#x2F;&#x2F;解析后的key</span><br><span class="line">                String resolvedName &#x3D; valueResolver</span><br><span class="line">                        .resolveStringValue(registeredName);&#x2F;&#x2F;解析后的value</span><br><span class="line">                if (resolvedAlias.equals(resolvedName)) &#123;&#x2F;&#x2F;若解析后的key、name相等，就把它们从aliasMap中移除</span><br><span class="line">                    this.aliasMap.remove(alias);</span><br><span class="line">                &#125; else if (!resolvedAlias.equals(alias)) &#123;&#x2F;&#x2F;若解析后的key不等于原来的Key</span><br><span class="line">                    String existingName &#x3D; this.aliasMap.get(resolvedAlias);&#x2F;&#x2F;取出解析后的key对应的value</span><br><span class="line">                    if (existingName !&#x3D; null&#x2F;&#x2F;如果不为空且不等于解析后的value，就抛出异常</span><br><span class="line">                            &amp;&amp; !existingName.equals(resolvedName)) &#123;</span><br><span class="line">                        throw new IllegalStateException(</span><br><span class="line">                                &quot;Cannot register resolved alias &#39;&quot;</span><br><span class="line">                                        + resolvedAlias</span><br><span class="line">                                        + &quot;&#39; (original: &#39;&quot;</span><br><span class="line">                                        + alias</span><br><span class="line">                                        + &quot;&#39;) for name &#39;&quot;</span><br><span class="line">                                        + resolvedName</span><br><span class="line">                                        + &quot;&#39;: It is already registered for name &#39;&quot;</span><br><span class="line">                                        + registeredName + &quot;&#39;.&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    checkForAliasCircle(resolvedName, resolvedAlias);</span><br><span class="line">                    this.aliasMap.remove(alias);</span><br><span class="line">                    this.aliasMap.put(resolvedAlias, resolvedName);</span><br><span class="line">                &#125; else if (!registeredName.equals(resolvedName)) &#123;</span><br><span class="line">                    this.aliasMap.put(alias, resolvedName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 根据name这个Key，在aliasMap中不断循环的取对应的value，如果取得到，就继续根据这个value取值，不断循环继续。</span><br><span class="line">     * 直到取不到，就把这个在aliasMap中无对应值的key返回。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String canonicalName(String name) &#123;</span><br><span class="line">        String canonicalName &#x3D; name;    &#x2F;&#x2F;规范名</span><br><span class="line">        &#x2F;&#x2F; Handle aliasing...</span><br><span class="line">        String resolvedName;&#x2F;&#x2F;已解析名</span><br><span class="line">        do &#123;</span><br><span class="line">            resolvedName &#x3D; this.aliasMap.get(canonicalName);&#x2F;&#x2F;aliasMap中规范名对应的值赋值给已解析名</span><br><span class="line">            if (resolvedName !&#x3D; null) &#123;&#x2F;&#x2F;如果已解析名存在（即规范名在aliasMap中有对应的值）</span><br><span class="line">                canonicalName &#x3D; resolvedName;   &#x2F;&#x2F; 这个已解析名赋值给标准名</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (resolvedName !&#x3D; null);&#x2F;&#x2F;不断循环，直到已解析名不存在</span><br><span class="line">        return canonicalName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 如果别名alias等于canonicalName(name)就抛出异常</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void checkForAliasCircle(String name, String alias) &#123;</span><br><span class="line">        if (alias.equals(canonicalName(name))) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Cannot register alias &#39;&quot; + alias</span><br><span class="line">                    + &quot;&#39; for name &#39;&quot; + name + &quot;&#39;: Circular reference - &#39;&quot;</span><br><span class="line">                    + name + &quot;&#39; is a direct or indirect alias for &#39;&quot; + alias</span><br><span class="line">                    + &quot;&#39; already&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 具体：</p>
<p>　　1、1个支持高并发的ConcurrentHashMap来放置所有的别名，其中key是别名，value是真名。</p>
<p>　　2、4个方法实现了SimpleAliasRegistry。</p>
<p>　　3、3个用来辅助实现4个接口方法的方法。其中canonicalName(String name)的实现非常优雅，用来循环来回判断，把aliasMap中无对应值的key返回。</p>
<p>　　4、2个添加额外功能的方法 retrieveAliases 和 resolveAliases ，前者是找出名字对应的所有别名，后者是用一个StringValueResolver处理解析所有的别名-名称。</p>
<p>总结：</p>
<p>　　这是一个非常简单的别名注册器，一个简单的接口实现。不过其中包含了非常优雅的方法实现，值得一看！</p>
<h1 id="三、默认单例注册类——DefaultSingletonBeanRegistry"><a href="#三、默认单例注册类——DefaultSingletonBeanRegistry" class="headerlink" title="三、默认单例注册类——DefaultSingletonBeanRegistry"></a>三、默认单例注册类——DefaultSingletonBeanRegistry</h1><p>源码：　　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry &#123;</span><br><span class="line"></span><br><span class="line">    protected static final Object NULL_OBJECT &#x3D; new Object();&#x2F;&#x2F;空object</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;** Logger available to subclasses *&#x2F;</span><br><span class="line">    protected final Log logger &#x3D; LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    &#x2F;** 单例缓存: bean name --&gt; bean instance *&#x2F;</span><br><span class="line">    private final Map&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;String, Object&gt;(64);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 单例工厂缓存: bean name --&gt; ObjectFactory *&#x2F;</span><br><span class="line">    private final Map&lt;String, ObjectFactory&gt; singletonFactories &#x3D; new HashMap&lt;String, ObjectFactory&gt;(16);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 早期单例对象缓存: bean name --&gt; bean instance *&#x2F;</span><br><span class="line">    private final Map&lt;String, Object&gt; earlySingletonObjects &#x3D; new HashMap&lt;String, Object&gt;(16);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 注册过的单例类（单例工厂） *&#x2F;</span><br><span class="line">    private final Set&lt;String&gt; registeredSingletons &#x3D; new LinkedHashSet&lt;String&gt;(64);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 即将创建的单例类 (using a ConcurrentHashMap as a Set) *&#x2F;</span><br><span class="line">    private final Map&lt;String, Boolean&gt; singletonsCurrentlyInCreation &#x3D; new ConcurrentHashMap&lt;String, Boolean&gt;(16);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 正在创建的单例类 (using a ConcurrentHashMap as a Set) *&#x2F;</span><br><span class="line">    private final Map&lt;String, Boolean&gt; inCreationCheckExclusions &#x3D; new ConcurrentHashMap&lt;String, Boolean&gt;(16);</span><br><span class="line"></span><br><span class="line">    &#x2F;** 被压制的异常集合 *&#x2F;</span><br><span class="line">    private Set&lt;Exception&gt; suppressedExceptions;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 单例类是否真正被销毁 *&#x2F;</span><br><span class="line">    private boolean singletonsCurrentlyInDestruction &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Disposable接口的实例: bean name --&gt; disposable instance *&#x2F;</span><br><span class="line">    private final Map&lt;String, Object&gt;   &#x3D; new LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;** bean名称和bean所有包含的Bean的名称的map: bean name --&gt; Set of bean names that the bean contains *&#x2F;</span><br><span class="line">    private final Map&lt;String, Set&lt;String&gt;&gt; containedBeanMap &#x3D; new ConcurrentHashMap&lt;String, Set&lt;String&gt;&gt;(16);</span><br><span class="line"></span><br><span class="line">    &#x2F;** bean名称和所有依赖于Bean的名称的map: bean name --&gt; Set of dependent bean names *&#x2F;</span><br><span class="line">    private final Map&lt;String, Set&lt;String&gt;&gt; dependentBeanMap &#x3D; new ConcurrentHashMap&lt;String, Set&lt;String&gt;&gt;(64);</span><br><span class="line"></span><br><span class="line">    &#x2F;** bean名称和bean所依赖的所有名称的map --&gt; Set of bean names for the bean&#39;s dependencies *&#x2F;</span><br><span class="line">    private final Map&lt;String, Set&lt;String&gt;&gt; dependenciesForBeanMap &#x3D; new ConcurrentHashMap&lt;String, Set&lt;String&gt;&gt;(64);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;SingletonBeanRegistry接口的实现类————注册单例Bean，不能重复注册</span><br><span class="line">    public void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException &#123;</span><br><span class="line">        Assert.notNull(beanName, &quot;&#39;beanName&#39; must not be null&quot;);</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            Object oldObject &#x3D; this.singletonObjects.get(beanName);</span><br><span class="line">            if (oldObject !&#x3D; null) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;Could not register object [&quot; + singletonObject +</span><br><span class="line">                        &quot;] under bean name &#39;&quot; + beanName + &quot;&#39;: there is already object [&quot; + oldObject + &quot;] bound&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            addSingleton(beanName, singletonObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;注册一个单例类，注册之后，从singletonFactories、earlySingletonObjects中删去</span><br><span class="line">    protected void addSingleton(String beanName, Object singletonObject) &#123;</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            this.singletonObjects.put(beanName, (singletonObject !&#x3D; null ? singletonObject : NULL_OBJECT));</span><br><span class="line">            this.singletonFactories.remove(beanName);</span><br><span class="line">            this.earlySingletonObjects.remove(beanName);&#x2F;&#x2F;</span><br><span class="line">            this.registeredSingletons.add(beanName);&#x2F;&#x2F;加入，注册过的单例类集合</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;注册一个单例工厂类，注册后从earlySingletonObjects移除</span><br><span class="line">    protected void addSingletonFactory(String beanName, ObjectFactory singletonFactory) &#123;</span><br><span class="line">        Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;);</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            if (!this.singletonObjects.containsKey(beanName)) &#123;    &#x2F;&#x2F;单例工厂类不能和单例类同名</span><br><span class="line">                this.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">                this.earlySingletonObjects.remove(beanName);</span><br><span class="line">                this.registeredSingletons.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;SingletonBeanRegistry接口的实现类</span><br><span class="line">    public Object getSingleton(String beanName) &#123;</span><br><span class="line">        return getSingleton(beanName, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据beanName返回单例类</span><br><span class="line">    protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">        Object singletonObject &#x3D; this.singletonObjects.get(beanName);</span><br><span class="line">        if (singletonObject &#x3D;&#x3D; null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;    &#x2F;&#x2F;    如果取不到，且该bean正在创建</span><br><span class="line">            synchronized (this.singletonObjects) &#123;</span><br><span class="line">                singletonObject &#x3D; this.earlySingletonObjects.get(beanName);</span><br><span class="line">                if (singletonObject &#x3D;&#x3D; null &amp;&amp; allowEarlyReference) &#123;    &#x2F;&#x2F;    如果从早期单例缓存中获取不到，且允许早期引用</span><br><span class="line">                    ObjectFactory singletonFactory &#x3D; this.singletonFactories.get(beanName);    &#x2F;&#x2F;    那么就从单例工厂缓存中获取单例工厂</span><br><span class="line">                    if (singletonFactory !&#x3D; null) &#123;    &#x2F;&#x2F;    如果还是获取不到，就创建一个单例工厂，并把它放进早期单例缓存中，并返回</span><br><span class="line">                        singletonObject &#x3D; singletonFactory.getObject();</span><br><span class="line">                        this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                        this.singletonFactories.remove(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (singletonObject !&#x3D; NULL_OBJECT ? singletonObject : null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取指定的单例Bean，如果取不到就调用指定的singletonFactory的getObject来返回</span><br><span class="line">    public Object getSingleton(String beanName, ObjectFactory singletonFactory) &#123;</span><br><span class="line">        Assert.notNull(beanName, &quot;&#39;beanName&#39; must not be null&quot;);</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            Object singletonObject &#x3D; this.singletonObjects.get(beanName);&#x2F;&#x2F;从单例缓存中获取</span><br><span class="line">            if (singletonObject &#x3D;&#x3D; null) &#123;</span><br><span class="line">                if (this.singletonsCurrentlyInDestruction) &#123;&#x2F;&#x2F;如果单例类正在被销毁，就抛出异常</span><br><span class="line">                    throw new BeanCreationNotAllowedException(beanName,</span><br><span class="line">                            &quot;Singleton bean creation not allowed while the singletons of this factory are in destruction &quot; +</span><br><span class="line">                            &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Creating shared instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;如果不在inCreationCheckExclusions中，且可以向singletonsCurrentlyInCreation中添加，就抛出异常</span><br><span class="line">                beforeSingletonCreation(beanName);</span><br><span class="line">                &#x2F;&#x2F;是否有记录被压制的异常</span><br><span class="line">                boolean recordSuppressedExceptions &#x3D; (this.suppressedExceptions &#x3D;&#x3D; null);</span><br><span class="line">                if (recordSuppressedExceptions) &#123;&#x2F;&#x2F;如果没有记录，即没有被压制的异常，就创建被压制的异常容器</span><br><span class="line">                    this.suppressedExceptions &#x3D; new LinkedHashSet&lt;Exception&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    singletonObject &#x3D; singletonFactory.getObject();&#x2F;&#x2F;以上都没有异常产生，那么就从指定的facgtory中取</span><br><span class="line">                &#125;</span><br><span class="line">                catch (BeanCreationException ex) &#123;</span><br><span class="line">                    if (recordSuppressedExceptions) &#123;</span><br><span class="line">                        for (Exception suppressedException : this.suppressedExceptions) &#123;</span><br><span class="line">                            ex.addRelatedCause(suppressedException);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    throw ex;</span><br><span class="line">                &#125;</span><br><span class="line">                finally &#123;</span><br><span class="line">                    if (recordSuppressedExceptions) &#123;</span><br><span class="line">                        this.suppressedExceptions &#x3D; null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    afterSingletonCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                addSingleton(beanName, singletonObject);&#x2F;&#x2F;取成功就放进singletonObjects中</span><br><span class="line">            &#125;</span><br><span class="line">            return (singletonObject !&#x3D; NULL_OBJECT ? singletonObject : null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加一个被压制的异常</span><br><span class="line">    protected void onSuppressedException(Exception ex) &#123;</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            if (this.suppressedExceptions !&#x3D; null) &#123;</span><br><span class="line">                this.suppressedExceptions.add(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据名称移除本容器中缓存的对应的单例Bean，把对应的单例从Bean集合、单例工厂集合、早期单例对象集合、注册过的单例集合都统统移除</span><br><span class="line">    protected void removeSingleton(String beanName) &#123;</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            this.singletonObjects.remove(beanName);</span><br><span class="line">            this.singletonFactories.remove(beanName);</span><br><span class="line">            this.earlySingletonObjects.remove(beanName);</span><br><span class="line">            this.registeredSingletons.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;SingletonBeanRegistry接口的实现类</span><br><span class="line">    public boolean containsSingleton(String beanName) &#123;</span><br><span class="line">        return (this.singletonObjects.containsKey(beanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;SingletonBeanRegistry接口的实现类</span><br><span class="line">    public String[] getSingletonNames() &#123;</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            return StringUtils.toStringArray(this.registeredSingletons);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;SingletonBeanRegistry接口的实现类</span><br><span class="line">    public int getSingletonCount() &#123;</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            return this.registeredSingletons.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置某个Bean是否正在创建</span><br><span class="line">    public void setCurrentlyInCreation(String beanName, boolean inCreation) &#123;</span><br><span class="line">        Assert.notNull(beanName, &quot;Bean name must not be null&quot;);</span><br><span class="line">        if (!inCreation) &#123;</span><br><span class="line">            this.inCreationCheckExclusions.put(beanName, Boolean.TRUE);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            this.inCreationCheckExclusions.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断某个Bean是否正在被创建</span><br><span class="line">    public boolean isCurrentlyInCreation(String beanName) &#123;</span><br><span class="line">        Assert.notNull(beanName, &quot;Bean name must not be null&quot;);</span><br><span class="line">        return (!this.inCreationCheckExclusions.containsKey(beanName) &amp;&amp; isActuallyInCreation(beanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected boolean isActuallyInCreation(String beanName) &#123;</span><br><span class="line">        return isSingletonCurrentlyInCreation(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;是否即将被创建</span><br><span class="line">    public boolean isSingletonCurrentlyInCreation(String beanName) &#123;</span><br><span class="line">        return this.singletonsCurrentlyInCreation.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;单例类创建开始之前调用</span><br><span class="line">    &#x2F;&#x2F;如果不在正在创建的单例类集合中，且可以向即将创建的单例类中添加，就抛出异常</span><br><span class="line">    protected void beforeSingletonCreation(String beanName) &#123;</span><br><span class="line">        if (!this.inCreationCheckExclusions.containsKey(beanName) &amp;&amp;</span><br><span class="line">                this.singletonsCurrentlyInCreation.put(beanName, Boolean.TRUE) !&#x3D; null) &#123;</span><br><span class="line">            throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;单例类创建之后调用</span><br><span class="line">    &#x2F;&#x2F;如果不在正在创建的单例类中，也不在即将创建的单例类中移除失败，就抛出异常</span><br><span class="line">    protected void afterSingletonCreation(String beanName) &#123;</span><br><span class="line">        if (!this.inCreationCheckExclusions.containsKey(beanName) &amp;&amp;</span><br><span class="line">                !this.singletonsCurrentlyInCreation.remove(beanName)) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Singleton &#39;&quot; + beanName + &quot;&#39; isn&#39;t currently in creation&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;往Disposable实例集合注册Disposable实例</span><br><span class="line">    public void registerDisposableBean(String beanName, DisposableBean bean) &#123;</span><br><span class="line">        synchronized (this.disposableBeans) &#123;</span><br><span class="line">            this.disposableBeans.put(beanName, bean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;注册一个被包含的Bean和一个包含它的Bean（子-&gt;父）</span><br><span class="line">    public void registerContainedBean(String containedBeanName, String containingBeanName) &#123;</span><br><span class="line">        synchronized (this.containedBeanMap) &#123;</span><br><span class="line">            Set&lt;String&gt; containedBeans &#x3D; this.containedBeanMap.get(containingBeanName);</span><br><span class="line">            if (containedBeans &#x3D;&#x3D; null) &#123;</span><br><span class="line">                containedBeans &#x3D; new LinkedHashSet&lt;String&gt;(8);&#x2F;&#x2F;containedBeans的初始容量为8</span><br><span class="line">                this.containedBeanMap.put(containingBeanName, containedBeans);&#x2F;&#x2F;注意！containedBeanMap的Key是父bean，value是其所包含的所有子Bean（父-&gt;子）</span><br><span class="line">            &#125;</span><br><span class="line">            containedBeans.add(containedBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        registerDependentBean(containedBeanName, containingBeanName);&#x2F;&#x2F;因为包含也是依赖的一种，所以此时也要注册在dependentBeanMap中</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;给指定的Bean注册一个其依赖的Bean</span><br><span class="line">    public void registerDependentBean(String beanName, String dependentBeanName) &#123;</span><br><span class="line">        String canonicalName &#x3D; canonicalName(beanName);&#x2F;&#x2F;在aliasMap中取规范名</span><br><span class="line">        synchronized (this.dependentBeanMap) &#123;    &#x2F;&#x2F;    这里是注册依赖BeanMap，key是bean的名称，value是依赖这个bean的所有bean的名称</span><br><span class="line">            Set&lt;String&gt; dependentBeans &#x3D; this.dependentBeanMap.get(canonicalName);</span><br><span class="line">            if (dependentBeans &#x3D;&#x3D; null) &#123;</span><br><span class="line">                dependentBeans &#x3D; new LinkedHashSet&lt;String&gt;(8);&#x2F;&#x2F;dependentBeans的初始容量也为8</span><br><span class="line">                this.dependentBeanMap.put(canonicalName, dependentBeans);&#x2F;&#x2F;dependentBeanMap中Key为beanName的规范名，value是依赖它的所有Bean的名称</span><br><span class="line">            &#125;</span><br><span class="line">            dependentBeans.add(dependentBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (this.dependenciesForBeanMap) &#123;    &#x2F;&#x2F;    这里相反，注册的是某个Bean和其所依赖的Bean的集合，key是这个beanName，value是这个Bean的依赖的所有Bean的Name</span><br><span class="line">            Set&lt;String&gt; dependenciesForBean &#x3D; this.dependenciesForBeanMap.get(dependentBeanName);</span><br><span class="line">            if (dependenciesForBean &#x3D;&#x3D; null) &#123;</span><br><span class="line">                dependenciesForBean &#x3D; new LinkedHashSet&lt;String&gt;(8);</span><br><span class="line">                this.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);</span><br><span class="line">            &#125;</span><br><span class="line">            dependenciesForBean.add(canonicalName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断某个Bean是否被其他Bean所依赖</span><br><span class="line">    protected boolean hasDependentBean(String beanName) &#123;</span><br><span class="line">        return this.dependentBeanMap.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回依赖于给定Bean的Bean名称的集合</span><br><span class="line">    public String[] getDependentBeans(String beanName) &#123;</span><br><span class="line">        Set&lt;String&gt; dependentBeans &#x3D; this.dependentBeanMap.get(beanName);</span><br><span class="line">        if (dependentBeans &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return new String[0];</span><br><span class="line">        &#125;</span><br><span class="line">        return StringUtils.toStringArray(dependentBeans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回某个Bean所依赖的所有Bean的名称</span><br><span class="line">    public String[] getDependenciesForBean(String beanName) &#123;</span><br><span class="line">        Set&lt;String&gt; dependenciesForBean &#x3D; this.dependenciesForBeanMap.get(beanName);</span><br><span class="line">        if (dependenciesForBean &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return new String[0];</span><br><span class="line">        &#125;</span><br><span class="line">        return dependenciesForBean.toArray(new String[dependenciesForBean.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;这个方法居然连注释都没有？太奇怪了！</span><br><span class="line">    public void destroySingletons() &#123;</span><br><span class="line">        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(&quot;Destroying singletons in &quot; + this);</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (this.singletonObjects) &#123;&#x2F;&#x2F;首先标记，所有的单例Bean正在被销毁，那么getSingleton就无法获得单例Bean了</span><br><span class="line">            this.singletonsCurrentlyInDestruction &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] disposableBeanNames;</span><br><span class="line">        synchronized (this.disposableBeans) &#123;&#x2F;&#x2F;然后把所有的disposableBean都放进数组，一个个按名称销毁</span><br><span class="line">            disposableBeanNames &#x3D; StringUtils.toStringArray(this.disposableBeans.keySet());</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; disposableBeanNames.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            destroySingleton(disposableBeanNames[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;    把本容器的所有的包含关系、依赖关系、被依赖关系的集合全部清空</span><br><span class="line">        this.containedBeanMap.clear();</span><br><span class="line">        this.dependentBeanMap.clear();</span><br><span class="line">        this.dependenciesForBeanMap.clear();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;然后把本容器的所有其他集合全部清空</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            this.singletonObjects.clear();</span><br><span class="line">            this.singletonFactories.clear();</span><br><span class="line">            this.earlySingletonObjects.clear();</span><br><span class="line">            this.registeredSingletons.clear();</span><br><span class="line">            this.singletonsCurrentlyInDestruction &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;销毁某个单例Bean</span><br><span class="line">    public void destroySingleton(String beanName) &#123;</span><br><span class="line">        &#x2F;&#x2F; Remove a registered singleton of the given name, if any.</span><br><span class="line">        removeSingleton(beanName);&#x2F;&#x2F;先把它销毁</span><br><span class="line"></span><br><span class="line">        DisposableBean disposableBean;&#x2F;&#x2F;它相应的DisposableBean实例</span><br><span class="line">        synchronized (this.disposableBeans) &#123;</span><br><span class="line">            disposableBean &#x3D; (DisposableBean) this.disposableBeans.remove(beanName);&#x2F;&#x2F;从disposableBeans移除这个实例</span><br><span class="line">        &#125;</span><br><span class="line">        destroyBean(beanName, disposableBean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 销毁指定名称的Bean，且销毁依赖于它的所有Bean</span><br><span class="line">    protected void destroyBean(String beanName, DisposableBean bean) &#123;</span><br><span class="line">        &#x2F;&#x2F; 首先销毁依赖它的所有Bean</span><br><span class="line">        Set&lt;String&gt; dependencies &#x3D; this.dependentBeanMap.remove(beanName);&#x2F;&#x2F;取依赖于指定Bean的所有Bean</span><br><span class="line">        if (dependencies !&#x3D; null) &#123;</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Retrieved dependent beans for bean &#39;&quot; + beanName + &quot;&#39;: &quot; + dependencies);</span><br><span class="line">            &#125;</span><br><span class="line">            for (String dependentBeanName : dependencies) &#123;</span><br><span class="line">                destroySingleton(dependentBeanName);&#x2F;&#x2F;一个个销毁</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 然后销毁它</span><br><span class="line">        if (bean !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                bean.destroy();</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">                logger.error(&quot;Destroy method on bean with name &#39;&quot; + beanName + &quot;&#39; threw an exception&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 然后销毁它所包含的Bean</span><br><span class="line">        Set&lt;String&gt; containedBeans &#x3D; this.containedBeanMap.remove(beanName);</span><br><span class="line">        if (containedBeans !&#x3D; null) &#123;</span><br><span class="line">            for (String containedBeanName : containedBeans) &#123;</span><br><span class="line">                destroySingleton(containedBeanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 然后把所有它依赖的Bean的依赖关系删除，首先删除dependentBeanMap中的依赖关系</span><br><span class="line">        synchronized (this.dependentBeanMap) &#123;</span><br><span class="line">            &#x2F;&#x2F;这样的for循环用法实在是经典</span><br><span class="line">            for (Iterator&lt;Map.Entry&lt;String, Set&lt;String&gt;&gt;&gt; it &#x3D; this.dependentBeanMap.entrySet().iterator(); it.hasNext();) &#123;</span><br><span class="line">                Map.Entry&lt;String, Set&lt;String&gt;&gt; entry &#x3D; it.next();</span><br><span class="line">                Set&lt;String&gt; dependenciesToClean &#x3D; entry.getValue();</span><br><span class="line">                dependenciesToClean.remove(beanName);</span><br><span class="line">                if (dependenciesToClean.isEmpty()) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 然后删除dependenciesForBeanMap中的依赖关系</span><br><span class="line">        this.dependenciesForBeanMap.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Expose the singleton mutex to subclasses.</span><br><span class="line">     * &lt;p&gt;Subclasses should synchronize on the given Object if they perform</span><br><span class="line">     * any sort of extended singleton creation phase. In particular, subclasses</span><br><span class="line">     * should &lt;i&gt;not&lt;&#x2F;i&gt; have their own mutexes involved in singleton creation,</span><br><span class="line">     * to avoid the potential for deadlocks in lazy-init situations.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;返回子类单例类的互斥体？这个暂且放着。</span><br><span class="line">    protected final Object getSingletonMutex() &#123;</span><br><span class="line">        return this.singletonObjects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体：</p>
<p>　　1、一个静态不可变的空对象NULL_OBJECT、一个简单的日志对象。</p>
<p>　　2、本类有如下集合：</p>
<p>　　　　（1）、一个单例缓存集合——singletonObjects</p>
<p>　　　　（2）、一个单例工厂缓存集合——singletonFactories</p>
<p>　　　　（3）、一个早期单例对象缓存集合——earlySingletonObjects</p>
<p>　　　　（4）、一个注册过的单例类（单例工厂）集合——registeredSingletons</p>
<p>　　　　（5）、一个即将创建的单例类集合——singletonsCurrentlyInCreation</p>
<p>　　　　（6）、一个正在创建的单例类集合——inCreationCheckExclusions</p>
<p>　　　　（7）、一个被压制的异常集合——suppressedExceptions（这种设计模式实在是经典！）</p>
<p>　　　　（8）、一个判断所有单例类是否马上被销毁的标记——singletonsCurrentlyInDestruction</p>
<p>　　　　（9）、一个Disposable接口（即可以自定义回收资源的接口）实例的集合——disposableBeans</p>
<p>　　　　（10）、一个bean名称和bean所有包含的Bean的名称的集合——containedBeanMap</p>
<p>　　　　（11）、bean名称和所有依赖于Bean的名称的集合——dependentBeanMap</p>
<p>　　　　（12）、bean名称和bean所依赖的所有名称的集合——dependenciesForBeanMap</p>
<p>　　3、2个注册单例方法，实际是暴露在外的SingletonBeanRegistry接口的实现方法registerSingleton加锁后调用另一个addSingleton方法。</p>
<p>　　4、1个注册单例工厂的方法。单例工厂类不能和单例类同名。</p>
<p>　　5、3个获取单例类的方法。一种是从单例类集合中获取，如果获取不到，boolean控制要么返回空对象，要么返回一个单例工厂。另一种是从单例集合中获取，如果取不到，就从指定的工厂中获取。还有一种？呵，就是暴露在外的SingletonBeanRegistry接口方法呗，直接调用第一种。</p>
<p>　　6、1个添加被压制的异常集合中添加异常的方法，我觉得这个设计非常经典。但需要记录异常，却不想处理的时候，可以采用这种设计模式。</p>
<p>　　7、1个移除单例的方法、1个判断是否包含单例的方法、1个返回所有单例名数组的方法、1个返回单例总数目的方法。</p>
<p>　　8、1个设置某个Bean是否正在创建的方法、1个判断某个Bean是否正在被创建的方法、2个判断某个Bean是否即将被创建的方法（一个调用另一个，用于重写）。</p>
<p>　　9、1个单例类创建开始之前调用的方法、1个单单例类创建之后调用的方法</p>
<p>　　10、1个往Disposable实例集合注册Disposable实例的方法，这个是Bean销毁前的准备。</p>
<p>　　11、1个注册一个被包含的Bean和一个包含的Bean的名称到containedBeanMap集合的方法。这个方法设置了Bean之间的包含关系。</p>
<p>　　12、1个给指定的Bean注册一个其依赖的Bean的方法。这个方法设置了Bean自己的依赖关系。</p>
<p>　　13、1个判断是否被依赖的方法、1个返回给定Bean名称的所有依赖的数组的方法、1个返回依赖于给定Bean的所有Bean名的数组的方法。</p>
<p>　　14、1个销毁所有单例类的方法（这个方法居然完全没有注释，有没搞错！）、1个销毁某个单例的方法、1个// 销毁指定名称的Bean，且销毁依赖于它的所有Bean的方法。</p>
<p>　　15、1个返回子类单例类的互斥体的方法。这个暂且待下一篇分析子类再看。</p>
<p>总结：</p>
<p>　　类如其名，默认的单例注册器。这个工厂的写法实在功能丰富，为了监控到一个单例类构建过程中的方方面面，简直就是不择手段啊，居然准备了12个集合，除了一个一个被压制的异常集合，其余全是跟单例类有直接关系的。可以说，这个单例注册器监听、实现了Spring单例注册的各个过程，具体的解读分析，在上面的源代码中可以看到，读者阅读我注释过的源代码应该会很轻松。</p>
<h1 id="一、工厂Bean注册支持——FactoryBeanRegistrySupport"><a href="#一、工厂Bean注册支持——FactoryBeanRegistrySupport" class="headerlink" title="一、工厂Bean注册支持——FactoryBeanRegistrySupport"></a>一、工厂Bean注册支持——FactoryBeanRegistrySupport</h1><p>废话不多说，直接看我注释的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Copyright 2002-2012 the original author or authors.</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"> * you may not use this file except in compliance with the License.</span><br><span class="line"> * You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *      http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">package org.springframework.beans.factory.support;</span><br><span class="line"></span><br><span class="line">import java.security.AccessControlContext;</span><br><span class="line">import java.security.AccessController;</span><br><span class="line">import java.security.PrivilegedAction;</span><br><span class="line">import java.security.PrivilegedActionException;</span><br><span class="line">import java.security.PrivilegedExceptionAction;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.factory.BeanCreationException;</span><br><span class="line">import org.springframework.beans.factory.BeanCurrentlyInCreationException;</span><br><span class="line">import org.springframework.beans.factory.FactoryBean;</span><br><span class="line">import org.springframework.beans.factory.FactoryBeanNotInitializedException;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Support base class for singleton registries which need to handle</span><br><span class="line"> * &#123;@link org.springframework.beans.factory.FactoryBean&#125; instances,</span><br><span class="line"> * integrated with &#123;@link DefaultSingletonBeanRegistry&#125;&#39;s singleton management.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Serves as base class for &#123;@link AbstractBeanFactory&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @author Juergen Hoeller</span><br><span class="line"> * @since 2.5.1</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract class FactoryBeanRegistrySupport extends DefaultSingletonBeanRegistry &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 工厂Bean生产的单例的集合: FactoryBean name --&gt; object *&#x2F;</span><br><span class="line">    private final Map&lt;String, Object&gt; factoryBeanObjectCache &#x3D; new ConcurrentHashMap&lt;String, Object&gt;(16);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回指定FactoryBean的类型</span><br><span class="line">    protected Class getTypeForFactoryBean(final FactoryBean factoryBean) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (System.getSecurityManager() !&#x3D; null) &#123;&#x2F;&#x2F;如果当前系统存在安全管理器</span><br><span class="line">                return AccessController.doPrivileged(new PrivilegedAction&lt;Class&gt;() &#123;&#x2F;&#x2F;那么返回factoryBean的类型这个操作不做权限检查，直接调用</span><br><span class="line">                    public Class run() &#123;</span><br><span class="line">                        return factoryBean.getObjectType();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;&#x2F;&#x2F;不存在安全管理器，就直接调用！</span><br><span class="line">                return factoryBean.getObjectType();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            logger.warn(&quot;FactoryBean threw exception from getObjectType, despite the contract saying &quot; +</span><br><span class="line">                    &quot;that it should return null if the type of its object cannot be determined yet&quot;, ex);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据FactoryBean名，返回其生产的Object，从缓存中取</span><br><span class="line">    protected Object getCachedObjectForFactoryBean(String beanName) &#123;</span><br><span class="line">        Object object &#x3D; this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">        return (object !&#x3D; NULL_OBJECT ? object : null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;从工厂Bean中取实例，实际调用下面的doGetObjectFromFactoryBean方法。</span><br><span class="line">    protected Object getObjectFromFactoryBean(FactoryBean factory, String beanName, boolean shouldPostProcess) &#123;</span><br><span class="line">        if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;&#x2F;&#x2F;若工厂是单例，且本容器包含beanName对应的单例类</span><br><span class="line">            synchronized (getSingletonMutex()) &#123;&#x2F;&#x2F;以所有的单例集合为锁</span><br><span class="line">                Object object &#x3D; this.factoryBeanObjectCache.get(beanName);&#x2F;&#x2F;根据beanName从factoryBeanObjectCache中取</span><br><span class="line">                if (object &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;若取不到</span><br><span class="line">                    object &#x3D; doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);</span><br><span class="line">                    this.factoryBeanObjectCache.put(beanName, (object !&#x3D; null ? object : NULL_OBJECT));&#x2F;&#x2F;放进factoryBeanObjectCache</span><br><span class="line">                &#125;</span><br><span class="line">                return (object !&#x3D; NULL_OBJECT ? object : null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;&#x2F;&#x2F;否则，直接</span><br><span class="line">            return doGetObjectFromFactoryBean(factory, beanName, shouldPostProcess);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;从工厂Bean中取实例</span><br><span class="line">    private Object doGetObjectFromFactoryBean(</span><br><span class="line">            final FactoryBean factory, final String beanName, final boolean shouldPostProcess)</span><br><span class="line">            throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">        Object object;</span><br><span class="line">        &#x2F;&#x2F;跟getTypeForFactoryBean的实现一样。</span><br><span class="line">        try &#123;</span><br><span class="line">            if (System.getSecurityManager() !&#x3D; null) &#123;&#x2F;&#x2F;若系统存在安全管理器</span><br><span class="line">                AccessControlContext acc &#x3D; getAccessControlContext();&#x2F;&#x2F;得到当前容器的安全访问上下文</span><br><span class="line">                try &#123;&#x2F;&#x2F;返回factoryBean的类型这个操作不做权限检查，直接调用</span><br><span class="line">                    object &#x3D; AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                        public Object run() throws Exception &#123;</span><br><span class="line">                                return factory.getObject();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, acc);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                    throw pae.getException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;&#x2F;&#x2F;否则直接取</span><br><span class="line">                object &#x3D; factory.getObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">            throw new BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            throw new BeanCreationException(beanName, &quot;FactoryBean threw exception on object creation&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果从beanFactory取不到，且这个实例即将被创建，抛出异常</span><br><span class="line">        if (object &#x3D;&#x3D; null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            throw new BeanCurrentlyInCreationException(</span><br><span class="line">                    beanName, &quot;FactoryBean which is currently in creation returned null from getObject&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;若取不到，且这个实例允许前处理</span><br><span class="line">        if (object !&#x3D; null &amp;&amp; shouldPostProcess) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                object &#x3D; postProcessObjectFromFactoryBean(object, beanName);&#x2F;&#x2F;这里简单返回，前处理的功能留给子类重写</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">                throw new BeanCreationException(beanName, &quot;Post-processing of the FactoryBean&#39;s object failed&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;这里简单返回Object，留给子类重写</span><br><span class="line">    protected Object postProcessObjectFromFactoryBean(Object object, String beanName) throws BeansException &#123;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果这个Object是FactoryBean类型，就转换成FactoryBean返回</span><br><span class="line">    protected FactoryBean getFactoryBean(String beanName, Object beanInstance) throws BeansException &#123;</span><br><span class="line">        if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">            throw new BeanCreationException(beanName,</span><br><span class="line">                    &quot;Bean instance of type [&quot; + beanInstance.getClass() + &quot;] is not a FactoryBean&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return (FactoryBean) beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;移除单例类这个方法重写，父类的移除之外，还要移除factoryBeanObjectCache中的。</span><br><span class="line">    @Override</span><br><span class="line">    protected void removeSingleton(String beanName) &#123;</span><br><span class="line">        super.removeSingleton(beanName);</span><br><span class="line">        this.factoryBeanObjectCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回当前容器的安全访问上下文</span><br><span class="line">    protected AccessControlContext getAccessControlContext() &#123;</span><br><span class="line">        return AccessController.getContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体：</p>
<p>　　1、1个不可变的实例属性ConcurrentHashMap来存放工厂Bean生产的单例的集合：FactoryBean name –&gt; object。</p>
<p>　　2、1个方法返回指定FactoryBean的类型的方法。</p>
<p>　　3、1个根据FactoryBean名，返回其生产的Object的方法。</p>
<p>　　4、2个从工厂Bean中取实例的方法。实际是一个方法调用另一个，取不到则返回空。</p>
<p>　　5、1个postProcessObjectFromFactoryBean的方法，留给子类重写。</p>
<p>　　6、1个取工厂Bean的方法——如果这个Object是FactoryBean类型，就转换成FactoryBean返回</p>
<p>　　7、1个重写父类的removeSingleton方法，移除单例的时候，父类的移除之外，还要移除factoryBeanObjectCache中的。</p>
<p>　　8、1个返回当前容器的安全访问上下文的方法。</p>
<p>总结：</p>
<p>　　这个类FactoryBeanRegistrySupport，类如其名，实现了对工厂Bean注册的支持。值得注意的是，这个类有较多类似如下的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (System.getSecurityManager() !&#x3D; null) &#123;&#x2F;&#x2F;如果当前系统存在安全管理器</span><br><span class="line">                return AccessController.doPrivileged(new PrivilegedAction&lt;Class&gt;() &#123;</span><br><span class="line">                    public Class run() &#123;</span><br><span class="line">                        &#x2F;&#x2F;实际处理</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;&#x2F;&#x2F;不存在安全管理器，就直接调用！</span><br><span class="line">                &#x2F;&#x2F;实际处理</span><br><span class="line">            &#125;     </span><br></pre></td></tr></table></figure>

<p>　　这个方法的意思是，如果当前系统存在安全管理器，那么接下来的操作不做权限检查，直接调用。而如果不存在，OK，那当然是直接调用了。这是JDK层面的一个系统安全管理工具，某些情况下，可以避免系统进行安全检查。这里稍作了解即可。在学习JVM的时候可仔细了解原理。</p>
<p>　　除此之外，这里可以了解一下这个类比较重要的方法doGetObjectFromFactoryBean，是从工厂Bean中取实例的方法，源码已经给出，这里重点指出一下：</p>
<p>//从工厂Bean中取实例，shouldPostProcess指的是是否允许提前处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Object doGetObjectFromFactoryBean(</span><br><span class="line">            final FactoryBean factory, final String beanName, final boolean shouldPostProcess)</span><br><span class="line">            throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">        Object object;</span><br><span class="line">        &#x2F;&#x2F;跟getTypeForFactoryBean的实现一样。</span><br><span class="line">        try &#123;</span><br><span class="line">            if (System.getSecurityManager() !&#x3D; null) &#123;&#x2F;&#x2F;若系统存在安全管理器</span><br><span class="line">                AccessControlContext acc &#x3D; getAccessControlContext();&#x2F;&#x2F;得到当前容器的安全访问上下文</span><br><span class="line">                try &#123;&#x2F;&#x2F;返回factoryBean的类型这个操作不做权限检查，直接调用</span><br><span class="line">                    object &#x3D; AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                        public Object run() throws Exception &#123;</span><br><span class="line">                                return factory.getObject();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, acc);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                    throw pae.getException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;&#x2F;&#x2F;否则直接取</span><br><span class="line">                object &#x3D; factory.getObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">            throw new BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            throw new BeanCreationException(beanName, &quot;FactoryBean threw exception on object creation&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果从beanFactory取不到，且这个实例即将被创建，抛出异常</span><br><span class="line">        if (object &#x3D;&#x3D; null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            throw new BeanCurrentlyInCreationException(</span><br><span class="line">                    beanName, &quot;FactoryBean which is currently in creation returned null from getObject&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;若取不到，并非即将创建、且这个实例允许前处理</span><br><span class="line">        if (object !&#x3D; null &amp;&amp; shouldPostProcess) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                object &#x3D; postProcessObjectFromFactoryBean(object, beanName);&#x2F;&#x2F;这里简单返回，前处理的功能留给子类重写</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">                throw new BeanCreationException(beanName, &quot;Post-processing of the FactoryBean&#39;s object failed&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>　　相信上面已经解释的很清楚了。</p>
<p>二、最重要的抽象类——AbstractBeanFactory</p>
<p>　　（PS：这个类的方法实在是多的骇人，看得我实在是头都大了。不多看到后面，发现很多方法其实也就是那么回事。源码注释了大部分，且看看咯！）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;父工厂的引用</span><br><span class="line">    private BeanFactory parentBeanFactory;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;类加载器</span><br><span class="line">    private ClassLoader beanClassLoader &#x3D; ClassUtils.getDefaultClassLoader();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;临时类加载器</span><br><span class="line">    private ClassLoader tempClassLoader;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Whether to cache bean metadata or rather reobtain it for every access *&#x2F;</span><br><span class="line">    private boolean cacheBeanMetadata &#x3D; true;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Bean表达式分解器，用来分解Bean定义中的表达式</span><br><span class="line">    private BeanExpressionResolver beanExpressionResolver;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;转换服务，用来替代属性编辑器的</span><br><span class="line">    private ConversionService conversionService;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;属性编辑登记员集合，容量为4的LinkedHashSet</span><br><span class="line">    private final Set&lt;PropertyEditorRegistrar&gt; propertyEditorRegistrars &#x3D;</span><br><span class="line">            new LinkedHashSet&lt;PropertyEditorRegistrar&gt;(4);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;通用的类型转换器，重写了默认的属相编辑器机制</span><br><span class="line">    private TypeConverter typeConverter;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;默认的属性编辑器集合</span><br><span class="line">    private final Map&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; customEditors &#x3D;</span><br><span class="line">            new HashMap&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt;(4);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;嵌入值转换器集合</span><br><span class="line">    private final List&lt;StringValueResolver&gt; embeddedValueResolvers &#x3D; new LinkedList&lt;StringValueResolver&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;BeanPostProcessor处理器集合</span><br><span class="line">    private final List&lt;BeanPostProcessor&gt; beanPostProcessors &#x3D; new ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;标记是否有InstantiationAwareBeanPostProcessors实例被注册</span><br><span class="line">    private boolean hasInstantiationAwareBeanPostProcessors;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;标记是否有DestructionAwareBeanPostProcessors实例被注册</span><br><span class="line">    private boolean hasDestructionAwareBeanPostProcessors;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;范围标识符和Scope实例的对应的Map</span><br><span class="line">    private final Map&lt;String, Scope&gt; scopes &#x3D; new HashMap&lt;String, Scope&gt;(8);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;安全上下文Provider，可以得到安全管理器的安全上下文</span><br><span class="line">    private SecurityContextProvider securityContextProvider;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;合并后的Bean根定义的集合</span><br><span class="line">    private final Map&lt;String, RootBeanDefinition&gt; mergedBeanDefinitions &#x3D;</span><br><span class="line">            new ConcurrentHashMap&lt;String, RootBeanDefinition&gt;(64);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;至少被创建过一次的Bean的集合</span><br><span class="line">    private final Map&lt;String, Boolean&gt; alreadyCreated &#x3D; new ConcurrentHashMap&lt;String, Boolean&gt;(64);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当前正在创建的原型，当前线程相关</span><br><span class="line">    private final ThreadLocal&lt;Object&gt; prototypesCurrentlyInCreation &#x3D;</span><br><span class="line">            new NamedThreadLocal&lt;Object&gt;(&quot;Prototype beans currently in creation&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;空构造方法</span><br><span class="line">    public AbstractBeanFactory() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;指定父Bean工厂的构造方法</span><br><span class="line">    public AbstractBeanFactory(BeanFactory parentBeanFactory) &#123;</span><br><span class="line">        this.parentBeanFactory &#x3D; parentBeanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line">    &#x2F;&#x2F; 3个getBean，BeanFactory接口的实现方法，实质是在调用doGetBean</span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    public Object getBean(String name) throws BeansException &#123;</span><br><span class="line">        return doGetBean(name, null, null, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException &#123;</span><br><span class="line">        return doGetBean(name, requiredType, null, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getBean(String name, Object... args) throws BeansException &#123;</span><br><span class="line">        return doGetBean(name, null, args, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;    提供创建时需要参数列表的getBean</span><br><span class="line">    public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType, Object... args) throws BeansException &#123;</span><br><span class="line">        return doGetBean(name, requiredType, args, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;从容器中获取bean的基本方法。</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    protected &lt;T&gt; T doGetBean(</span><br><span class="line">            final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</span><br><span class="line">            throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">        final String beanName &#x3D; transformedBeanName(name);&#x2F;&#x2F;在aliasMap中取得的标准名</span><br><span class="line">        Object bean;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Eagerly check singleton cache for manually registered singletons.</span><br><span class="line">        Object sharedInstance &#x3D; getSingleton(beanName);&#x2F;&#x2F;首先在单例集合中取</span><br><span class="line">        if (sharedInstance !&#x3D; null &amp;&amp; args &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;如果取得到，没有指定参数</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;&#x2F;&#x2F;若Log允许调试</span><br><span class="line">                if (isSingletonCurrentlyInCreation(beanName)) &#123;&#x2F;&#x2F;若正准备创建，输出日志</span><br><span class="line">                    logger.debug(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +</span><br><span class="line">                            &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;&#x2F;&#x2F;根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例</span><br><span class="line">            bean &#x3D; getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line">            if (isPrototypeCurrentlyInCreation(beanName)) &#123;&#x2F;&#x2F;如果正在被创建，就抛出异常</span><br><span class="line">                throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();&#x2F;&#x2F;取本容器的父容器</span><br><span class="line">            if (parentBeanFactory !&#x3D; null &amp;&amp; !containsBeanDefinition(beanName)) &#123;&#x2F;&#x2F;若存在父容器，且本容器不存在对应的Bean定义</span><br><span class="line">                String nameToLookup &#x3D; originalBeanName(name);&#x2F;&#x2F;取原始的Bean名</span><br><span class="line">                if (args !&#x3D; null) &#123;&#x2F;&#x2F;若参数列表存在</span><br><span class="line">                    &#x2F;&#x2F; 那么用父容器根据原始Bean名和参数列表返回</span><br><span class="line">                    return (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 参数列表不要求，那就直接根据原始名称和要求的类型返回</span><br><span class="line">                    return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果不需要类型检查，标记其已经被创建</span><br><span class="line">            if (!typeCheckOnly) &#123;</span><br><span class="line">                markBeanAsCreated(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;根据beanName取其根Bean定义</span><br><span class="line">            final RootBeanDefinition mbd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            String[] dependsOn &#x3D; mbd.getDependsOn();&#x2F;&#x2F;得到这个根定义的所有依赖</span><br><span class="line">            if (dependsOn !&#x3D; null) &#123;</span><br><span class="line">                for (String dependsOnBean : dependsOn) &#123;</span><br><span class="line">                    getBean(dependsOnBean);&#x2F;&#x2F;注册这个Bean</span><br><span class="line">                    &#x2F;&#x2F;注册一个Bean和依赖于它的Bean（后参数依赖前参数）</span><br><span class="line">                    registerDependentBean(dependsOnBean, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果Bean定义是单例，就在返回单例</span><br><span class="line">            if (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance &#x3D; getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                    public Object getObject() throws BeansException &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            return createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        catch (BeansException ex) &#123;</span><br><span class="line">                            destroySingleton(beanName);</span><br><span class="line">                            throw ex;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                &#x2F;&#x2F;根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例</span><br><span class="line">                bean &#x3D; getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果是原型</span><br><span class="line">            else if (mbd.isPrototype()) &#123;</span><br><span class="line">                &#x2F;&#x2F; It&#39;s a prototype -&gt; create a new instance.</span><br><span class="line">                Object prototypeInstance &#x3D; null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);&#x2F;&#x2F;原型创建前，与当前线程绑定</span><br><span class="line">                    prototypeInstance &#x3D; createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                finally &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);&#x2F;&#x2F;原型创建后，与当前线程解除绑定</span><br><span class="line">                &#125;</span><br><span class="line">                bean &#x3D; getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            else &#123;&#x2F;&#x2F;既不是单例又不是原型的情况</span><br><span class="line">                String scopeName &#x3D; mbd.getScope();</span><br><span class="line">                final Scope scope &#x3D; this.scopes.get(scopeName);&#x2F;&#x2F;得到范围</span><br><span class="line">                if (scope &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;No Scope registered for scope &#39;&quot; + scopeName + &quot;&#39;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;&#x2F;&#x2F;根据范围创建实例</span><br><span class="line">                    Object scopedInstance &#x3D; scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                        public Object getObject() throws BeansException &#123;</span><br><span class="line">                            beforePrototypeCreation(beanName);</span><br><span class="line">                            try &#123;</span><br><span class="line">                                return createBean(beanName, mbd, args);&#x2F;&#x2F;原型创建前，与当前线程绑定</span><br><span class="line">                            &#125;</span><br><span class="line">                            finally &#123;</span><br><span class="line">                                &#x2F;&#x2F;&#x2F;&#x2F;原型创建后，与当前线程解除绑定</span><br><span class="line">                                afterPrototypeCreation(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    &#x2F;&#x2F;根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例</span><br><span class="line">                    bean &#x3D; getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (IllegalStateException ex) &#123;</span><br><span class="line">                    throw new BeanCreationException(beanName,</span><br><span class="line">                            &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; &quot; +</span><br><span class="line">                            &quot;consider defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,</span><br><span class="line">                            ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断要求的类型是否和Bean实例的类型正在匹配</span><br><span class="line">        if (requiredType !&#x3D; null &amp;&amp; bean !&#x3D; null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return getTypeConverter().convertIfNecessary(bean, requiredType);&#x2F;&#x2F;转换类型，不抛出异常就说明类型匹配</span><br><span class="line">            &#125;</span><br><span class="line">            catch (TypeMismatchException ex) &#123;</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type [&quot; +</span><br><span class="line">                            ClassUtils.getQualifiedName(requiredType) + &quot;]&quot;, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (T) bean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;判断本容器是否包含指定bean</span><br><span class="line">    public boolean containsBean(String name) &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line">        &#x2F;&#x2F;    （如果是否包含单例 或 包含Bean定义）且 （为工厂Bean的产物 或 本身就是工厂bean），就返回true</span><br><span class="line">        if (containsSingleton(beanName) || containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            return (!BeanFactoryUtils.isFactoryDereference(name) || isFactoryBean(name));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果不包含单例且不包含Bean定义，就从父类去查找</span><br><span class="line">        BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();</span><br><span class="line">        return (parentBeanFactory !&#x3D; null &amp;&amp; parentBeanFactory.containsBean(originalBeanName(name)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断指定Bean是否为单例</span><br><span class="line">    public boolean isSingleton(String name) throws NoSuchBeanDefinitionException &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">        Object beanInstance &#x3D; getSingleton(beanName, false);&#x2F;&#x2F;首先从单例集合中取</span><br><span class="line">        if (beanInstance !&#x3D; null) &#123;&#x2F;&#x2F;取不到，就判断它是不是FactoryBean的实例</span><br><span class="line">            if (beanInstance instanceof FactoryBean) &#123;    &#x2F;&#x2F;    如果是，要求它是工厂Bean产生的实例或这个工厂bean是单例</span><br><span class="line">                return (BeanFactoryUtils.isFactoryDereference(name) || ((FactoryBean&lt;?&gt;) beanInstance).isSingleton());</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;&#x2F;&#x2F;    如果不是，要求它不是工厂Bean产生的实例</span><br><span class="line">                return !BeanFactoryUtils.isFactoryDereference(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#x2F;&#x2F;若虽然取不到，但是单例集合中包含它的名字，说明它是单例</span><br><span class="line">        else if (containsSingleton(beanName)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F;从父工厂中去查询Bean定义</span><br><span class="line">            BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();</span><br><span class="line">            if (parentBeanFactory !&#x3D; null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                &#x2F;&#x2F;父工厂找不到Bean定义，那就在父工厂根据原始名去查是否为单例</span><br><span class="line">                return parentBeanFactory.isSingleton(originalBeanName(name));</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;返回一个合并后的根Bean定义</span><br><span class="line">            RootBeanDefinition mbd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; In case of FactoryBean, return singleton status of created object if not a dereference.</span><br><span class="line">            &#x2F;&#x2F;若该根定义是单例</span><br><span class="line">            if (mbd.isSingleton()) &#123;</span><br><span class="line">                if (isFactoryBean(beanName, mbd)) &#123;    &#x2F;&#x2F;若该根定义为工厂Bean</span><br><span class="line">                    if (BeanFactoryUtils.isFactoryDereference(name)) &#123;&#x2F;&#x2F;判断是否为工厂产生的实例</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;取对应的工厂，判断该工厂Bean是否为单例</span><br><span class="line">                    FactoryBean&lt;?&gt; factoryBean &#x3D; (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                    return factoryBean.isSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;    &#x2F;&#x2F;    是否不为工厂Bean产生的实例（此时，即，该根定义不为工厂Bean，且不为工厂Bean产生的实例的时候，由于根定义是单例，那么它就是单例）</span><br><span class="line">                    return !BeanFactoryUtils.isFactoryDereference(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断是否为原型</span><br><span class="line">    public boolean isPrototype(String name) throws NoSuchBeanDefinitionException &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">        BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();&#x2F;&#x2F;得到父工厂</span><br><span class="line">        &#x2F;&#x2F;若父工厂中的定义为原型，就为原型</span><br><span class="line">        if (parentBeanFactory !&#x3D; null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            return parentBeanFactory.isPrototype(originalBeanName(name));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;若合并后的根定义为原型，且不是工厂Bean产生的实例、或本身是工厂Bean，那么就为原型</span><br><span class="line">        RootBeanDefinition mbd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        if (mbd.isPrototype()) &#123;</span><br><span class="line">            return (!BeanFactoryUtils.isFactoryDereference(name) || isFactoryBean(beanName, mbd));</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (BeanFactoryUtils.isFactoryDereference(name)) &#123;&#x2F;&#x2F;若为工厂Bean产生的实例</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (isFactoryBean(beanName, mbd)) &#123;&#x2F;&#x2F;若为工厂Bean，取它产生的Bean，判断SmartFactoryBean</span><br><span class="line">                final FactoryBean&lt;?&gt; factoryBean &#x3D; (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                if (System.getSecurityManager() !&#x3D; null) &#123;</span><br><span class="line">                    return AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                        public Boolean run() &#123;</span><br><span class="line">                            return ((factoryBean instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factoryBean).isPrototype()) ||</span><br><span class="line">                                    !factoryBean.isSingleton());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, getAccessControlContext());</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    return ((factoryBean instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factoryBean).isPrototype()) ||</span><br><span class="line">                            !factoryBean.isSingleton());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断类型是否匹配</span><br><span class="line">    public boolean isTypeMatch(String name, Class&lt;?&gt; targetType) throws NoSuchBeanDefinitionException &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line">        Class&lt;?&gt; typeToMatch &#x3D; (targetType !&#x3D; null ? targetType : Object.class);</span><br><span class="line"></span><br><span class="line">        Object beanInstance &#x3D; getSingleton(beanName, false);&#x2F;&#x2F;取name对应的单例</span><br><span class="line">        if (beanInstance !&#x3D; null) &#123;</span><br><span class="line">            if (beanInstance instanceof FactoryBean) &#123;&#x2F;&#x2F;若为工厂Bean</span><br><span class="line">                &#x2F;&#x2F;若不是工厂Bean产生的实例</span><br><span class="line">                if (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">                    &#x2F;&#x2F;取工厂Bean的类型与targetType进行对比</span><br><span class="line">                    Class&lt;?&gt; type &#x3D; getTypeForFactoryBean((FactoryBean&lt;?&gt;) beanInstance);</span><br><span class="line">                    return (type !&#x3D; null &amp;&amp; ClassUtils.isAssignable(typeToMatch, type));</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    return ClassUtils.isAssignableValue(typeToMatch, beanInstance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;不是工厂Bean，那就直接判断</span><br><span class="line">            else &#123;</span><br><span class="line">                return !BeanFactoryUtils.isFactoryDereference(name) &amp;&amp;</span><br><span class="line">                        ClassUtils.isAssignableValue(typeToMatch, beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;单例表中，对应的Key没有值，也不包含Bean定义，说明没有注册，返回false</span><br><span class="line">        else if (containsSingleton(beanName) &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;以下是包含Bean定义的情况</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F;先查父类的Bean定义</span><br><span class="line">            BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();</span><br><span class="line">            if (parentBeanFactory !&#x3D; null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                &#x2F;&#x2F; No bean definition found in this factory -&gt; delegate to parent.</span><br><span class="line">                return parentBeanFactory.isTypeMatch(originalBeanName(name), targetType);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;直接查合并后的根定义</span><br><span class="line">            RootBeanDefinition mbd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;构建类型数组</span><br><span class="line">            Class[] typesToMatch &#x3D; (FactoryBean.class.equals(typeToMatch) ?</span><br><span class="line">                    new Class[] &#123;typeToMatch&#125; : new Class[] &#123;FactoryBean.class, typeToMatch&#125;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check decorated bean definition, if any: We assume it&#39;ll be easier</span><br><span class="line">            &#x2F;&#x2F; to determine the decorated bean&#39;s type than the proxy&#39;s type.</span><br><span class="line">            &#x2F;&#x2F;得到Bean定义的持有者</span><br><span class="line">            BeanDefinitionHolder dbd &#x3D; mbd.getDecoratedDefinition();</span><br><span class="line">            if (dbd !&#x3D; null &amp;&amp; !BeanFactoryUtils.isFactoryDereference(name)) &#123;&#x2F;&#x2F;若为Bean工厂生成的实例，先得到根定义</span><br><span class="line">                RootBeanDefinition tbd &#x3D; getMergedBeanDefinition(dbd.getBeanName(), dbd.getBeanDefinition(), mbd);</span><br><span class="line">                Class&lt;?&gt; targetClass &#x3D; predictBeanType(dbd.getBeanName(), tbd, typesToMatch);&#x2F;&#x2F;得到预测的根定义</span><br><span class="line">                if (targetClass !&#x3D; null &amp;&amp; !FactoryBean.class.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">                    return typeToMatch.isAssignableFrom(targetClass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; beanType &#x3D; predictBeanType(beanName, mbd, typesToMatch);&#x2F;&#x2F;预测后的类型</span><br><span class="line">            if (beanType &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (FactoryBean.class.isAssignableFrom(beanType)) &#123;&#x2F;&#x2F;BeanFactory是否为其子类</span><br><span class="line">                if (!BeanFactoryUtils.isFactoryDereference(name)) &#123;&#x2F;&#x2F;若不为工厂Bean的产物</span><br><span class="line">                    &#x2F;&#x2F; If it&#39;s a FactoryBean, we want to look at what it creates, not the factory class.</span><br><span class="line">                    beanType &#x3D; getTypeForFactoryBean(beanName, mbd);</span><br><span class="line">                    if (beanType &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (BeanFactoryUtils.isFactoryDereference(name)) &#123;&#x2F;&#x2F;若为工厂类Bean的产物</span><br><span class="line">                beanType &#x3D; predictBeanType(beanName, mbd, FactoryBean.class);&#x2F;&#x2F;预测类型</span><br><span class="line">                if (beanType &#x3D;&#x3D; null || !FactoryBean.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return typeToMatch.isAssignableFrom(beanType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回类型</span><br><span class="line">    public Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Check manually registered singletons.</span><br><span class="line">        Object beanInstance &#x3D; getSingleton(beanName, false);</span><br><span class="line">        if (beanInstance !&#x3D; null) &#123;</span><br><span class="line">            if (beanInstance instanceof FactoryBean &amp;&amp; !BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">                return getTypeForFactoryBean((FactoryBean&lt;?&gt;) beanInstance);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return beanInstance.getClass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (containsSingleton(beanName) &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            &#x2F;&#x2F; null instance registered</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; No singleton instance found -&gt; check bean definition.</span><br><span class="line">            BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();</span><br><span class="line">            if (parentBeanFactory !&#x3D; null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                &#x2F;&#x2F; No bean definition found in this factory -&gt; delegate to parent.</span><br><span class="line">                return parentBeanFactory.getType(originalBeanName(name));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RootBeanDefinition mbd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check decorated bean definition, if any: We assume it&#39;ll be easier</span><br><span class="line">            &#x2F;&#x2F; to determine the decorated bean&#39;s type than the proxy&#39;s type.</span><br><span class="line">            BeanDefinitionHolder dbd &#x3D; mbd.getDecoratedDefinition();</span><br><span class="line">            if (dbd !&#x3D; null &amp;&amp; !BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">                RootBeanDefinition tbd &#x3D; getMergedBeanDefinition(dbd.getBeanName(), dbd.getBeanDefinition(), mbd);</span><br><span class="line">                Class&lt;?&gt; targetClass &#x3D; predictBeanType(dbd.getBeanName(), tbd);</span><br><span class="line">                if (targetClass !&#x3D; null &amp;&amp; !FactoryBean.class.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">                    return targetClass;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; beanClass &#x3D; predictBeanType(beanName, mbd);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check bean class whether we&#39;re dealing with a FactoryBean.</span><br><span class="line">            if (beanClass !&#x3D; null &amp;&amp; FactoryBean.class.isAssignableFrom(beanClass)) &#123;</span><br><span class="line">                if (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; If it&#39;s a FactoryBean, we want to look at what it creates, not at the factory class.</span><br><span class="line">                    return getTypeForFactoryBean(beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    return beanClass;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return (!BeanFactoryUtils.isFactoryDereference(name) ? beanClass : null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重写了，得到别名的方法。</span><br><span class="line">    @Override</span><br><span class="line">    public String[] getAliases(String name) &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line">        List&lt;String&gt; aliases &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        boolean factoryPrefix &#x3D; name.startsWith(FACTORY_BEAN_PREFIX);</span><br><span class="line">        String fullBeanName &#x3D; beanName;</span><br><span class="line">        if (factoryPrefix) &#123;</span><br><span class="line">            fullBeanName &#x3D; FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!fullBeanName.equals(name)) &#123;</span><br><span class="line">            aliases.add(fullBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] retrievedAliases &#x3D; super.getAliases(beanName);</span><br><span class="line">        for (String retrievedAlias : retrievedAliases) &#123;</span><br><span class="line">            String alias &#x3D; (factoryPrefix ? FACTORY_BEAN_PREFIX : &quot;&quot;) + retrievedAlias;</span><br><span class="line">            if (!alias.equals(name)) &#123;</span><br><span class="line">                aliases.add(alias);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!containsSingleton(beanName) &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();</span><br><span class="line">            if (parentBeanFactory !&#x3D; null) &#123;</span><br><span class="line">                aliases.addAll(Arrays.asList(parentBeanFactory.getAliases(fullBeanName)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return StringUtils.toStringArray(aliases);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line">    &#x2F;&#x2F; Implementation of HierarchicalBeanFactory interface</span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回本Bean工厂的父Bean工厂</span><br><span class="line">    public BeanFactory getParentBeanFactory() &#123;</span><br><span class="line">        return this.parentBeanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;是否在本容器中（就是说，并不是工厂bean生产出来的）</span><br><span class="line">    public boolean containsLocalBean(String name) &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);    &#x2F;&#x2F;    转换后的名字</span><br><span class="line">        &#x2F;&#x2F;（是否为单例或有对应的Bean定义） 且（不是工厂Bean生产出来的 或 本身就是工厂bean）</span><br><span class="line">        return ((containsSingleton(beanName) || containsBeanDefinition(beanName)) &amp;&amp;</span><br><span class="line">                (!BeanFactoryUtils.isFactoryDereference(name) || isFactoryBean(beanName)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line">    &#x2F;&#x2F; Implementation of ConfigurableBeanFactory interface</span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    public void setParentBeanFactory(BeanFactory parentBeanFactory) &#123;</span><br><span class="line">        if (this.parentBeanFactory !&#x3D; null &amp;&amp; this.parentBeanFactory !&#x3D; parentBeanFactory) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Already associated with parent BeanFactory: &quot; + this.parentBeanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        this.parentBeanFactory &#x3D; parentBeanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBeanClassLoader(ClassLoader beanClassLoader) &#123;</span><br><span class="line">        this.beanClassLoader &#x3D; (beanClassLoader !&#x3D; null ? beanClassLoader : ClassUtils.getDefaultClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ClassLoader getBeanClassLoader() &#123;</span><br><span class="line">        return this.beanClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTempClassLoader(ClassLoader tempClassLoader) &#123;</span><br><span class="line">        this.tempClassLoader &#x3D; tempClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ClassLoader getTempClassLoader() &#123;</span><br><span class="line">        return this.tempClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCacheBeanMetadata(boolean cacheBeanMetadata) &#123;</span><br><span class="line">        this.cacheBeanMetadata &#x3D; cacheBeanMetadata;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isCacheBeanMetadata() &#123;</span><br><span class="line">        return this.cacheBeanMetadata;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBeanExpressionResolver(BeanExpressionResolver resolver) &#123;</span><br><span class="line">        this.beanExpressionResolver &#x3D; resolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BeanExpressionResolver getBeanExpressionResolver() &#123;</span><br><span class="line">        return this.beanExpressionResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setConversionService(ConversionService conversionService) &#123;</span><br><span class="line">        this.conversionService &#x3D; conversionService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ConversionService getConversionService() &#123;</span><br><span class="line">        return this.conversionService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addPropertyEditorRegistrar(PropertyEditorRegistrar registrar) &#123;</span><br><span class="line">        Assert.notNull(registrar, &quot;PropertyEditorRegistrar must not be null&quot;);</span><br><span class="line">        this.propertyEditorRegistrars.add(registrar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the set of PropertyEditorRegistrars.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Set&lt;PropertyEditorRegistrar&gt; getPropertyEditorRegistrars() &#123;</span><br><span class="line">        return this.propertyEditorRegistrars;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void registerCustomEditor(Class&lt;?&gt; requiredType, Class&lt;? extends PropertyEditor&gt; propertyEditorClass) &#123;</span><br><span class="line">        Assert.notNull(requiredType, &quot;Required type must not be null&quot;);</span><br><span class="line">        Assert.isAssignable(PropertyEditor.class, propertyEditorClass);</span><br><span class="line">        this.customEditors.put(requiredType, propertyEditorClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void copyRegisteredEditorsTo(PropertyEditorRegistry registry) &#123;</span><br><span class="line">        registerCustomEditors(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the map of custom editors, with Classes as keys and PropertyEditor classes as values.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Map&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; getCustomEditors() &#123;</span><br><span class="line">        return this.customEditors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTypeConverter(TypeConverter typeConverter) &#123;</span><br><span class="line">        this.typeConverter &#x3D; typeConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;得到通用的类型转换器</span><br><span class="line">    protected TypeConverter getCustomTypeConverter() &#123;</span><br><span class="line">        return this.typeConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;得到类型转换器</span><br><span class="line">    public TypeConverter getTypeConverter() &#123;</span><br><span class="line">        TypeConverter customConverter &#x3D; getCustomTypeConverter();</span><br><span class="line">        if (customConverter !&#x3D; null) &#123;</span><br><span class="line">            return customConverter;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;&#x2F;&#x2F;若本容器未注册类型转换器，就创建一个简单的类型转换器</span><br><span class="line">            SimpleTypeConverter typeConverter &#x3D; new SimpleTypeConverter();</span><br><span class="line">            typeConverter.setConversionService(getConversionService());</span><br><span class="line">            registerCustomEditors(typeConverter);</span><br><span class="line">            return typeConverter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addEmbeddedValueResolver(StringValueResolver valueResolver) &#123;</span><br><span class="line">        Assert.notNull(valueResolver, &quot;StringValueResolver must not be null&quot;);</span><br><span class="line">        this.embeddedValueResolvers.add(valueResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String resolveEmbeddedValue(String value) &#123;</span><br><span class="line">        String result &#x3D; value;</span><br><span class="line">        for (StringValueResolver resolver : this.embeddedValueResolvers) &#123;</span><br><span class="line">            if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            result &#x3D; resolver.resolveStringValue(result);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) &#123;</span><br><span class="line">        Assert.notNull(beanPostProcessor, &quot;BeanPostProcessor must not be null&quot;);</span><br><span class="line">        this.beanPostProcessors.remove(beanPostProcessor);</span><br><span class="line">        this.beanPostProcessors.add(beanPostProcessor);</span><br><span class="line">        if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            this.hasInstantiationAwareBeanPostProcessors &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) &#123;</span><br><span class="line">            this.hasDestructionAwareBeanPostProcessors &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getBeanPostProcessorCount() &#123;</span><br><span class="line">        return this.beanPostProcessors.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the list of BeanPostProcessors that will get applied</span><br><span class="line">     * to beans created with this factory.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public List&lt;BeanPostProcessor&gt; getBeanPostProcessors() &#123;</span><br><span class="line">        return this.beanPostProcessors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return whether this factory holds a InstantiationAwareBeanPostProcessor</span><br><span class="line">     * that will get applied to singleton beans on shutdown.</span><br><span class="line">     * @see #addBeanPostProcessor</span><br><span class="line">     * @see org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean hasInstantiationAwareBeanPostProcessors() &#123;</span><br><span class="line">        return this.hasInstantiationAwareBeanPostProcessors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return whether this factory holds a DestructionAwareBeanPostProcessor</span><br><span class="line">     * that will get applied to singleton beans on shutdown.</span><br><span class="line">     * @see #addBeanPostProcessor</span><br><span class="line">     * @see org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean hasDestructionAwareBeanPostProcessors() &#123;</span><br><span class="line">        return this.hasDestructionAwareBeanPostProcessors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void registerScope(String scopeName, Scope scope) &#123;</span><br><span class="line">        Assert.notNull(scopeName, &quot;Scope identifier must not be null&quot;);</span><br><span class="line">        Assert.notNull(scope, &quot;Scope must not be null&quot;);</span><br><span class="line">        if (SCOPE_SINGLETON.equals(scopeName) || SCOPE_PROTOTYPE.equals(scopeName)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Cannot replace existing scopes &#39;singleton&#39; and &#39;prototype&#39;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.scopes.put(scopeName, scope);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getRegisteredScopeNames() &#123;</span><br><span class="line">        return StringUtils.toStringArray(this.scopes.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Scope getRegisteredScope(String scopeName) &#123;</span><br><span class="line">        Assert.notNull(scopeName, &quot;Scope identifier must not be null&quot;);</span><br><span class="line">        return this.scopes.get(scopeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Set the security context provider for this bean factory. If a security manager</span><br><span class="line">     * is set, interaction with the user code will be executed using the privileged</span><br><span class="line">     * of the provided security context.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void setSecurityContextProvider(SecurityContextProvider securityProvider) &#123;</span><br><span class="line">        this.securityContextProvider &#x3D; securityProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Delegate the creation of the access control context to the</span><br><span class="line">     * &#123;@link #setSecurityContextProvider SecurityContextProvider&#125;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public AccessControlContext getAccessControlContext() &#123;</span><br><span class="line">        return (this.securityContextProvider !&#x3D; null ?</span><br><span class="line">                this.securityContextProvider.getAccessControlContext() :</span><br><span class="line">                AccessController.getContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void copyConfigurationFrom(ConfigurableBeanFactory otherFactory) &#123;</span><br><span class="line">        Assert.notNull(otherFactory, &quot;BeanFactory must not be null&quot;);</span><br><span class="line">        setBeanClassLoader(otherFactory.getBeanClassLoader());</span><br><span class="line">        setCacheBeanMetadata(otherFactory.isCacheBeanMetadata());</span><br><span class="line">        setBeanExpressionResolver(otherFactory.getBeanExpressionResolver());</span><br><span class="line">        if (otherFactory instanceof AbstractBeanFactory) &#123;</span><br><span class="line">            AbstractBeanFactory otherAbstractFactory &#x3D; (AbstractBeanFactory) otherFactory;</span><br><span class="line">            this.customEditors.putAll(otherAbstractFactory.customEditors);</span><br><span class="line">            this.propertyEditorRegistrars.addAll(otherAbstractFactory.propertyEditorRegistrars);</span><br><span class="line">            this.beanPostProcessors.addAll(otherAbstractFactory.beanPostProcessors);</span><br><span class="line">            this.hasInstantiationAwareBeanPostProcessors &#x3D; this.hasInstantiationAwareBeanPostProcessors ||</span><br><span class="line">                    otherAbstractFactory.hasInstantiationAwareBeanPostProcessors;</span><br><span class="line">            this.hasDestructionAwareBeanPostProcessors &#x3D; this.hasDestructionAwareBeanPostProcessors ||</span><br><span class="line">                    otherAbstractFactory.hasDestructionAwareBeanPostProcessors;</span><br><span class="line">            this.scopes.putAll(otherAbstractFactory.scopes);</span><br><span class="line">            this.securityContextProvider &#x3D; otherAbstractFactory.securityContextProvider;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            setTypeConverter(otherFactory.getTypeConverter());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回合并后的bean定义（父Bean定义和子Bean定义合并）</span><br><span class="line">    public BeanDefinition getMergedBeanDefinition(String name) throws BeansException &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Efficiently check whether bean definition exists in this factory.</span><br><span class="line">        &#x2F;&#x2F;若Bean定义不存在，且本容器父工厂为ConfigurableBeanFactory的实例，让父工厂来调用这个方法</span><br><span class="line">        if (!containsBeanDefinition(beanName) &amp;&amp; getParentBeanFactory() instanceof ConfigurableBeanFactory) &#123;</span><br><span class="line">            return ((ConfigurableBeanFactory) getParentBeanFactory()).getMergedBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;否则直接从本地合并后的Bean定义中取</span><br><span class="line">        return getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isFactoryBean(String name) throws NoSuchBeanDefinitionException &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">        Object beanInstance &#x3D; getSingleton(beanName, false);</span><br><span class="line">        if (beanInstance !&#x3D; null) &#123;</span><br><span class="line">            return (beanInstance instanceof FactoryBean);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (containsSingleton(beanName)) &#123;</span><br><span class="line">            &#x2F;&#x2F; null instance registered</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; No singleton instance found -&gt; check bean definition.</span><br><span class="line">        if (!containsBeanDefinition(beanName) &amp;&amp; getParentBeanFactory() instanceof ConfigurableBeanFactory) &#123;</span><br><span class="line">            &#x2F;&#x2F; No bean definition found in this factory -&gt; delegate to parent.</span><br><span class="line">            return ((ConfigurableBeanFactory) getParentBeanFactory()).isFactoryBean(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return isFactoryBean(beanName, getMergedLocalBeanDefinition(beanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isActuallyInCreation(String beanName) &#123;</span><br><span class="line">        return isSingletonCurrentlyInCreation(beanName) || isPrototypeCurrentlyInCreation(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;    判断指定的原型是否正在被创建</span><br><span class="line">    protected boolean isPrototypeCurrentlyInCreation(String beanName) &#123;</span><br><span class="line">        Object curVal &#x3D; this.prototypesCurrentlyInCreation.get();</span><br><span class="line">        return (curVal !&#x3D; null &amp;&amp;</span><br><span class="line">                (curVal.equals(beanName) || (curVal instanceof Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;原型创建前回调，需要子类重写</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    protected void beforePrototypeCreation(String beanName) &#123;</span><br><span class="line">        Object curVal &#x3D; this.prototypesCurrentlyInCreation.get();</span><br><span class="line">        if (curVal &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;原型创建状态与当前线程绑定</span><br><span class="line">            this.prototypesCurrentlyInCreation.set(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (curVal instanceof String) &#123;</span><br><span class="line">            Set&lt;String&gt; beanNameSet &#x3D; new HashSet&lt;String&gt;(2);</span><br><span class="line">            beanNameSet.add((String) curVal);</span><br><span class="line">            beanNameSet.add(beanName);</span><br><span class="line">            this.prototypesCurrentlyInCreation.set(beanNameSet);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;这里多余了。。。</span><br><span class="line">        else &#123;</span><br><span class="line">            Set&lt;String&gt; beanNameSet &#x3D; (Set&lt;String&gt;) curVal;</span><br><span class="line">            beanNameSet.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建原型后，从当前线程解除绑定</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    protected void afterPrototypeCreation(String beanName) &#123;</span><br><span class="line">        Object curVal &#x3D; this.prototypesCurrentlyInCreation.get();</span><br><span class="line">        if (curVal instanceof String) &#123;</span><br><span class="line">            this.prototypesCurrentlyInCreation.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (curVal instanceof Set) &#123;</span><br><span class="line">            Set&lt;String&gt; beanNameSet &#x3D; (Set&lt;String&gt;) curVal;</span><br><span class="line">            beanNameSet.remove(beanName);</span><br><span class="line">            if (beanNameSet.isEmpty()) &#123;</span><br><span class="line">                this.prototypesCurrentlyInCreation.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroyBean(String beanName, Object beanInstance) &#123;</span><br><span class="line">        destroyBean(beanName, beanInstance, getMergedLocalBeanDefinition(beanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Destroy the given bean instance (usually a prototype instance</span><br><span class="line">     * obtained from this factory) according to the given bean definition.</span><br><span class="line">     * @param beanName the name of the bean definition</span><br><span class="line">     * @param beanInstance the bean instance to destroy</span><br><span class="line">     * @param mbd the merged bean definition</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void destroyBean(String beanName, Object beanInstance, RootBeanDefinition mbd) &#123;</span><br><span class="line">        new DisposableBeanAdapter(beanInstance, beanName, mbd, getBeanPostProcessors(), getAccessControlContext()).destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroyScopedBean(String beanName) &#123;</span><br><span class="line">        RootBeanDefinition mbd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        if (mbd.isSingleton() || mbd.isPrototype()) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;Bean name &#39;&quot; + beanName + &quot;&#39; does not correspond to an object in a mutable scope&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        String scopeName &#x3D; mbd.getScope();</span><br><span class="line">        Scope scope &#x3D; this.scopes.get(scopeName);</span><br><span class="line">        if (scope &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;No Scope SPI registered for scope &#39;&quot; + scopeName + &quot;&#39;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Object bean &#x3D; scope.remove(beanName);</span><br><span class="line">        if (bean !&#x3D; null) &#123;</span><br><span class="line">            destroyBean(beanName, bean, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line">    &#x2F;&#x2F; Implementation methods</span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;变换后的Bean名称（先去掉BeanFactory前缀，然后在aliasMap中取标准名）</span><br><span class="line">    protected String transformedBeanName(String name) &#123;</span><br><span class="line">        return canonicalName(BeanFactoryUtils.transformedBeanName(name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回原始的Bean名</span><br><span class="line">    protected String originalBeanName(String name) &#123;</span><br><span class="line">        String beanName &#x3D; transformedBeanName(name);</span><br><span class="line">        if (name.startsWith(FACTORY_BEAN_PREFIX)) &#123;</span><br><span class="line">            beanName &#x3D; FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">        &#125;</span><br><span class="line">        return beanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Initialize the given BeanWrapper with the custom editors registered</span><br><span class="line">     * with this factory. To be called for BeanWrappers that will create</span><br><span class="line">     * and populate bean instances.</span><br><span class="line">     * &lt;p&gt;The default implementation delegates to &#123;@link #registerCustomEditors&#125;.</span><br><span class="line">     * Can be overridden in subclasses.</span><br><span class="line">     * @param bw the BeanWrapper to initialize</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void initBeanWrapper(BeanWrapper bw) &#123;</span><br><span class="line">        bw.setConversionService(getConversionService());</span><br><span class="line">        registerCustomEditors(bw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Initialize the given PropertyEditorRegistry with the custom editors</span><br><span class="line">     * that have been registered with this BeanFactory.</span><br><span class="line">     * &lt;p&gt;To be called for BeanWrappers that will create and populate bean</span><br><span class="line">     * instances, and for SimpleTypeConverter used for constructor argument</span><br><span class="line">     * and factory method type conversion.</span><br><span class="line">     * @param registry the PropertyEditorRegistry to initialize</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void registerCustomEditors(PropertyEditorRegistry registry) &#123;</span><br><span class="line">        PropertyEditorRegistrySupport registrySupport &#x3D;</span><br><span class="line">                (registry instanceof PropertyEditorRegistrySupport ? (PropertyEditorRegistrySupport) registry : null);</span><br><span class="line">        if (registrySupport !&#x3D; null) &#123;</span><br><span class="line">            registrySupport.useConfigValueEditors();</span><br><span class="line">        &#125;</span><br><span class="line">        if (!this.propertyEditorRegistrars.isEmpty()) &#123;</span><br><span class="line">            for (PropertyEditorRegistrar registrar : this.propertyEditorRegistrars) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    registrar.registerCustomEditors(registry);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (BeanCreationException ex) &#123;</span><br><span class="line">                    Throwable rootCause &#x3D; ex.getMostSpecificCause();</span><br><span class="line">                    if (rootCause instanceof BeanCurrentlyInCreationException) &#123;</span><br><span class="line">                        BeanCreationException bce &#x3D; (BeanCreationException) rootCause;</span><br><span class="line">                        if (isCurrentlyInCreation(bce.getBeanName())) &#123;</span><br><span class="line">                            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                                logger.debug(&quot;PropertyEditorRegistrar [&quot; + registrar.getClass().getName() +</span><br><span class="line">                                        &quot;] failed because it tried to obtain currently created bean &#39;&quot; +</span><br><span class="line">                                        ex.getBeanName() + &quot;&#39;: &quot; + ex.getMessage());</span><br><span class="line">                            &#125;</span><br><span class="line">                            onSuppressedException(ex);</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    throw ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!this.customEditors.isEmpty()) &#123;</span><br><span class="line">            for (Map.Entry&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; entry : this.customEditors.entrySet()) &#123;</span><br><span class="line">                Class&lt;?&gt; requiredType &#x3D; entry.getKey();</span><br><span class="line">                Class&lt;? extends PropertyEditor&gt; editorClass &#x3D; entry.getValue();</span><br><span class="line">                registry.registerCustomEditor(requiredType, BeanUtils.instantiateClass(editorClass));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回一个合并后的根Bean定义（父Bean定义和子Bean定义合并）（从当前容器取）</span><br><span class="line">    protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException &#123;</span><br><span class="line">        &#x2F;&#x2F; Quick check on the concurrent map first, with minimal locking.</span><br><span class="line">        RootBeanDefinition mbd &#x3D; this.mergedBeanDefinitions.get(beanName);&#x2F;&#x2F;首先直接从合并根定义集合中取</span><br><span class="line">        if (mbd !&#x3D; null) &#123;</span><br><span class="line">            return mbd;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;根据bean名和其对应的Bean定义，取其根Bean根定义</span><br><span class="line">        return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据Bean名和Bean定义取其Bean根定义</span><br><span class="line">    protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd)</span><br><span class="line">            throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">        return getMergedBeanDefinition(beanName, bd, null);&#x2F;&#x2F;调用重载方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据Bean名称返回根定义（若给定的Bean定义为子Bean定义，那么合并它的父Bean定义）</span><br><span class="line">    protected RootBeanDefinition getMergedBeanDefinition(</span><br><span class="line">            String beanName, BeanDefinition bd, BeanDefinition containingBd)</span><br><span class="line">            throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">        synchronized (this.mergedBeanDefinitions) &#123;</span><br><span class="line">            RootBeanDefinition mbd &#x3D; null;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;若给定的Bean定义并没有包含子Bean定义，那么直接根据Bean名取根定义</span><br><span class="line">            if (containingBd &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mbd &#x3D; this.mergedBeanDefinitions.get(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mbd &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;若取不到</span><br><span class="line">                if (bd.getParentName() &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;若Bean定义没有父类，就很简单了</span><br><span class="line">                    if (bd instanceof RootBeanDefinition) &#123;&#x2F;&#x2F;若Bean定义是RootBeanDefinition的实例，克隆、强转后返回</span><br><span class="line">                        mbd &#x3D; ((RootBeanDefinition) bd).cloneBeanDefinition();</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;&#x2F;&#x2F;否则，根据Bean定义，来构造一个根Bean定义</span><br><span class="line">                        mbd &#x3D; new RootBeanDefinition(bd);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;&#x2F;&#x2F;若Bean定义有父类</span><br><span class="line">                    &#x2F;&#x2F; Child bean definition: needs to be merged with parent.</span><br><span class="line">                    BeanDefinition pbd;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        String parentBeanName &#x3D; transformedBeanName(bd.getParentName());&#x2F;&#x2F;取其父Bean定义的名字</span><br><span class="line">                        if (!beanName.equals(parentBeanName)) &#123;&#x2F;&#x2F;若Bean名字并不是bd的父Bean的名字</span><br><span class="line">                            pbd &#x3D; getMergedBeanDefinition(parentBeanName);&#x2F;&#x2F;根据父Bean定义名称来返回合并后的bean定义</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;&#x2F;&#x2F;如果beanName对应的Bean就是bd的父Bean</span><br><span class="line">                            if (getParentBeanFactory() instanceof ConfigurableBeanFactory) &#123;&#x2F;&#x2F;若父Bean工厂为ConfigurableBeanFactory的实例</span><br><span class="line">                                &#x2F;&#x2F;    那么强转成ConfigurableBeanFactory后再调用合并方法</span><br><span class="line">                                pbd &#x3D; ((ConfigurableBeanFactory) getParentBeanFactory()).getMergedBeanDefinition(parentBeanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;&#x2F;&#x2F;若父Bean工厂不是ConfigurableBeanFactory的实例，就抛出异常</span><br><span class="line">                                throw new NoSuchBeanDefinitionException(bd.getParentName(),</span><br><span class="line">                                        &quot;Parent name &#39;&quot; + bd.getParentName() + &quot;&#39; is equal to bean name &#39;&quot; + beanName +</span><br><span class="line">                                        &quot;&#39;: cannot be resolved without an AbstractBeanFactory parent&quot;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                        throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName,</span><br><span class="line">                                &quot;Could not resolve parent bean definition &#39;&quot; + bd.getParentName() + &quot;&#39;&quot;, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 深度复制</span><br><span class="line">                    mbd &#x3D; new RootBeanDefinition(pbd);&#x2F;&#x2F;根据Bean定义生成一个根Bean定义</span><br><span class="line">                    mbd.overrideFrom(bd);&#x2F;&#x2F;将Bean定义的属性复制进自己的定义（根Bean定义）中</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!StringUtils.hasLength(mbd.getScope())) &#123;&#x2F;&#x2F;如果根Bean定义未设置范围</span><br><span class="line">                    mbd.setScope(RootBeanDefinition.SCOPE_SINGLETON);&#x2F;&#x2F;那么设置其范围为单例</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;    若本根Bean定义包含Bean定义、本根Bean定义为单例且包含的Bean定义并不是单例</span><br><span class="line">                if (containingBd !&#x3D; null &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;</span><br><span class="line">                    mbd.setScope(containingBd.getScope());&#x2F;&#x2F;    那么将本根Bean定义的范围设置为包含的Bean定义的范围</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;若本根Bean定义不包含Bean定义，且是缓存Bean元数据（重写前均为true）且Bean定义是否有资格缓存（默认实现是，这个Bean已经创建便有资格）</span><br><span class="line">                if (containingBd &#x3D;&#x3D; null &amp;&amp; isCacheBeanMetadata() &amp;&amp; isBeanEligibleForMetadataCaching(beanName)) &#123;</span><br><span class="line">                    this.mergedBeanDefinitions.put(beanName, mbd);&#x2F;&#x2F;放进mergedBeanDefinitions中</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return mbd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;检查Bean定义，抛出异常</span><br><span class="line">    protected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, Object[] args)</span><br><span class="line">            throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">        if (mbd.isAbstract()) &#123;</span><br><span class="line">            throw new BeanIsAbstractException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (args !&#x3D; null &amp;&amp; !mbd.isPrototype()) &#123;</span><br><span class="line">            throw new BeanDefinitionStoreException(</span><br><span class="line">                    &quot;Can only specify arguments for the getBean method when referring to a prototype bean definition&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Remove the merged bean definition for the specified bean,</span><br><span class="line">     * recreating it on next access.</span><br><span class="line">     * @param beanName the bean name to clear the merged definition for</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void clearMergedBeanDefinition(String beanName) &#123;</span><br><span class="line">        this.mergedBeanDefinitions.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;解析类型，处理异常</span><br><span class="line">    protected Class&lt;?&gt; resolveBeanClass(final RootBeanDefinition mbd, String beanName, final Class&lt;?&gt;... typesToMatch)</span><br><span class="line">            throws CannotLoadBeanClassException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (mbd.hasBeanClass()) &#123;</span><br><span class="line">                return mbd.getBeanClass();</span><br><span class="line">            &#125;</span><br><span class="line">            if (System.getSecurityManager() !&#x3D; null) &#123;</span><br><span class="line">                return AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                    public Class&lt;?&gt; run() throws Exception &#123;</span><br><span class="line">                        return doResolveBeanClass(mbd, typesToMatch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return doResolveBeanClass(mbd, typesToMatch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (PrivilegedActionException pae) &#123;</span><br><span class="line">            ClassNotFoundException ex &#x3D; (ClassNotFoundException) pae.getException();</span><br><span class="line">            throw new CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (ClassNotFoundException ex) &#123;</span><br><span class="line">            throw new CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (LinkageError err) &#123;</span><br><span class="line">            throw new CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 真正的解析类型</span><br><span class="line">    private Class&lt;?&gt; doResolveBeanClass(RootBeanDefinition mbd, Class&lt;?&gt;... typesToMatch) throws ClassNotFoundException &#123;</span><br><span class="line">        if (!ObjectUtils.isEmpty(typesToMatch)) &#123;</span><br><span class="line">            ClassLoader tempClassLoader &#x3D; getTempClassLoader();&#x2F;&#x2F;找到临时的类加载器</span><br><span class="line">            if (tempClassLoader !&#x3D; null) &#123;</span><br><span class="line">                if (tempClassLoader instanceof DecoratingClassLoader) &#123;&#x2F;&#x2F;若为装饰类加载器</span><br><span class="line">                    DecoratingClassLoader dcl &#x3D; (DecoratingClassLoader) tempClassLoader;</span><br><span class="line">                    for (Class&lt;?&gt; typeToMatch : typesToMatch) &#123;</span><br><span class="line">                        dcl.excludeClass(typeToMatch.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                String className &#x3D; mbd.getBeanClassName();</span><br><span class="line">                return (className !&#x3D; null ? ClassUtils.forName(className, tempClassLoader) : null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mbd.resolveBeanClass(getBeanClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Evaluate the given String as contained in a bean definition,</span><br><span class="line">     * potentially resolving it as an expression.</span><br><span class="line">     * @param value the value to check</span><br><span class="line">     * @param beanDefinition the bean definition that the value comes from</span><br><span class="line">     * @return the resolved value</span><br><span class="line">     * @see #setBeanExpressionResolver</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected Object evaluateBeanDefinitionString(String value, BeanDefinition beanDefinition) &#123;</span><br><span class="line">        if (this.beanExpressionResolver &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">        Scope scope &#x3D; (beanDefinition !&#x3D; null ? getRegisteredScope(beanDefinition.getScope()) : null);</span><br><span class="line">        return this.beanExpressionResolver.evaluate(value, new BeanExpressionContext(this, scope));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;预测类型</span><br><span class="line">    protected Class&lt;?&gt; predictBeanType(String beanName, RootBeanDefinition mbd, Class&lt;?&gt;... typesToMatch) &#123;</span><br><span class="line">        &#x2F;&#x2F;若根Bena定义的工厂方法名存在，说明它是工厂Bean创建的，无法预测类型？</span><br><span class="line">        if (mbd.getFactoryMethodName() !&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;否则，解析Bean的Class</span><br><span class="line">        return resolveBeanClass(mbd, beanName, typesToMatch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Check whether the given bean is defined as a &#123;@link FactoryBean&#125;.</span><br><span class="line">     * @param beanName the name of the bean</span><br><span class="line">     * @param mbd the corresponding bean definition</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean isFactoryBean(String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line">        Class&lt;?&gt; beanType &#x3D; predictBeanType(beanName, mbd, FactoryBean.class);</span><br><span class="line">        return (beanType !&#x3D; null &amp;&amp; FactoryBean.class.isAssignableFrom(beanType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回工厂Bean的类型</span><br><span class="line">    protected Class&lt;?&gt; getTypeForFactoryBean(String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line">        if (!mbd.isSingleton()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            FactoryBean&lt;?&gt; factoryBean &#x3D; doGetBean(FACTORY_BEAN_PREFIX + beanName, FactoryBean.class, null, true);</span><br><span class="line">            return getTypeForFactoryBean(factoryBean);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (BeanCreationException ex) &#123;</span><br><span class="line">            &#x2F;&#x2F; Can only happen when getting a FactoryBean.</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Ignoring bean creation exception on FactoryBean type check: &quot; + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            onSuppressedException(ex);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;标记这个Bean已经被创建</span><br><span class="line">    protected void markBeanAsCreated(String beanName) &#123;</span><br><span class="line">        this.alreadyCreated.put(beanName, Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Determine whether the specified bean is eligible for having</span><br><span class="line">     * its bean definition metadata cached.</span><br><span class="line">     * @param beanName the name of the bean</span><br><span class="line">     * @return &#123;@code true&#125; if the bean&#39;s metadata may be cached</span><br><span class="line">     * at this point already</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;若本根Bean定义包含Bean元定义作为缓存，这个方法应被之类覆盖，这里仅判断Bean是否已经被创建</span><br><span class="line">    protected boolean isBeanEligibleForMetadataCaching(String beanName) &#123;</span><br><span class="line">        return this.alreadyCreated.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Remove the singleton instance (if any) for the given bean name,</span><br><span class="line">     * but only if it hasn&#39;t been used for other purposes than type checking.</span><br><span class="line">     * @param beanName the name of the bean</span><br><span class="line">     * @return &#123;@code true&#125; if actually removed, &#123;@code false&#125; otherwise</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean removeSingletonIfCreatedForTypeCheckOnly(String beanName) &#123;</span><br><span class="line">        if (!this.alreadyCreated.containsKey(beanName)) &#123;</span><br><span class="line">            removeSingleton(beanName);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例</span><br><span class="line">    protected Object getObjectForBeanInstance(</span><br><span class="line">            Object beanInstance, String name, String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果这个Bean是工厂Bean创建的 且 这个Bean实例并不是FactoryBean实例，抛异常</span><br><span class="line">        if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">            throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果这个Bean实例并不是FactoryBean实例 或 这个Bean是工厂Bean创建的，直接返回</span><br><span class="line">        if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">            return beanInstance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;——————————以下都是 这个Bean实例是FactoryBean实例的情况</span><br><span class="line">        Object object &#x3D; null;</span><br><span class="line">        if (mbd &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;若根Bean定义为空，取这个BeanFactory所生产的实例</span><br><span class="line">            object &#x3D; getCachedObjectForFactoryBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        if (object &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;若取不到，那么手动取</span><br><span class="line">            FactoryBean&lt;?&gt; factory &#x3D; (FactoryBean&lt;?&gt;) beanInstance;&#x2F;&#x2F;把这个实例转化成一个FactoryBean</span><br><span class="line">            &#x2F;&#x2F; Caches object obtained from FactoryBean if it is a singleton.</span><br><span class="line">            if (mbd &#x3D;&#x3D; null &amp;&amp; containsBeanDefinition(beanName)) &#123;&#x2F;&#x2F;若根Bean定义为空，但是容器内有Bean定义</span><br><span class="line">                mbd &#x3D; getMergedLocalBeanDefinition(beanName);&#x2F;&#x2F;返回合并后的Bean定义</span><br><span class="line">            &#125;</span><br><span class="line">            boolean synthetic &#x3D; (mbd !&#x3D; null &amp;&amp; mbd.isSynthetic());&#x2F;&#x2F;标记这个Bean定义是合并的</span><br><span class="line">            object &#x3D; getObjectFromFactoryBean(factory, beanName, !synthetic);&#x2F;&#x2F;从工厂Bean中取</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断给定的Bean是否被使用过</span><br><span class="line">    public boolean isBeanNameInUse(String beanName) &#123;</span><br><span class="line">        &#x2F;&#x2F;若是别名 或 并非工厂bean生产出来的 或 被其他某个bean所依赖，那么判断其被使用过</span><br><span class="line">        return isAlias(beanName) || containsLocalBean(beanName) || hasDependentBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Determine whether the given bean requires destruction on shutdown.</span><br><span class="line">     * &lt;p&gt;The default implementation checks the DisposableBean interface as well as</span><br><span class="line">     * a specified destroy method and registered DestructionAwareBeanPostProcessors.</span><br><span class="line">     * @param bean the bean instance to check</span><br><span class="line">     * @param mbd the corresponding bean definition</span><br><span class="line">     * @see org.springframework.beans.factory.DisposableBean</span><br><span class="line">     * @see AbstractBeanDefinition#getDestroyMethodName()</span><br><span class="line">     * @see org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean requiresDestruction(Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">        return (bean !&#x3D; null &amp;&amp;</span><br><span class="line">                (DisposableBeanAdapter.hasDestroyMethod(bean, mbd) || hasDestructionAwareBeanPostProcessors()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Add the given bean to the list of disposable beans in this factory,</span><br><span class="line">     * registering its DisposableBean interface and&#x2F;or the given destroy method</span><br><span class="line">     * to be called on factory shutdown (if applicable). Only applies to singletons.</span><br><span class="line">     * @param beanName the name of the bean</span><br><span class="line">     * @param bean the bean instance</span><br><span class="line">     * @param mbd the bean definition for the bean</span><br><span class="line">     * @see RootBeanDefinition#isSingleton</span><br><span class="line">     * @see RootBeanDefinition#getDependsOn</span><br><span class="line">     * @see #registerDisposableBean</span><br><span class="line">     * @see #registerDependentBean</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">        AccessControlContext acc &#x3D; (System.getSecurityManager() !&#x3D; null ? getAccessControlContext() : null);</span><br><span class="line">        if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) &#123;</span><br><span class="line">            if (mbd.isSingleton()) &#123;</span><br><span class="line">                &#x2F;&#x2F; Register a DisposableBean implementation that performs all destruction</span><br><span class="line">                &#x2F;&#x2F; work for the given bean: DestructionAwareBeanPostProcessors,</span><br><span class="line">                &#x2F;&#x2F; DisposableBean interface, custom destroy method.</span><br><span class="line">                registerDisposableBean(beanName,</span><br><span class="line">                        new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                &#x2F;&#x2F; A bean with a custom scope...</span><br><span class="line">                Scope scope &#x3D; this.scopes.get(mbd.getScope());</span><br><span class="line">                if (scope &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;No Scope registered for scope &#39;&quot; + mbd.getScope() + &quot;&#39;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                scope.registerDestructionCallback(beanName,</span><br><span class="line">                        new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line">    &#x2F;&#x2F; Abstract methods to be implemented by subclasses</span><br><span class="line">    &#x2F;&#x2F;---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;标记是否包含Bean定义的方法</span><br><span class="line">    protected abstract boolean containsBeanDefinition(String beanName);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据Bean名返回其BeanDefinition</span><br><span class="line">    protected abstract BeanDefinition getBeanDefinition(String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据指定的bean定义和bean名、参数，创建对象</span><br><span class="line">    protected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args)</span><br><span class="line">            throws BeanCreationException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>FactoryBeanRegistrySupport，并且实现了BeanFactory重要的第三级接口——ConfigurableBeanFactory。需要具体了解这个接口，可以去看我之前的接口分析——Spring源码分析——BeanFactory体系之接口详细分析 。ConfigurableBeanFactory是一个非常复杂的接口，继承了HierarchicalBeanFactory和SingletonBeanRegistry，主要实现了工厂创建、注册Bean、单例类注册等各种功能。</p>
<p>　　AbstractBeanFactory实现了ConfigurableBeanFactory接口的绝大多数方法，实现了Bean工厂的许多重要功能，如BeanDefinition、RootBeanDefinition、原型、单例相关的各种操作。</p>
<p>　　下面列出一些主要方法实现，其他的方法说明，可具体参照上文我贴出的大部分注释过的源码。</p>
<p>（1）、从容器中获取bean的方法——doGetBean：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    protected &lt;T&gt; T doGetBean(</span><br><span class="line">            final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</span><br><span class="line">            throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">        final String beanName &#x3D; transformedBeanName(name);&#x2F;&#x2F;在aliasMap中取得的标准名</span><br><span class="line">        Object bean;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Eagerly check singleton cache for manually registered singletons.</span><br><span class="line">        Object sharedInstance &#x3D; getSingleton(beanName);&#x2F;&#x2F;首先在单例集合中取</span><br><span class="line">        if (sharedInstance !&#x3D; null &amp;&amp; args &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;如果取得到，没有指定参数</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;&#x2F;&#x2F;若Log允许调试</span><br><span class="line">                if (isSingletonCurrentlyInCreation(beanName)) &#123;&#x2F;&#x2F;若正准备创建，输出日志</span><br><span class="line">                    logger.debug(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +</span><br><span class="line">                            &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;&#x2F;&#x2F;根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例</span><br><span class="line">            bean &#x3D; getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123;</span><br><span class="line">            if (isPrototypeCurrentlyInCreation(beanName)) &#123;&#x2F;&#x2F;如果正在被创建，就抛出异常</span><br><span class="line">                throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();&#x2F;&#x2F;取本容器的父容器</span><br><span class="line">            if (parentBeanFactory !&#x3D; null &amp;&amp; !containsBeanDefinition(beanName)) &#123;&#x2F;&#x2F;若存在父容器，且本容器不存在对应的Bean定义</span><br><span class="line">                String nameToLookup &#x3D; originalBeanName(name);&#x2F;&#x2F;取原始的Bean名</span><br><span class="line">                if (args !&#x3D; null) &#123;&#x2F;&#x2F;若参数列表存在</span><br><span class="line">                    &#x2F;&#x2F; 那么用父容器根据原始Bean名和参数列表返回</span><br><span class="line">                    return (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 参数列表不要求，那就直接根据原始名称和要求的类型返回</span><br><span class="line">                    return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果不需要类型检查，标记其已经被创建</span><br><span class="line">            if (!typeCheckOnly) &#123;</span><br><span class="line">                markBeanAsCreated(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;根据beanName取其根Bean定义</span><br><span class="line">            final RootBeanDefinition mbd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            String[] dependsOn &#x3D; mbd.getDependsOn();&#x2F;&#x2F;得到这个根定义的所有依赖</span><br><span class="line">            if (dependsOn !&#x3D; null) &#123;</span><br><span class="line">                for (String dependsOnBean : dependsOn) &#123;</span><br><span class="line">                    getBean(dependsOnBean);&#x2F;&#x2F;注册这个Bean</span><br><span class="line">                    &#x2F;&#x2F;注册一个Bean和依赖于它的Bean（后参数依赖前参数）</span><br><span class="line">                    registerDependentBean(dependsOnBean, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果Bean定义是单例，就在返回单例</span><br><span class="line">            if (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance &#x3D; getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                    public Object getObject() throws BeansException &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            return createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        catch (BeansException ex) &#123;</span><br><span class="line">                            destroySingleton(beanName);</span><br><span class="line">                            throw ex;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                &#x2F;&#x2F;根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例</span><br><span class="line">                bean &#x3D; getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果是原型</span><br><span class="line">            else if (mbd.isPrototype()) &#123;</span><br><span class="line">                &#x2F;&#x2F; It&#39;s a prototype -&gt; create a new instance.</span><br><span class="line">                Object prototypeInstance &#x3D; null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);&#x2F;&#x2F;原型创建前，与当前线程绑定</span><br><span class="line">                    prototypeInstance &#x3D; createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                finally &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);&#x2F;&#x2F;原型创建后，与当前线程解除绑定</span><br><span class="line">                &#125;</span><br><span class="line">                bean &#x3D; getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            else &#123;&#x2F;&#x2F;既不是单例又不是原型的情况</span><br><span class="line">                String scopeName &#x3D; mbd.getScope();</span><br><span class="line">                final Scope scope &#x3D; this.scopes.get(scopeName);&#x2F;&#x2F;得到范围</span><br><span class="line">                if (scope &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;No Scope registered for scope &#39;&quot; + scopeName + &quot;&#39;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;&#x2F;&#x2F;根据范围创建实例</span><br><span class="line">                    Object scopedInstance &#x3D; scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                        public Object getObject() throws BeansException &#123;</span><br><span class="line">                            beforePrototypeCreation(beanName);</span><br><span class="line">                            try &#123;</span><br><span class="line">                                return createBean(beanName, mbd, args);&#x2F;&#x2F;原型创建前，与当前线程绑定</span><br><span class="line">                            &#125;</span><br><span class="line">                            finally &#123;</span><br><span class="line">                                &#x2F;&#x2F;&#x2F;&#x2F;原型创建后，与当前线程解除绑定</span><br><span class="line">                                afterPrototypeCreation(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    &#x2F;&#x2F;根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例</span><br><span class="line">                    bean &#x3D; getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (IllegalStateException ex) &#123;</span><br><span class="line">                    throw new BeanCreationException(beanName,</span><br><span class="line">                            &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; &quot; +</span><br><span class="line">                            &quot;consider defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,</span><br><span class="line">                            ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断要求的类型是否和Bean实例的类型正在匹配</span><br><span class="line">        if (requiredType !&#x3D; null &amp;&amp; bean !&#x3D; null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return getTypeConverter().convertIfNecessary(bean, requiredType);&#x2F;&#x2F;转换类型，不抛出异常就说明类型匹配</span><br><span class="line">            &#125;</span><br><span class="line">            catch (TypeMismatchException ex) &#123;</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type [&quot; +</span><br><span class="line">                            ClassUtils.getQualifiedName(requiredType) + &quot;]&quot;, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (T) bean;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面对这个方法进行简要的解释：</p>
<p>　　&lt;1&gt;、这个方法形参为final String name, final Class<T> requiredType, final Object[] args, boolean typeCheckOnly，分别表示Bean的名称、要求返回的Bean的类型、取Bean时提供的参数数组 以及 是否需要类型检查。哦</p>
<p>　　&lt;2&gt;、final String beanName = transformedBeanName(name); 这个方法是从aliasMap中取得对应的标准名。方法实现是，首先去掉name的 FACTORY_BEAN_PREFIX 前缀（如果是工厂Bean本身，那么Bean名有这个前缀），然后调用SimpleAliasRegistry的canonicalName方法。上篇博客已经介绍过SimpleAliasRegistry了，这里贴一下这个方法的源码：</p>
<p>/*<br>     * 根据name这个Key，在aliasMap中不断循环的取对应的value，如果取得到，就继续根据这个value取值，不断循环继续。<br>     * 直到取不到，就把这个在aliasMap中无对应值的key返回。这个动作，叫规范名<br>     */</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String canonicalName(String name) &#123;</span><br><span class="line">    String canonicalName &#x3D; name;    &#x2F;&#x2F;规范名</span><br><span class="line">    &#x2F;&#x2F; Handle aliasing...</span><br><span class="line">    String resolvedName;&#x2F;&#x2F;已解析名</span><br><span class="line">    do &#123;</span><br><span class="line">        resolvedName &#x3D; this.aliasMap.get(canonicalName);&#x2F;&#x2F;aliasMap中规范名对应的值赋值给已解析名</span><br><span class="line">        if (resolvedName !&#x3D; null) &#123;&#x2F;&#x2F;如果已解析名存在（即规范名在aliasMap中有对应的值）</span><br><span class="line">            canonicalName &#x3D; resolvedName;   &#x2F;&#x2F; 这个已解析名赋值给标准名</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (resolvedName !&#x3D; null);&#x2F;&#x2F;不断循环，直到已解析名不存在</span><br><span class="line">    return canonicalName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　&lt;3&gt;、首先根据标准名beanName，在单例缓存中取对应的Bean：Object sharedInstance = getSingleton(beanName);</p>
<p>　　&lt;4&gt;、如果取得到，且args为空，根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例：bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);然后结束整个方法。这个方法源码如下：</p>
<p>//根据给定的实例是否为工厂Bean，返回它自己或工厂Bean创建的实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Object getObjectForBeanInstance(</span><br><span class="line">            Object beanInstance, String name, String beanName, RootBeanDefinition mbd) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果这个Bean是工厂Bean创建的 且 这个Bean实例并不是FactoryBean实例，抛异常</span><br><span class="line">        if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">            throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果这个Bean实例并不是FactoryBean实例 或 这个Bean是工厂Bean创建的，直接返回</span><br><span class="line">        if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">            return beanInstance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;——————————以下都是 这个Bean实例是FactoryBean实例的情况</span><br><span class="line">        Object object &#x3D; null;</span><br><span class="line">        if (mbd &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;若根Bean定义为空，取这个BeanFactory所生产的实例</span><br><span class="line">            object &#x3D; getCachedObjectForFactoryBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        if (object &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;若取不到，那么手动取</span><br><span class="line">            FactoryBean&lt;?&gt; factory &#x3D; (FactoryBean&lt;?&gt;) beanInstance;&#x2F;&#x2F;把这个实例转化成一个FactoryBean</span><br><span class="line">            &#x2F;&#x2F; Caches object obtained from FactoryBean if it is a singleton.</span><br><span class="line">            if (mbd &#x3D;&#x3D; null &amp;&amp; containsBeanDefinition(beanName)) &#123;&#x2F;&#x2F;若根Bean定义为空，但是容器内有Bean定义</span><br><span class="line">                mbd &#x3D; getMergedLocalBeanDefinition(beanName);&#x2F;&#x2F;返回合并后的Bean定义</span><br><span class="line">            &#125;</span><br><span class="line">            boolean synthetic &#x3D; (mbd !&#x3D; null &amp;&amp; mbd.isSynthetic());&#x2F;&#x2F;标记这个Bean定义是合并的</span><br><span class="line">            object &#x3D; getObjectFromFactoryBean(factory, beanName, !synthetic);&#x2F;&#x2F;从工厂Bean中取</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>　　&lt;5&gt;、如果取不到、或 args 不为空（下面都是基于这个条件）：</p>
<p>（如果对应的Bean正在被创建，就抛出异常）首先用父容器（如果本容器有的话）根据给出的形参取对应的Bean。</p>
<p>　　&lt;6&gt;、此时，判断，如果不需要类型检查，标记其已经被创建。</p>
<p>　　&lt;7&gt;、根据beanName取本地合并后的RootBeanDefinition（这个方法getMergedLocalBeanDefinition涉及到多层BeanDefinition相关的调用），然后检查一下。然后根据这个RootBeanDefinition，注册这个Bean和它的所有依赖。</p>
<p>　　&lt;8&gt;、如果这个RootBeanDefinition是单例，先根据beanName从单例缓存中取，取不到就创建一个匿名内部Bean工厂，创建一个单例，直接结束方法。</p>
<p>　　&lt;9&gt;、如果这个RootBeanDefinition是原型，就直接创建一个Bean返回，并在创建前把beanName与当前线程绑定，创建后解绑。</p>
<p>　　&lt;10&gt;、如果这个RootBeanDefinition既不是单例，又不是原型，那么根据这个RootBeanDefinition定义的范围Scope，直接创建一个scopedInstance。</p>
<p>　　&lt;11&gt;、若这个scopedInstance为工厂Bean，就得到它创建的实例，否则得到它自身。</p>
<p>　　&lt;12&gt;、对&lt;9&gt;或&lt;11&gt;中最后产生的Bean就进行一次检查，要求这个产生的Bean的类型是否和Bean实例的类型匹配，不匹配就抛出异常。</p>
<p>　　以上就是这个doGetBean方法了。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>ioc</tag>
        <tag>bean</tag>
      </tags>
  </entry>
  <entry>
    <title>java数组的复制与填充</title>
    <url>/2020/03/25/java%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%A1%AB%E5%85%85/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       &#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;复制&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;</span><br><span class="line">        &#x2F;&#x2F;克隆</span><br><span class="line">        int[] a &#x3D; &#123;1,2,3,4&#125;;</span><br><span class="line">&#x2F;&#x2F;        int[] copyA &#x3D; a.clone();</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        int[] copyA &#x3D; Arrays.copyOf(a, 4);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        int[] copyA &#x3D; Arrays.copyOfRange(a, 1, 4);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;       &#x2F;&#x2F;a数组的0开始复制到copyA的1开始，复制长度3</span><br><span class="line">&#x2F;&#x2F;        int[] copyA &#x3D; new int[4];</span><br><span class="line">&#x2F;&#x2F;        System.arraycopy(a, 0, copyA, 1, 3);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(Arrays.toString(copyA));</span><br><span class="line"></span><br><span class="line">        &#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;填充&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;</span><br><span class="line">        Arrays.fill(a, 100);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line"></span><br><span class="line">        Arrays.fill(a, 1,3,99);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>神奇的位运算</title>
    <url>/2020/03/25/%E7%A5%9E%E5%A5%87%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p><strong>1.x = x&amp;(x-1)</strong></p>
<blockquote>
<p>每一次运算将x的二进制形式中最右边的1（包括1）及其后面置0<br>应用：统计出x的二进制有多少个1<br>还可以判断是不是2的n次方（因为如果一个数是2的n次方，那么这个数用二进制表示时其最高位为1，其余位为0。），顺便一提，左移右移也是变换2的n次方的快速方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int func(x) &#123; </span><br><span class="line">    int count &#x3D; 0; </span><br><span class="line">    while(x)   &#123; </span><br><span class="line">          count ++; </span><br><span class="line">          x &#x3D; x&amp;(x-1); </span><br><span class="line">     &#125; </span><br><span class="line">    return count; </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public static boolean func(x) &#123; </span><br><span class="line">    if( (x&amp;(x-1)) &#x3D;&#x3D; 0 )  return true;</span><br><span class="line">    else return false;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><strong>2. x^x = 0、0^x = x</strong></p>
<blockquote>
<p>奇偶个数的判断<br>应用：找出一个数组中只出现一次的数，其他都是两次。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int singleNumber(int[] nums) &#123;</span><br><span class="line">       int result &#x3D; 0;</span><br><span class="line">       for(int i &#x3D; 0 ; i &lt; nums.length ; i++ )&#123;</span><br><span class="line">       result ^&#x3D; nums[i];</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>**3.x &amp; (-x) **</p>
<blockquote>
<p>保留位中最右边 1 ，且将其余的 1 设位 0 的方法。</p>
</blockquote>
<p><strong>4.不用“+”，实现“+”</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int getSum(int a, int b) &#123;</span><br><span class="line">       while (b !&#x3D; 0) &#123;&#x2F;&#x2F; 当进位不为0时</span><br><span class="line">           &#x2F;&#x2F; 无进位累加值</span><br><span class="line">            int temp &#x3D; a ^ b;</span><br><span class="line">            &#x2F;&#x2F; 进位值</span><br><span class="line">            int carry &#x3D; (a &amp; b) &lt;&lt; 1;</span><br><span class="line">            </span><br><span class="line">            a &#x3D; temp;</span><br><span class="line">            b &#x3D; carry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.十进制数判断奇偶性</strong></p>
<blockquote>
<p>看其二进制最后一位（当然不用转二进制，x&amp;1即可拿到最后一位），是1为奇数，是0为偶数</p>
</blockquote>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程</title>
    <url>/2020/03/07/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、创建线程"><a href="#一、创建线程" class="headerlink" title="一、创建线程"></a>一、创建线程</h1><h2 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1.继承Thread类"></a>1.继承Thread类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadTest extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; is running&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ThreadTest().start();</span><br><span class="line">        new ThreadTest().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2.实现Runnable接口"></a>2.实现Runnable接口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RunnableTest implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; is running&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        RunnableTest runnableTest &#x3D; new RunnableTest();</span><br><span class="line">        </span><br><span class="line">        new Thread(runnableTest,&quot;线程1&quot;).start();</span><br><span class="line">        new Thread(runnableTest,&quot;线程2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Callable和Future"><a href="#3-Callable和Future" class="headerlink" title="3.Callable和Future"></a>3.Callable和Future</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CallableTest implements Callable&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String call()&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot; is running&quot;);</span><br><span class="line">        return &quot;ok&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        Callable&lt;String&gt; callable  &#x3D;new CallableTest();</span><br><span class="line">        Thread thread1&#x3D;new Thread(new FutureTask&lt;&gt;(callable));</span><br><span class="line">        Thread thread2&#x3D;new Thread(new FutureTask&lt;&gt;(callable));</span><br><span class="line">&#x2F;&#x2F;		thread1.setName(&quot;线程一&quot;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        &#x2F;&#x2F;System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4.线程池"></a>4.线程池</h2><blockquote>
<p>newCachedThreadPool()<br>    缓存型池子，先查看池中有没有以前建立的线程，如果有，如果没有，就建一个新的线程加入池中<br>newFixedThreadPool(int)<br>    最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待<br>newScheduledThreadPool(int)<br>调度型线程池，这个池子里的线程可以按schedule依次delay执行，或周期执行   SingleThreadExecutor()<br>单例线程，任意时间池中只能有一个线程</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        new threadPool().run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class threadPool&#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newFixedThreadPool(3);</span><br><span class="line">        for (int i &#x3D;0;i&lt;10;i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;:doSomething start&quot;);</span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;:doSomething end&quot;);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二-锁"><a href="#二-锁" class="headerlink" title="二.锁"></a>二.锁</h1><h2 id="1-synchronized"><a href="#1-synchronized" class="headerlink" title="1.synchronized"></a>1.synchronized</h2><blockquote>
<p>Java语言内置关键字，JVM会让线程自动释放锁。</p>
</blockquote>
<h2 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2.ReentrantLock"></a>2.ReentrantLock</h2><blockquote>
<p>是一个类，通过这个类可以实现同步访问，必须要用户去手动释放锁。独占锁</p>
</blockquote>
<h2 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3.Semaphore"></a>3.Semaphore</h2><blockquote>
<p>信号量，类似PV原语，acquire()减少信号量，release()增多信号量。共享锁</p>
</blockquote>
<h2 id="4-CountDownLatch"><a href="#4-CountDownLatch" class="headerlink" title="4.CountDownLatch"></a>4.CountDownLatch</h2><blockquote>
<p>与join()功能类似，当前执行线程等待join线程执行结束。是主等客的关系。</p>
</blockquote>
<h2 id="5-CyclicBarrier"><a href="#5-CyclicBarrier" class="headerlink" title="5.CyclicBarrier"></a>5.CyclicBarrier</h2><blockquote>
<p>类似软件测试里讲的集合点的概念（性能测试）。这个类也可以实现一组线程在到达某个条件之前进行等待，是客与客之间的关系。比如，王者荣耀等10个人都100%才开始游戏。它们内部都有一个计数器，当计数器的值不断的减为0的时候所有阻塞的线程将会被唤醒。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200414131519266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="6-AbstractQueuedSynchronizer（AQS）"><a href="#6-AbstractQueuedSynchronizer（AQS）" class="headerlink" title="6.AbstractQueuedSynchronizer（AQS）"></a>6.AbstractQueuedSynchronizer（AQS）</h2><blockquote>
<p>上面的类都依赖与AQS所提供的队列式同步器。每个线程封装在Node。源码分析交给大佬，我就到此为止。</p>
</blockquote>
]]></content>
      <tags>
        <tag>并发编程</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java高级特性概要</title>
    <url>/2020/02/22/java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E6%A6%82%E8%A6%81/</url>
    <content><![CDATA[<p>Java注解<br>注解的本质<br>@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)<br>public @interface Override {<br>}<br>这是注解 @Override 的定义，其实它本质上就是：<br>public interface Override extends Annotation{<br>}<br>有关这一点，你可以去反编译任意一个注解类。</p>
<p>@Target：注解的作用目标<br>ElementType 是一个枚举类型，有以下一些值：<br>ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上<br>ElementType.FIELD：允许作用在属性字段上<br>ElementType.METHOD：允许作用在方法上<br>ElementType.PARAMETER：允许作用在方法参数上<br>ElementType.CONSTRUCTOR：允许作用在构造器上<br>ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上<br>ElementType.ANNOTATION_TYPE：允许作用在注解上<br>ElementType.PACKAGE：允许作用在包上</p>
<p>@Retention：注解的生命周期<br>RetentionPolicy 依然是一个枚举类型：<br>RetentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件<br>RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件<br>RetentionPolicy.RUNTIME：永久保存，可以反射获取</p>
<p>@Documented：注解是否应当被包含在 JavaDoc 文档中<br>@Inherited：是否允许子类继承该注解</p>
<p>JAVA 的内置三大注解<br>除了上述四种元注解外，JDK 还为我们预定义了另外三种注解，它们是：<br>@Override         //匹对父类中是否具有一个同样的方法<br>@Deprecated      //标记已经不再被推荐使用了，可能下一次的 JDK 版本就会删除。<br>@SuppressWarnings        //压制警告（看着烦人）</p>
<p>自定义注解<br>public @interface BugReport {<br>   enum Status {UNCONFIRMED, CONFIRMED, FIXED, NOTABUG};<br>   boolean showStopper() default true;<br>   String assiganedTo() default “[none]”;<br>   Status status() default Status.UNCONFIRMED;<br>   String[] reportedBy();<br>}</p>
<p>注解与反射<br>Class 类中提供了以下一些方法用于反射注解：<br>getAnnotation：返回指定的注解<br>isAnnotationPresent：判定当前元素是否被指定注解修饰<br>getAnnotations：返回所有的注解<br>getDeclaredAnnotation：返回本元素的指定注解<br>getDeclaredAnnotations：返回本元素的所有注解，不包含父类继承而来的</p>
<p>Java反射<br>Class&lt;?&gt; classTest = Class.forName(“”);<br>setAccessible(true); //临时改变私有的东西<br>getConstructor(String.class,String.class);    //构造方法<br>getDeclaredConstructor(String.class,String.class);<br>newInstance()  //创建实例<br>getFields()    // 反射本类及父类所有的public属性<br>getDeclaredFields() // 反射本类所有属性(包括公有和私有)<br>    Fild.getName() //属性名<br>    Fild.get(obj) //属性值<br>getMethods()    // 反射本类及父类所有的public方法<br>getDeclaredMethods()// 反射本类所有方法(包括公有和私有)<br>invoke(obj,arg…)    //执行方法<br>Java代理</p>
<p>应用：<br>基于反射、注解、代理，<br>实现简易AOP、实现简易ORM、实现简易Spring框架</p>
<p>ClassLoader 中与加载类相关的方法<br>方法    说明<br>getParent()    返回该类加载器的父类加载器。<br>loadClass(String name)    加载名称为name的类，返回的结果是 java.lang.Class类的实例。<br>findClass(String name)    查找名称为name的类，返回的结果是 java.lang.Class类的实例。<br>findLoadedClass(String name)    查找名称为name的已经被加载过的类，返回的结果是 java.lang.Class类的实例。<br>defineClass(String name, byte[] b, int off, int len)    把字节数组 b中的内容转换成 Java 类，返回的结是 java.lang.Class类的实例。这个方法被声明为final的。<br>resolveClass(Class&lt;?&gt; c)    链接指定的 Java 类。</p>
<p>public class test{<br> <br>   public static void main(String[] args) {<br>       ClassLoader loader = test.class.getClassLoader();<br>       while (loader != null) {<br>           System.out.println(loader.toString());<br>           loader = loader.getParent();<br>       }<br>   }<br>}</p>
<p>class文件结构<br>类型    名称    说明    长度<br>u4    magic    魔数，识别Class文件格式    4个字节<br>u2    minor_version    副版本号    2个字节<br>u2    major_version    主版本号    2个字节<br>u2    constant_pool_count    常量池计算器    2个字节<br>cp_info    constant_pool    常量池    n个字节<br>u2    access_flags    访问标志    2个字节<br>u2    this_class    类索引    2个字节<br>u2    super_class    父类索引    2个字节<br>u2    interfaces_count    接口计数器    2个字节<br>u2    interfaces    接口索引集合    2个字节<br>u2    fields_count    字段个数    2个字节<br>field_info    fields    字段集合    n个字节<br>u2    methods_count    方法计数器    2个字节<br>method_info    methods    方法集合    n个字节<br>u2    attributes_count    附加属性计数器    2个字节<br>attribute_info    attributes    附加属性集合    n个字节<br>类型    标志    描述<br>CONSTANT_utf8_info    1    UTF-8编码的字符串<br>CONSTANT_Integer_info    3    整形字面量<br>CONSTANT_Float_info    4    浮点型字面量<br>CONSTANT_Long_info    5    长整型字面量<br>CONSTANT_Double_info    6    双精度浮点型字面量<br>CONSTANT_Class_info    7    类或接口的符号引用<br>CONSTANT_String_info    8    字符串类型字面量<br>CONSTANT_Fieldref_info    9    字段的符号引用<br>CONSTANT_Methodref_info    10    类中方法的符号引用<br>CONSTANT_InterfaceMethodref_info    11    接口中方法的符号引用<br>CONSTANT_NameAndType_info    12    字段或方法的符号引用<br>CONSTANT_MethodHandle_info    15    表示方法句柄<br>CONSTANT_MothodType_info    16    标志方法类型<br>CONSTANT_InvokeDynamic_info    18    表示一个动态方法调用点</p>
<p>表的结构信息</p>
<p>类的访问信息表<br>标志名称    标志值    含义<br>ACC_PUBLIC    0x0001    是否为Public类型<br>ACC_FINAL    0x0010    是否被声明为final，只有类可以设置<br>ACC_SUPER    0x0020    是否允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真<br>ACC_INTERFACE    0x0200    标志这是一个接口<br>ACC_ABSTRACT    0x0400    是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假<br>ACC_SYNTHETIC    0x1000    标志这个类并非由用户代码产生<br>ACC_ANNOTATION    0x2000    标志这是一个注解<br>ACC_ENUM    x4000    标志这是一个枚举<br>字段表结构<br>field_info {<br>    u2 access_flags;<br>    u2 name_index;<br>    u2 descriptor_index;<br>    u2 attributes_count;<br>    attribute_info attributes[attributes_count];<br>}</p>
<p>类型    名称    含义    数量<br>u2    access_flags    访问标志    1<br>u2    name_index    字段名索引    1<br>u2    descriptor_index    描述符索引    1<br>u2    attributes_count    属性计数器    1<br>attribute_info    attributes    属性集合    attributes_count<br>字段的访问信息表<br>标志名称    标志值    含义<br>ACC_PUBLIC    0x0001    字段是否为public<br>ACC_PRIVATE    0x0002    字段是否为private<br>ACC_PROTECTED    0x0004    字段是否为protected<br>ACC_STATIC    0x0008    字段是否为static<br>ACC_FINAL    0x0010    字段是否为final<br>ACC_VOLATILE    0x0040    字段是否为volatile<br>ACC_TRANSTENT    0x0080    字段是否为transient<br>ACC_SYNCHETIC    0x1000    字段是否为由编译器自动产生<br>ACC_ENUM    0x4000    字段是否为enum<br>方法表结构<br>method_info {<br>    u2 access_flags;<br>    u2 name_index;<br>    u2 descriptor_index;<br>    u2 attributes_count;<br>    attribute_info attributes[attributes_count];<br>}<br>类型    名称    含义    数量<br>u2    access_flags    访问标志    1<br>u2    name_index    方法名索引    1<br>u2    descriptor_index    描述符索引    1<br>u2    attributes_count    属性计数器    1<br>attribute_info    attributes    属性集合    attributes_count</p>
<p>方法访问信息表<br>标志名称    标志值    含义<br>ACC_PUBLIC    0x0001    方法是否为public<br>ACC_PRIVATE    0x0002    方法是否为private<br>ACC_PROTECTED    0x0004    方法是否为protected<br>ACC_STATIC    0x0008    方法是否为static<br>ACC_FINAL    0x0010    方法是否为final<br>ACC_SYHCHRONRIZED    0x0020    方法是否为synchronized<br>ACC_BRIDGE    0x0040    方法是否是有编译器产生的方法<br>ACC_VARARGS    0x0080    方法是否接受参数<br>ACC_NATIVE    0x0100    方法是否为native<br>ACC_ABSTRACT    0x0400    方法是否为abstract<br>ACC_STRICTFP    0x0800    方法是否为strictfp<br>ACC_SYNTHETIC    0x1000    方法是否是有编译器自动产生的<br>属性表通用格式<br>attribute_info {<br>    u2 attribute_name_index;   //属性名索引<br>    u4 attribute_length;       //属性长度<br>u1 info[attribute_length]; //属性的具体内容<br>}<br>类型    名称    数量    含义<br>u2    attribute_name_index    1    属性名索引<br>u2    attribute_length    1    属性长度<br>u1    info    attribute_length    属性表<br>Code 属性<br>Code_attribute {<br>    u2 attribute_name_index; //常量池中的uft8类型的索引，值固定为”Code“<br>    u4 attribute_length; //属性值长度，为整个属性表长度-6<br>    u2 max_stack;   //操作数栈的最大深度值，jvm运行时根据该值分配栈帧<br>    u2 max_locals;  //局部变量表最大存储空间，单位是slot<br>    u4 code_length; // 字节码指令的个数<br>    u1 code[code_length]; // 具体的字节码指令<br>    u2 exception_table_length; //异常的个数<br>    {   u2 start_pc;<br>        u2 end_pc;<br>        u2 handler_pc; //当字节码在[start_pc, end_pc)区间出现catch_type或子类，则转到handler_pc行继续处理。<br>        u2 catch_type; //当catch_type=0，则任意异常都需转到handler_pc处理<br>    } exception_table[exception_table_length]; //具体的异常内容<br>    u2 attributes_count;     //属性的个数<br>attribute_info attributes[attributes_count]; //具体的属性内容<br>}</p>
<p>类型    名称    数量    含义<br>u2    attribute_name_index    1    属性名索引<br>u4    attribute_length    1    属性长度<br>u2    max_stack    1    操作数栈深度的最大值<br>u2    max_locals    1    局部变量表所需的存续空间<br>u4    code_length    1    字节码指令的长度<br>u1    code    code_length    存储字节码指令<br>u2    exception_table_length    1    异常表长度<br>exception_info    exception_table    exception_length    异常表<br>u2    attributes_count    1    属性集合计数器<br>attribute_info    attributes    attributes_count    属性集合</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java class文件分析实列</title>
    <url>/2020/02/19/Java%20class%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E5%AE%9E%E5%88%97/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200219141935647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2019/12/27/Linux/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>要玩Linux系统，当然得先装个双系统（绝大多数个人电脑都是预装window）。<br>装双系统一般有两种方式：</p>
<ol>
<li><p>直接往硬件上安装<br> 这种涉及分区问题。</p>
<pre><code>  a.电脑有固态硬盘+机械硬盘</code></pre>
<p> 一般window操作系统都装在固态硬盘上，再装双系统（比如Ubuntu）时，分区的时候，也从固态上分一点给它，如果你从机械盘上分，会涉及一个麻烦的问题。安装成功后，开机引导变为Ubuntu的，要想切回window系统去，就得进入boot切换从固态硬盘去启动，比较麻烦。</p>
<pre><code> 从同一个盘分的好处就是，启动的时候切换不同系统启动容易一点。
 我用window10装Ubuntu，就搞了这一波坑的，折腾了半天，又删除了Ubuntu，用PE装机工具把分区弄回去，心酸~~~</code></pre>
<p>  b.电脑只有机械硬盘分区时就不存在上述问题了。</p>
</li>
<li><p>虚拟机安装<br> 这种我觉得最大的好处就是，window能和它宏观上并行，双系统就像一个应用程序来运行，遇到问题了，回到window百度。也不像在硬盘上安装，不小心还把盘给搞炸了。所以一般都选择安装虚拟机。安装过程很简单，教程很多，这就不说了。<br> <strong><em>注：虚拟机安装后界面会小，安装tools就行了，主机上的东西还能直接粘过去。</em></strong></p>
</li>
</ol>
<ul>
<li><h1 id="以Ubuntu为例"><a href="#以Ubuntu为例" class="headerlink" title="以Ubuntu为例"></a>以Ubuntu为例</h1><p>  一切都安装好之后，输入密码即可进入Ubuntu系统。进入新系统，首先肯定是熟悉命令，下面列出几个我觉得很常用的（一些命令会有参数达到不同效果，自行了解）：</p>
<blockquote>
<p>Ctrl+alt+t    ———-弹出终端<br>   pwd ——–查看当前路径<br>   ls——–查看当前路径下的文件等<br>   ls 字母* ———查看以什么什么开头的文件<br>   cd——切换不同路径<br>   tar -zxvf FileName.tar.gz————解压<br>   mv file1 file2 ———-移动文件<br>   su——切换用户（首次没有root，因为没有设置root密码，sudo passwd）<br>   whereis sth———查看sth在哪个路径<br>   sudo apt-get -f install———安装软件<br>   sudo dpkg -i XXX.deb——–安装软件安装包</p>
</blockquote>
<p>  熟悉一些命令之后那就开始改头换面了。</p>
<ul>
<li><h1 id="改头换面"><a href="#改头换面" class="headerlink" title="改头换面"></a>改头换面</h1><ul>
<li><h2 id="必做"><a href="#必做" class="headerlink" title="必做"></a>必做</h2><p>  更换下载源，我换成阿里的，速度可以。</p>
</li>
<li><h2 id="卸载Ubuntu自带的一些软件"><a href="#卸载Ubuntu自带的一些软件" class="headerlink" title="卸载Ubuntu自带的一些软件"></a>卸载Ubuntu自带的一些软件</h2><blockquote>
<p>卸载火狐<br>sudo apt-get purge firefox firefox-locale-en firefox-locale-zh-hans unity-scope-firefoxbookmarks<br>自带的各种软件：<br>libreoffice-common libreoffice（可以换 WPS）<br>unity-webapps-common Amazon 链接<br>thunderbird 雷鸟邮件客户端<br>totem 自带的播放器<br>rhythmbox 自带的音乐播放器<br>empathy 自带的即时聊天应用<br>brasero 自带的光盘刻录器<br>simple-scan 扫描仪<br>gnome-mahjongg 对对碰游戏<br>aisleriot 纸牌游戏<br>gnome-mines 扫雷游戏<br>cheese webcam 应用<br>gnome-sudoku 数独游戏<br>transmission-common BT 客户端<br>gnome-orca 屏幕阅读<br>webbrowser-app Ubuntu 自带的浏览器（有了 chrome 和 Firefox 根本用不到这个）<br>landscape-client-ui-install landscape 远程控制软件<br>deja-dup 备份<br>onboard 屏幕键盘<br>删除不常用软件：<br>apt purge libreoffice-common<br>apt purge unity-webapps-common<br>apt purge thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese gnome-sudoku transmission-common gnome-orca webbrowser-app landscape-client-ui-install<br>apt purge deja-dup</p>
</blockquote>
</li>
<li><h2 id="安装软件（安装过程肯定会遇到一些问题，自行解决，这里就不说了。）"><a href="#安装软件（安装过程肯定会遇到一些问题，自行解决，这里就不说了。）" class="headerlink" title="安装软件（安装过程肯定会遇到一些问题，自行解决，这里就不说了。）"></a>安装软件（安装过程肯定会遇到一些问题，自行解决，这里就不说了。）</h2><blockquote>
<p>vim文本编辑<br>   Chrome浏览器<br>   Wps<br>   cocoMusic音乐播放器<br>   SMPlayer视频播放器<br>   PyCharm（Ubuntu自带不同python版本，可以切换默认版本）<br>   pip（也要更换下载源，我用的阿里，挺快）<br>   jdk<br>   tomcat<br>   MySQL<br>   <img src="https://img-blog.csdnimg.cn/20200208203715364.png" alt="在这里插入图片描述"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><h1 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h1><p>我觉得上面那些做完后，基本上能愉快的玩耍了。当然，我主要分享的是自己用的一些东西，仅供参考。也不注重具体的实施过程，在这个过程中肯定会遇到许多问题（因为我也遇到很多问题），解决这些问题，正是熟悉的过程。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>vmware</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>新手使用云服务器（及其发布Javaweb项目）的若干问题</title>
    <url>/2019/12/27/%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%8F%8A%E5%85%B6%E5%8F%91%E5%B8%83Javaweb%E9%A1%B9%E7%9B%AE%EF%BC%89%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<body>
<div id="top"></div>
</body>


<ul>
<li><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1>  简单交代一下，这篇主要记录一下自己第一次使用云服务器时遇到的问题及其解决办法。看这篇的朋友们，首先对自己电脑本地环境的搭建应该是熟练掌握了。比如jdk、mysql、Tomcat等的配置。如果这在自己电脑上都还没玩懂，那就先别玩服务器了！</li>
<li><h1 id="我用的东西"><a href="#我用的东西" class="headerlink" title="我用的东西"></a>我用的东西</h1></li>
</ul>
<ol>
<li><p>mysql 5.7.21</p>
</li>
<li><p>Tomcat 9.0.11</p>
</li>
<li><p>jdk 1.8</p>
</li>
<li><p>eclipse/IntelliJ IDEA（这看自己习惯了）</p>
</li>
<li><p>腾讯云服务器（windows server 2012 r2）</p>
<p> <strong><em>有了这些基本的东西就能玩起来了！</em></strong></p>
</li>
</ol>
<ul>
<li><h1 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h1><ul>
<li><h2 id="一、配置服务器环境"><a href="#一、配置服务器环境" class="headerlink" title="一、配置服务器环境"></a>一、配置服务器环境</h2><ul>
<li><h3 id="1-开始菜单栏直接搜索远程（或cmd-输命令方式）"><a href="#1-开始菜单栏直接搜索远程（或cmd-输命令方式）" class="headerlink" title="1.开始菜单栏直接搜索远程（或cmd 输命令方式）"></a>1.开始菜单栏直接搜索远程（或cmd 输命令方式）</h3>  如图所示：<pre><code>  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191227102550979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70)    </code></pre>
<ul>
<li><h3 id="2-找到下图中的详细信息，勾选某盘（目的是将其挂载到服务器上，可将自己电脑上资源考到服务器上去）"><a href="#2-找到下图中的详细信息，勾选某盘（目的是将其挂载到服务器上，可将自己电脑上资源考到服务器上去）" class="headerlink" title="2. 找到下图中的详细信息，勾选某盘（目的是将其挂载到服务器上，可将自己电脑上资源考到服务器上去）"></a>2. 找到下图中的详细信息，勾选某盘（目的是将其挂载到服务器上，可将自己电脑上资源考到服务器上去）</h3><img src="https://img-blog.csdnimg.cn/20191227102703780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><h3 id="3-服务器上看到下图所示，就是刚刚我挂载上去的（我的软件全在E盘）"><a href="#3-服务器上看到下图所示，就是刚刚我挂载上去的（我的软件全在E盘）" class="headerlink" title="3.服务器上看到下图所示，就是刚刚我挂载上去的（我的软件全在E盘）"></a>3.服务器上看到下图所示，就是刚刚我挂载上去的（我的软件全在E盘）</h3>  <img src="https://img-blog.csdnimg.cn/20191227103234350.png" alt="在这里插入图片描述"></li>
<li><h3 id="4-然后把jdk、MySQL、tomcat等从挂载上去的盘直接考到服务器的盘上，然后与自己电脑一样，配置环境变量，这就不用多说了。"><a href="#4-然后把jdk、MySQL、tomcat等从挂载上去的盘直接考到服务器的盘上，然后与自己电脑一样，配置环境变量，这就不用多说了。" class="headerlink" title="4.然后把jdk、MySQL、tomcat等从挂载上去的盘直接考到服务器的盘上，然后与自己电脑一样，配置环境变量，这就不用多说了。"></a>4.然后把jdk、MySQL、tomcat等从挂载上去的盘直接考到服务器的盘上，然后与自己电脑一样，配置环境变量，这就不用多说了。</h3>  <img src="https://img-blog.csdnimg.cn/2019122712103484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><ul>
<li><h3 id="验证自己是否安装成功"><a href="#验证自己是否安装成功" class="headerlink" title="验证自己是否安装成功"></a>验证自己是否安装成功</h3><pre><code>  输入Java有效果，那jdk成功了！
  能进入MySQL。说明MySQL成功了（自己电脑上的那些数据库表也都在）
  浏览器的那只小猫在，说明Tomcat成功了！</code></pre>
  <img src="https://img-blog.csdnimg.cn/20191227121413883.png" alt="在这里插入图片描述"></li>
<li><h3 id="注：其中我遇到的小问题"><a href="#注：其中我遇到的小问题" class="headerlink" title="注：其中我遇到的小问题"></a>注：<em>其中我遇到的小问题</em></h3><ol>
<li>jdk是最容易成功的。</li>
<li>安装MySQL时，给我说缺少什么什么 <strong><em>dll</em></strong> 文件，百度试了两种方法，第一种，在自己电脑找到那个dll，考过去，但没用。第二种，下载下图那个东西，在服务器上安装就解决了。<br><img src="https://img-blog.csdnimg.cn/20191227122345140.png" alt="在这里插入图片描述"></li>
<li> Tomcat不行，各种试了试，最终下载了一个新的然后就解决了。（可能我自己电脑上用那个Tomcat被我改过配置文件）</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="二、上述环境都配置无误后，就到了发布Javaweb项目的时候了"><a href="#二、上述环境都配置无误后，就到了发布Javaweb项目的时候了" class="headerlink" title="二、上述环境都配置无误后，就到了发布Javaweb项目的时候了"></a>二、上述环境都配置无误后，就到了发布Javaweb项目的时候了</h2><ul>
<li><h3 id="首先，项目在自己电脑上调试好，跑起来。"><a href="#首先，项目在自己电脑上调试好，跑起来。" class="headerlink" title="首先，项目在自己电脑上调试好，跑起来。"></a>首先，项目在自己电脑上调试好，跑起来。</h3></li>
<li><h3 id="然后，eclipse或IntelliJ-IDEA将其打包。"><a href="#然后，eclipse或IntelliJ-IDEA将其打包。" class="headerlink" title="然后，eclipse或IntelliJ IDEA将其打包。"></a>然后，eclipse或IntelliJ IDEA将其打包。</h3></li>
<li><h3 id="直接往服务器tomcat路径，webapps文件夹下扔就行。"><a href="#直接往服务器tomcat路径，webapps文件夹下扔就行。" class="headerlink" title="直接往服务器tomcat路径，webapps文件夹下扔就行。"></a>直接往服务器tomcat路径，webapps文件夹下扔就行。</h3></li>
<li><h3 id="修改tomcat路径，config文件夹下server文件，端口改为80（这样访问的时候只需要ip，不用加端口号），下加这么一句："><a href="#修改tomcat路径，config文件夹下server文件，端口改为80（这样访问的时候只需要ip，不用加端口号），下加这么一句：" class="headerlink" title="修改tomcat路径，config文件夹下server文件，端口改为80（这样访问的时候只需要ip，不用加端口号），下加这么一句："></a>修改tomcat路径，config文件夹下server文件，端口改为80（这样访问的时候只需要ip，不用加端口号），<host>下加这么一句：</h3><pre><code>    &lt;Context path=&quot;/&quot; docBase=&quot;C:apache-tomcat-9.0.11\webapps\&quot; reloadable=&quot;true&quot;/&gt;</code></pre>
<p>  docBase那里，如果配置到具体的项目，那么访问的时候只需要外网ip就行。如果只配置到webapps，那么访问的时候需要在ip后面加上具体项目名（放在webapps下的打包文件，会被tomcat自动解析）<br><img src="https://img-blog.csdnimg.cn/20191227124020848.png" alt="在这里插入图片描述"></p>
</li>
<li><h3 id="启动Tomcat。"><a href="#启动Tomcat。" class="headerlink" title="启动Tomcat。"></a>启动Tomcat。</h3><p>  浏览器输入自己服务器外网ip访问试试<br>  <img src="https://img-blog.csdnimg.cn/20191227125253898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><h3 id="注：其中我遇到的小问题-1"><a href="#注：其中我遇到的小问题-1" class="headerlink" title="注：其中我遇到的小问题"></a>注：<em>其中我遇到的小问题</em></h3>  自己在服务器上用内网ip可以访问到项目，但用外网ip就访问不到（或者输入外网ip的时候就跳出IIS）：<br>  解决：<ol>
<li>关闭IIS服务<br><img src="https://img-blog.csdnimg.cn/20191227125749573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我的已经关闭了。<br><img src="https://img-blog.csdnimg.cn/20191227125920599.png" alt="在这里插入图片描述"></li>
<li>还是访问不到项目，一开始以为是tomcat的问题，最终解决。<pre><code> 是防火墙的问题。
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191227130138983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70)</code></pre>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><h1 id="结束，-以上就是我自己玩服务器的一点总结，有问题的可以参考一下！"><a href="#结束，-以上就是我自己玩服务器的一点总结，有问题的可以参考一下！" class="headerlink" title="结束， 以上就是我自己玩服务器的一点总结，有问题的可以参考一下！"></a>结束， 以上就是我自己玩服务器的一点总结，有问题的可以参考一下！</h1></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>tomcat</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>关于二进制的一些运算</title>
    <url>/2019/09/29/%E5%85%B3%E4%BA%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<body>
<div id="top"></div>
</body>


<h1 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h1><p>正整数转二进制，这个简单，除2取余，倒着写。<br>容易忽略的是小数，乘2取整，正着写。</p>
<p>负数的话，在计算机中要用补码，因为计算机中加减乘除都得用加法。</p>
<h1 id="机器数与真值"><a href="#机器数与真值" class="headerlink" title="机器数与真值"></a>机器数与真值</h1><p>把符号“数字化”的数称为机器数。<br>把带“+”或“-”符号的数称为真值。</p>
<h1 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h1><p>正数最简单，原码、反码、补码都一样。<br>**<em>例：**</em><br>真值：+1110（已经二进制）<br>原码：01110（0表示符号为正）<br>反码：01110<br>补码：01110</p>
<p>负数复杂一点，<br>*<strong>例1：***<br>真值：-1110（已经二进制）<br>原码：11110（1表示符号为负）<br>反码：10001（符号位不变）<br>补码：10010（取反加1）<br>*</strong>例2：***<br>真值：-0.1101（已经二进制）<br>原码：1.1101（由1-（-0.1101）得到，其实就是“-0”换成1）<br>反码：1.0010（符号位不变）<br>补码：1.0011（取反加1）</p>
<p><strong><em>注意：</em></strong><br>  [+0.0000]<del>原</del>=0.0000<br>  [+0.0000]<del>反</del>=0.0000<br>  [+0.0000]<del>补</del>=0.0000</p>
<hr>
<p>  [-0.0000]<del>原</del>=1.0000<br>  [-0.0000]<del>反</del>=1.1111<br>  [-0.0000]<del>补</del>=0.0000</p>
<h1 id="顺便说一说BCD码"><a href="#顺便说一说BCD码" class="headerlink" title="顺便说一说BCD码"></a>顺便说一说BCD码</h1><p>它是用4个二进制表示一个十进制，2^4^=16，所以表示十进制时有6个剩余，只需从<br>**<em>0000-1111**</em> （16个）中选10个即可表示十进制。</p>
<p><strong><em>8421码：0000-1001<br>2421码：0000-1111、0001-1110……..它是一对一对的，这样选10个<br>余3码：0011-1100 前后各去3个，也是对称的。</em></strong></p>
<h1 id="数的定点表示与浮点表示"><a href="#数的定点表示与浮点表示" class="headerlink" title="数的定点表示与浮点表示"></a>数的定点表示与浮点表示</h1><p>定点：<br><img src="https://img-blog.csdnimg.cn/20190929110558441.png" alt="在这里插入图片描述"><br>浮点：<br><img src="https://img-blog.csdnimg.cn/2019092911074320.png" alt="在这里插入图片描述"><br>直接通过例子说明：将-54表示成二进制定点数和浮点数。设浮点数字长16位，其中阶码5位（含1位阶位），尾数11位（含1位数符）。</p>
<p><strong><em>定点机中：</em></strong><br>真值：-110110<br>原码：10000110110（符号1位负，数值10位）<br>反码：11111001001<br>补码：11111001010</p>
<p><strong><em>浮点机中：</em></strong>（类笔着科学计数法来想）<br>浮点数表示：-0000110110<br>规格化：-（0.1101100000）x 2^110^ （注意：110是二进制，即右移6位才和原来相等）<br>这样阶码、尾数就有了。<br>原码：0,0110；1.1101100000<br>反码：0,0110；1.0010011111<br>补码：0,0110；1.0010100000</p>
<p><strong><em>补充：</em></strong><br>同样以n=10；m=4，阶符和数符各取1位。<br><img src="https://img-blog.csdnimg.cn/20190929135842811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h1><p><img src="https://img-blog.csdnimg.cn/20190929140644387.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190929141029837.png" alt="在这里插入图片描述"><br>阶码的真值都被加上一个常数。短实数加7FH，长实数加3FFH。临时实数加3FFFH。<br>**<em>例：**</em><br>数值：178.125<br>二进制：10110010.001<br>浮点表示：1.0110010001 x 2^111^ （1.xxx的形式，最后表示时，省略（不写）那个1）<br>此时的阶码是：00000111，加上01111111（7FH）得10000110：<br>短实数表示为 10000110  01100100010000000000000（总的31位）</p>
<p><strong><em>注意：</em></strong> 逆推的时候得记得加上1.xxx</p>
<h1 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h1><h2 id="加法与减法运算"><a href="#加法与减法运算" class="headerlink" title="加法与减法运算"></a>加法与减法运算</h2><p>整数：[A]<del>补</del>+[B]<del>补</del>=[A+B]<del>补</del>（mod 2^n+1^）<br>小数：[A]<del>补</del>+[B]<del>补</del>=[A+B]<del>补</del>（mod 2）</p>
<p>整数：[A-B]<del>补</del>=[A]<del>补</del>+[-B]<del>补</del>（mod 2^n+1^）<br>小数：[A-B]<del>补</del>=[A]<del>补</del>+[-B]<del>补</del>（mod 2）</p>
<p><strong><em>例1：</em></strong><br>A=0.1011,B=-0.0101，求[A+B]<del>补</del><br>[A]<del>补</del>=0.1011，[B]<del>补</del>=1.1011<br>[A+B]<del>补</del>=0.0110</p>
<p><strong><em>例2：</em></strong><br>A=+15,B=+24，求[A-B]<del>补</del><br>[A]<del>补</del>=0,0001111，<br>[B]<del>补</del>=0,0011000，[-B]<del>补</del>=1,1101000 （[B]<del>补</del>连着符号位取反加1）<br>[A-B]<del>补</del>=1,1110111</p>
<p><em>由上可知：不论操作数是正还是负，在做补码加减法时，只需将符号位和数值部分一起参加运算并且将符号位产生的进为自然丢弃即可</em></p>
<h2 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h2><ul>
<li><p>不论是做加法还是减法，只要两个操作数的符号相同，而结果又与原操作数符号不同，即为溢出。<br>也就是将符号位产生的进位与最高有效位产生的进位异或操作，1则溢出，0则没有溢出。</p>
</li>
<li><p>变形补码（2位符号位）<br>  当两位符号位不同时表示溢出，否则；无溢出。“10”表示负溢出；“01”表示正溢出。</p>
<p>  <strong><em>例1：</em></strong><br>  x=+11/16 , y=+3/16<br>  [x]<del>补</del>=00.1011；[y]<del>补</del>=00.0011；<br>  [x+y]<del>补</del>=00.1110 （00相同，无溢出）<br>  x+y=0.1110</p>
<p>  <strong><em>例2：</em></strong></p>
<pre><code>  x=-11/16 , y=-7/16
  [x]~补~=11.0101；[y]~补~=11.1001；
  [x]~补~+[y]~补~=10.1110；（10不同，负溢出）</code></pre>
</li>
</ul>
<h1 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h1><h2 id="加法与减法运算-1"><a href="#加法与减法运算-1" class="headerlink" title="加法与减法运算"></a>加法与减法运算</h2><ul>
<li>对阶</li>
<li>尾数求和</li>
<li>规格化<br>  左规：尾数的第一数值为与符号位相同需左规，尾数左移一位，阶码减1.<br>  右规：符号位不相同需右规，尾数右移一位，阶码加1.</li>
<li>舍入</li>
<li>溢出</li>
</ul>
<p><strong><em>例1：</em></strong><br>x=0.1101 x 2^01^ ,y=(-0.1010) x 2^11^,求x+y。<br>[x]<del>补</del>=00,01；00.1101<br>[y]<del>补</del>=00,11；11.0110</p>
<ul>
<li><p>小阶向大阶看齐<br>  显然，要将x变为2^11^ ,每右移一位，阶码加1<br>  [x]<del>补</del>=00,11；00.0011</p>
</li>
<li><p>尾数求和<br>  00.0011+11.0110=11.1001<br>  即[x+y]<del>补</del>=00,11；11.1001</p>
</li>
<li><p>规格化<br>  左规：<br>  [x+y]<del>补</del>=00,10；11.0010</p>
<p>  故x+y=(-0.1110) x 2^10^</p>
</li>
</ul>
<p><strong><em>例2：</em></strong><br>x=0.1101 x 2^10^ ,y=0.1011 x 2^01^,求x+y。<br>[x]<del>补</del>=00,10；00.1101<br>[y]<del>补</del>=00,01；11.1011</p>
<ul>
<li><p>小阶向大阶看齐<br>  显然，要将y变为2^10^ ,每右移一位，阶码加1<br>  [y]<del>补</del>=00,10；00.0101</p>
</li>
<li><p>尾数求和<br>  00.1101+00.0101=01.0010<br>  即[x+y]<del>补</del>=00,10；01.0010</p>
</li>
<li><p>规格化<br>  右规：<br>  [x+y]<del>补</del>=00,11；00.1001</p>
<p>  故x+y=0.1001 x 2^11^</p>
</li>
</ul>
<p><a href="#top">返回顶部</a></p>
]]></content>
      <tags>
        <tag>二进制的一些运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据分析与挖掘</title>
    <url>/2019/08/18/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/</url>
    <content><![CDATA[<body>
<div id="top"></div>
</body>


<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间做了个回归模型预测分析，效果不好，只是简单地熟悉了数据挖掘的流程而已，下面记录一些数据挖掘常用到的东西。</p>
<h1 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h1><ul>
<li>找公开的</li>
<li>爬虫</li>
<li>现成软件，比如八爪鱼</li>
</ul>
<p>下面是一个爬历史天气的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Spyder Editor</span><br><span class="line"></span><br><span class="line">This is a temporary script file.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Sun May  5 11:11:43 2019</span><br><span class="line"></span><br><span class="line">@author: kdc</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import requests</span><br><span class="line">from requests.exceptions import RequestException</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import os</span><br><span class="line">import csv</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def get_one_page(url):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    获取网页</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    print(&#39;正在加载&#39;+url)</span><br><span class="line">    headers&#x3D;&#123;&#39;User-Agent&#39;:&#39;User-Agent:Mozilla&#x2F;5.0&#39;&#125;</span><br><span class="line">    try:</span><br><span class="line">        response &#x3D; requests.get(url,headers&#x3D;headers)</span><br><span class="line">        if response.status_code &#x3D;&#x3D; 200:</span><br><span class="line">            return response.content</span><br><span class="line">        return None</span><br><span class="line">    except RequestException:</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">def parse_one_page(html):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">	对网页内容进行解析</span><br><span class="line">	&#39;&#39;&#39;</span><br><span class="line">    soup &#x3D; BeautifulSoup(html,  &quot;lxml&quot;)</span><br><span class="line">    info &#x3D; soup.find(&#39;div&#39;,  class_&#x3D;&#39;wdetail&#39;)</span><br><span class="line">    rows&#x3D;[]</span><br><span class="line">    tr_list &#x3D; info.find_all(&#39;tr&#39;)[1:]       # 使用从第二个tr开始取</span><br><span class="line">    for index,  tr in enumerate(tr_list):     # enumerate可以返回元素的位置及内容</span><br><span class="line">        td_list &#x3D; tr.find_all(&#39;td&#39;)</span><br><span class="line">        date &#x3D; td_list[0].text.strip().replace(&quot;\n&quot;, &quot;&quot;)  # 取每个标签的text信息，并使用replace()函数将换行符删除</span><br><span class="line">        weather &#x3D; td_list[1].text.strip().replace(&quot;\n&quot;, &quot;&quot;).split(&quot;&#x2F;&quot;)[0].strip()</span><br><span class="line">        temperature_high &#x3D; td_list[2].text.strip().replace(&quot;\n&quot;,  &quot;&quot;).split(&quot;&#x2F;&quot;)[0].strip()</span><br><span class="line">        temperature_low &#x3D; td_list[2].text.strip().replace(&quot;\n&quot;,  &quot;&quot;).split(&quot;&#x2F;&quot;)[1].strip()</span><br><span class="line"></span><br><span class="line">        rows.append((date,weather,temperature_high,temperature_low))</span><br><span class="line">    return rows</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cities &#x3D; [&#39;tianjin&#39;,&#39;heilongjiang&#39;]</span><br><span class="line">years &#x3D; [&#39;2012&#39;,&#39;2013&#39;,&#39;2014&#39;,&#39;2015&#39;,&#39;2016&#39;,&#39;2017&#39;,&#39;2018&#39;]</span><br><span class="line">months &#x3D; [&#39;01&#39;,&#39;02&#39;,&#39;03&#39;,&#39;04&#39;,&#39;05&#39;,&#39;06&#39;,&#39;07&#39;,&#39;08&#39;,&#39;09&#39;,&#39;10&#39;,&#39;11&#39;,&#39;12&#39;]</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # os.chdir()  # 设置工作路径</span><br><span class="line">    for city in cities:</span><br><span class="line">        with open(city + &#39;_weather.csv&#39;, &#39;a&#39;, newline&#x3D;&#39;&#39;) as f:</span><br><span class="line">            writer &#x3D; csv.writer(f)</span><br><span class="line">            writer.writerow([&#39;date&#39;,&#39;weather&#39;,&#39;temperature_high&#39;,&#39;temperature_low&#39;])</span><br><span class="line">            for year in years:</span><br><span class="line">                for month in months:</span><br><span class="line">                    url &#x3D; &#39;http:&#x2F;&#x2F;www.tianqihoubao.com&#x2F;lishi&#x2F;&#39;+city+&#39;&#x2F;month&#x2F;&#39;+year+month+&#39;.html&#39;</span><br><span class="line">                    html &#x3D; get_one_page(url)</span><br><span class="line">                    content&#x3D;parse_one_page(html)</span><br><span class="line">                    writer.writerows(content)</span><br><span class="line">                    print(city+year+month+&#39; is OK!&#39;)</span><br><span class="line">                    time.sleep(2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="#top">返回顶部</a></p>
<h1 id="可视化及其数据处理"><a href="#可视化及其数据处理" class="headerlink" title="可视化及其数据处理"></a>可视化及其数据处理</h1><ul>
<li><h2 id="词云"><a href="#词云" class="headerlink" title="词云"></a>词云</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Sat May 25 10:04:26 2019</span><br><span class="line"></span><br><span class="line">@author: Administrator</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">from wordcloud import WordCloud</span><br><span class="line"></span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">from scipy.misc import imread</span><br><span class="line"></span><br><span class="line">from wordcloud.color_from_image import ImageColorGenerator</span><br><span class="line"></span><br><span class="line">#将数据打开     </span><br><span class="line">text &#x3D; open(&quot;f:\\pachong\\aa.txt&quot;,&#39;r&#39;,encoding&#x3D;&#39;gbk&#39;).read() </span><br><span class="line">#你需要处理的背景图片  </span><br><span class="line">bg_pic &#x3D; imread(&quot;f:\\pachong\\picture\\b.jpg&quot;)        </span><br><span class="line">#汉字要加这个</span><br><span class="line">font&#x3D;r&#39;C:\\Windows\\Fonts\\STFANGSO.ttf&#39;  </span><br><span class="line">#生成词云</span><br><span class="line">wordcloud &#x3D; WordCloud(mask&#x3D;bg_pic,background_color&#x3D;&#39;white&#39;,font_path&#x3D;font,scale&#x3D;1.5).generate(text) </span><br><span class="line">#生成背景图片</span><br><span class="line">image_colors&#x3D;ImageColorGenerator(bg_pic) </span><br><span class="line">#展示词云</span><br><span class="line">plt.imshow(wordcloud)  </span><br><span class="line"></span><br><span class="line">plt.axis(&#39;off&#39;)    </span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line">#在本地目录下生成该图片</span><br><span class="line">#wordcloud.to_file(&#39;f:\\house_price\\词云.pdf&#39;) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果：<br>这是网易云音乐歌曲《你的酒馆对我打了烊》的评论，有毒啊！<br><img src="https://img-blog.csdnimg.cn/20190818093129706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#top">返回顶部</a></p>
<ul>
<li><h2 id="画饼图"><a href="#画饼图" class="headerlink" title="画饼图"></a>画饼图</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Mon May  6 22:15:50 2019</span><br><span class="line"></span><br><span class="line">@author: Administrator</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">###正常显示中文</span><br><span class="line">import matplotlib.pyplot as plot</span><br><span class="line">import matplotlib</span><br><span class="line"></span><br><span class="line">matplotlib.rcParams[&#39;font.sans-serif&#39;]&#x3D;[&#39;SimHei&#39;]  #使用指定的汉字字体类型（此处为黑体）</span><br><span class="line"></span><br><span class="line">#matplotlib.rcParams[&#39;axes.unicode_minus&#39;]&#x3D;False #用来正常显示负号</span><br><span class="line"></span><br><span class="line">####主要功能片段</span><br><span class="line">city&#x3D;&#39;chengdu&#39;</span><br><span class="line">citydict&#x3D;&#123;&#39;tianjin&#39;:&#39;天津&#39;,&#39;chengdu&#39;:&#39;成都&#39;,&#39;qujing&#39;:&#39;曲靖&#39;&#125;</span><br><span class="line">try:</span><br><span class="line">    #gbk不行那就utf_8</span><br><span class="line">    data &#x3D; pd.read_csv(r&#39;f:\\pachong\\&#39;+city+&#39;_weather.csv&#39;,encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line">except IOError as e:  </span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pieData&#x3D;data[&#39;weather&#39;].value_counts()</span><br><span class="line">after&#x3D;&#123;&#125;</span><br><span class="line">labels &#x3D; [] </span><br><span class="line"></span><br><span class="line"># 取出前几个，剩余的所占比重小，所有的作为其他显示</span><br><span class="line">cnt &#x3D; 0 </span><br><span class="line">required_cnt&#x3D;7  </span><br><span class="line">sum&#x3D;0</span><br><span class="line">for key, value in pieData.items():</span><br><span class="line">     cnt +&#x3D; 1</span><br><span class="line">     if cnt &gt; required_cnt:</span><br><span class="line">        sum&#x3D;sum+value</span><br><span class="line">    #print(&quot;&#123;&#125;:&#123;&#125;&quot;.format(key, value))</span><br><span class="line">     if cnt &lt;&#x3D; required_cnt:</span><br><span class="line">        after.update(&#123;key:value&#125;)</span><br><span class="line">        labels.append(key)</span><br><span class="line"></span><br><span class="line">after.update(&#123;&#39;其它&#39;:sum&#125;)</span><br><span class="line">labels.append(&#39;其它&#39;)</span><br><span class="line"></span><br><span class="line"> #设置标题名</span><br><span class="line">plot.title(citydict[city]+&quot;天气百分比&quot;) </span><br><span class="line">#为饼状图的每个区间安排颜色&#39;lightskyblue&#39;浅蓝色</span><br><span class="line">colors &#x3D; [&#39;orange&#39;,&#39;red&#39;,&#39;pink&#39;,&#39;lightskyblue&#39;,&#39;teal&#39;,&#39;green&#39;]</span><br><span class="line">#表示八个扇区“邻居”之间的缝隙距离</span><br><span class="line">explode &#x3D; (0.03, 0.02, 0.02, 0.03,0.03, 0.02, 0.02,0.02)</span><br><span class="line"></span><br><span class="line">patches, l_text, p_text &#x3D; plot.pie(pd.Series(after), explode&#x3D;explode,labels&#x3D;labels,colors&#x3D;colors,</span><br><span class="line"></span><br><span class="line">                                   labeldistance&#x3D;1.06, autopct&#x3D;&#39;%3.0f%%&#39;, shadow&#x3D;False,</span><br><span class="line"></span><br><span class="line">                                   startangle&#x3D;90, pctdistance&#x3D;0.6)</span><br><span class="line"></span><br><span class="line"># labeldistance，文本的位置离远点有多远，1.1指1.1倍半径的位置</span><br><span class="line"></span><br><span class="line"># autopct，圆里面的文本格式，%3.1f%%表示小数有三位，整数有一位的浮点数</span><br><span class="line"></span><br><span class="line"># shadow，饼是否有阴影</span><br><span class="line"></span><br><span class="line"># startangle，起始角度，0，表示从0开始逆时针转，为第一块。一般选择从90度开始比较好看</span><br><span class="line"></span><br><span class="line"># pctdistance，百分比的text离圆心的距离</span><br><span class="line"></span><br><span class="line"># patches, l_texts, p_texts，为了得到饼图的返回值，p_texts饼图内部文本的，l_texts饼图外label的文本</span><br><span class="line"></span><br><span class="line"># 改变文本的大小</span><br><span class="line"></span><br><span class="line"># 方法是把每一个text遍历。调用set_size方法设置它的属性</span><br><span class="line"></span><br><span class="line">for t in l_text:</span><br><span class="line"></span><br><span class="line">    t.set_size &#x3D; (30)</span><br><span class="line"></span><br><span class="line">for t in p_text:</span><br><span class="line"></span><br><span class="line">    t.set_size &#x3D; (20)#去掉&#x3D;号修改字体大小</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 设置x，y轴刻度一致，这样饼图才能是圆的</span><br><span class="line"></span><br><span class="line">plot.axis(&#39;equal&#39;)</span><br><span class="line"></span><br><span class="line">plot.legend(loc&#x3D;&#39;upper left&#39;, bbox_to_anchor&#x3D;(-0.1, 1))#legend为左上角那种集合的说明</span><br><span class="line"></span><br><span class="line"># loc: 表示legend的位置，包括&#39;upper right&#39;,&#39;upper left&#39;,&#39;lower right&#39;,&#39;lower left&#39;等</span><br><span class="line"></span><br><span class="line"># bbox_to_anchor: 表示legend距离图形之间的距离，当出现图形与legend重叠时，可使用bbox_to_anchor进行调整legend的位置</span><br><span class="line"></span><br><span class="line"># 由两个参数决定，第一个参数为legend距离左边的距离，第二个参数为距离下面的距离</span><br><span class="line"></span><br><span class="line">plot.grid()</span><br><span class="line"></span><br><span class="line">#plot.savefig(&#39;f:\\&#39;+citydict[city]+&#39;.pdf&#39;)</span><br><span class="line">plot.show()</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://img-blog.csdnimg.cn/20190818090748381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#top">返回顶部</a></p>
<ul>
<li><h2 id="画走势图"><a href="#画走势图" class="headerlink" title="画走势图"></a>画走势图</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Sun May  5 20:29:47 2019</span><br><span class="line"></span><br><span class="line">@author: kimmel</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;date	weather	temperature_high(℃)	temperature_low(℃)&#39;&#39;&#39;</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">       data &#x3D; pd.read_csv(r&#39;F:&#x2F;&#x2F;pachong&#x2F;&#x2F;tianjin_weather.csv&#39;,encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line">except IOError as e:</span><br><span class="line">       print(e)</span><br><span class="line"></span><br><span class="line">x &#x3D; np.arange(0,365,1)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize&#x3D;(10,6))</span><br><span class="line"></span><br><span class="line">#正常显示负号</span><br><span class="line">plt.rcParams[&#39;axes.unicode_minus&#39;] &#x3D; False </span><br><span class="line"></span><br><span class="line">#表中有好多年的数据，用365乘以某数可以限定到某年到某年</span><br><span class="line">#plt.plot(x,data[&#39;temperature_high&#39;][365*0:365*1],label&#x3D;&#39;Temperature_high&#39;,color&#x3D;&#39;red&#39; , alpha&#x3D;0.8)</span><br><span class="line">#plt.plot(x,data[&#39;temperature_low&#39;][365*0:365*1],label&#x3D;&#39;Temperature_low&#39;, color&#x3D;&#39;blue&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.plot(x,data[&#39;temperature_high&#39;][365*6:365*7],label&#x3D;&#39;Temperature_high&#39;,color&#x3D;&#39;red&#39; , alpha&#x3D;0.8)</span><br><span class="line">plt.plot(x,data[&#39;temperature_low&#39;][365*6:365*7],label&#x3D;&#39;Temperature_low&#39;, color&#x3D;&#39;blue&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.xlabel(&quot;Time(day)&quot;)</span><br><span class="line">plt.ylabel((&quot;%s%c%s&quot;)%(&quot;Temperature(&quot;,u&quot;\u2103&quot;,&quot;)&quot;))</span><br><span class="line"></span><br><span class="line">plt.ylim(-30,45)</span><br><span class="line">y_ticks &#x3D; np.arange(-30,45,5)</span><br><span class="line">plt.yticks(y_ticks)</span><br><span class="line">plt.legend()</span><br><span class="line">#plt.savefig(r&#39;f:\\tianjin.pdf&#39;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://img-blog.csdnimg.cn/20190817114544380.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#top">返回顶部</a></p>
<ul>
<li><h2 id="根据表中不同字段画条形图"><a href="#根据表中不同字段画条形图" class="headerlink" title="根据表中不同字段画条形图"></a>根据表中不同字段画条形图</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Wed May  8 12:54:47 2019</span><br><span class="line"></span><br><span class="line">@author: Administrator</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import pandas as pd</span><br><span class="line">###正常显示中文</span><br><span class="line">import matplotlib</span><br><span class="line"></span><br><span class="line">city&#x3D;&#39;tj&#39;</span><br><span class="line">citydict&#x3D;&#123;&#39;city&#39;:&#39;全国部分城市平均&#39;,&#39;tj&#39;:&#39;天津&#39;,&#39;bj&#39;:&#39;北京&#39;,&#39;cd&#39;:&#39;成都&#39;,&#39;gz&#39;:&#39;广州&#39;,&#39;sh&#39;:&#39;上海&#39;,&#39;sz&#39;:&#39;深圳&#39;,&#39;wh&#39;:&#39;武汉&#39;,&#39;hz&#39;:&#39;杭州&#39;,&#39;gy&#39;:&#39;贵阳&#39;,&#39;cs&#39;:&#39;长沙&#39;,&#39;cq&#39;:&#39;重庆&#39;,&#39;qj&#39;:&#39;曲靖&#39;,&#39;km&#39;:&#39;昆明&#39;&#125;</span><br><span class="line">matplotlib.rcParams[&#39;font.sans-serif&#39;]&#x3D;[&#39;SimHei&#39;]  #使用指定的汉字字体类型（此处为黑体）</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.read_csv(r&#39;C:\Users\Administrator\Desktop\lianjia-beike-spider-master\data\ke\xiaoqu\all\all_city&#39;+&#39;.csv&#39;,encoding&#x3D;&#39;gbk&#39;)  </span><br><span class="line"> </span><br><span class="line">var &#x3D; df.groupby(&#39;城市&#39;)[&#39;挂牌均价&#39;].mean()</span><br><span class="line"></span><br><span class="line">fig &#x3D; plt.figure()</span><br><span class="line"></span><br><span class="line">ax1 &#x3D; fig.add_subplot(111)</span><br><span class="line">ax1.set_xlabel(&#39;地区&#39;)</span><br><span class="line">ax1.set_ylabel(&#39;房价&#39;)</span><br><span class="line">ax1.set_title(citydict[city]+&#39;各区平均房价&#39;)</span><br><span class="line"></span><br><span class="line">var.plot(kind&#x3D;&#39;bar&#39;)</span><br><span class="line"></span><br><span class="line">plt.savefig(&#39;f:\\&#39;+citydict[city]+&#39;房价.pdf&#39;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://img-blog.csdnimg.cn/20190817133922581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#top">返回顶部</a></p>
<ul>
<li><h2 id="画地图"><a href="#画地图" class="headerlink" title="画地图"></a>画地图</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Wed May  8 12:54:47 2019</span><br><span class="line"></span><br><span class="line">@author: Administrator</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import pandas as pd</span><br><span class="line">from pyecharts import Map,Geo</span><br><span class="line">###正常显示中文</span><br><span class="line">import matplotlib</span><br><span class="line"></span><br><span class="line">city&#x3D;&#39;tj&#39;</span><br><span class="line">citydict&#x3D;&#123;&#39;city&#39;:&#39;全国部分城市平均&#39;,&#39;tj&#39;:&#39;天津&#39;,&#39;bj&#39;:&#39;北京&#39;,&#39;cd&#39;:&#39;成都&#39;,&#39;gz&#39;:&#39;广州&#39;,&#39;sh&#39;:&#39;上海&#39;,&#39;sz&#39;:&#39;深圳&#39;,&#39;wh&#39;:&#39;武汉&#39;,&#39;hz&#39;:&#39;杭州&#39;,&#39;gy&#39;:&#39;贵阳&#39;,&#39;cs&#39;:&#39;长沙&#39;,&#39;cq&#39;:&#39;重庆&#39;,&#39;qj&#39;:&#39;曲靖&#39;,&#39;km&#39;:&#39;昆明&#39;&#125;</span><br><span class="line">matplotlib.rcParams[&#39;font.sans-serif&#39;]&#x3D;[&#39;SimHei&#39;]  #使用指定的汉字字体类型（此处为黑体）</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.read_csv(r&#39;C:\Users\Administrator\Desktop\lianjia-beike-spider-master\data\ke\xiaoqu\all\all_city&#39;+&#39;.csv&#39;,encoding&#x3D;&#39;gbk&#39;)  </span><br><span class="line"> </span><br><span class="line">var &#x3D; df.groupby(&#39;城市&#39;)[&#39;挂牌均价&#39;].mean()</span><br><span class="line"></span><br><span class="line">data&#x3D;list(var.items())</span><br><span class="line">attr, value &#x3D; Geo.cast(data)</span><br><span class="line"></span><br><span class="line">Geo &#x3D; Geo(&quot;全国部分城市房价热力图&quot;, &quot;数据来源房价信息表&quot;, title_color&#x3D;&quot;#fff&quot;, title_pos&#x3D;&quot;center&quot;, width&#x3D;1200, height&#x3D;600, background_color&#x3D;&#39;#404a59&#39;)</span><br><span class="line"></span><br><span class="line">Geo.add(&quot;房价热力图&quot;, attr, value, visual_range&#x3D;[0, 20000], type&#x3D;&#39;heatmap&#39;,visual_text_color&#x3D;&quot;#fff&quot;, symbol_size&#x3D;15, is_visualmap&#x3D;True, is_roam&#x3D;False)</span><br><span class="line"></span><br><span class="line">Geo.show_config()</span><br><span class="line"></span><br><span class="line">Geo.render(path&#x3D;&quot;f:\\a1.html&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#世界地图：</span><br><span class="line">map0 &#x3D; Map(&quot;世界地图示例&quot;, width&#x3D;1200, height&#x3D;600)</span><br><span class="line">map0.add(&quot;世界地图&quot;, attr, value, maptype&#x3D;&quot;world&quot;,  is_visualmap&#x3D;True, visual_text_color&#x3D;&#39;#000&#39;)</span><br><span class="line">map0.render(path&#x3D;&quot;f:\\a2.html&quot;)</span><br><span class="line"></span><br><span class="line">#中国地图</span><br><span class="line"># maptype&#x3D;&#39;china&#39; 只显示全国直辖市和省级</span><br><span class="line"># 数据只能是省名和直辖市的名称</span><br><span class="line">map1 &#x3D; Map(&quot;中国地图&quot;,&#39;中国地图&#39;, width&#x3D;1200, height&#x3D;600)</span><br><span class="line">map1.add(&quot;&quot;, attr, value, visual_range&#x3D;[0, 50],  maptype&#x3D;&#39;china&#39;, is_visualmap&#x3D;True,    visual_text_color&#x3D;&#39;#000&#39;)</span><br><span class="line">map1.show_config()</span><br><span class="line">map1.render(path&#x3D;&quot;f:\\a3.html&quot;)</span><br><span class="line"></span><br><span class="line">#省份地图</span><br><span class="line">province&#x3D; &#123;&#39;云南&#39;: 6&#125;</span><br><span class="line">provice&#x3D;list(province.keys())</span><br><span class="line">values&#x3D;list(province.values()) </span><br><span class="line">map2 &#x3D; Map(&quot;云南地图&quot;,&#39;云南&#39;, width&#x3D;1200, height&#x3D;600)</span><br><span class="line">map2.add(&#39;云南&#39;, provice, values, visual_range&#x3D;[1, 10], maptype&#x3D;&#39;云南&#39;, is_visualmap&#x3D;True, visual_text_color&#x3D;&#39;#000&#39;)</span><br><span class="line">map2.show_config()</span><br><span class="line">map2.render(path&#x3D;&quot;f:\\a4.html&quot;)</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">#区县地图</span><br><span class="line">quxian &#x3D; []</span><br><span class="line">values3 &#x3D; []</span><br><span class="line">map3 &#x3D; Map(&quot;aa&quot;,&#39;aa&#39;, width&#x3D;1200, height&#x3D;600)</span><br><span class="line">map3.add(&quot;xx&quot;, quxian, values3, visual_range&#x3D;[1, 10], maptype&#x3D;&#39;xx&#39;, is_visualmap&#x3D;True,    visual_text_color&#x3D;&#39;#000&#39;)</span><br><span class="line">map3.render(path&#x3D;&quot;f:\\a5.html&quot;)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://img-blog.csdnimg.cn/2019081713465038.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#top">返回顶部</a></p>
<ul>
<li><h2 id="合并多个csv文件"><a href="#合并多个csv文件" class="headerlink" title="合并多个csv文件"></a>合并多个csv文件</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import os</span><br><span class="line">Folder_Path &#x3D; r&#39;C:\Users\Administrator\Desktop\\all&#39;          #要拼接的文件夹及其完整路径，注意不要包含中文</span><br><span class="line">SaveFile_Path &#x3D;  r&#39;f:\\xx&#39;       #拼接后要保存的文件路径</span><br><span class="line">SaveFile_Name &#x3D; r&#39;all.csv&#39;              #合并后要保存的文件名</span><br><span class="line"> </span><br><span class="line">#修改当前工作目录</span><br><span class="line">os.chdir(Folder_Path)</span><br><span class="line">#将该文件夹下的所有文件名存入一个列表</span><br><span class="line">file_list &#x3D; os.listdir()</span><br><span class="line"> </span><br><span class="line">#读取第一个CSV文件并包含表头</span><br><span class="line">df &#x3D; pd.read_csv(Folder_Path +&#39;\\&#39;+ file_list[0],encoding&#x3D;&quot;gbk&quot;)   #或UTF-8</span><br><span class="line"> </span><br><span class="line">#将读取的第一个CSV文件写入合并后的文件保存</span><br><span class="line">df.to_csv(SaveFile_Path+&#39;\\&#39;+ SaveFile_Name,encoding&#x3D;&quot;gbk&quot;,index&#x3D;False)</span><br><span class="line"> </span><br><span class="line">#循环遍历列表中各个CSV文件名，并追加到合并后的文件</span><br><span class="line">for i in range(1,len(file_list)):</span><br><span class="line">    try:</span><br><span class="line">        df &#x3D; pd.read_csv(Folder_Path + &#39;\\&#39;+ file_list[i],encoding&#x3D;&quot;gbk&quot;)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line">    df.to_csv(SaveFile_Path+&#39;\\&#39;+ SaveFile_Name,encoding&#x3D;&quot;gbk&quot;,index&#x3D;False, header&#x3D;False, mode&#x3D;&#39;a+&#39;)</span><br></pre></td></tr></table></figure>
<p><a href="#top">返回顶部</a></p>
<h1 id="最后利用各种挖掘算法分析解释"><a href="#最后利用各种挖掘算法分析解释" class="headerlink" title="最后利用各种挖掘算法分析解释"></a>最后利用各种挖掘算法分析解释</h1><p><img src="https://img-blog.csdnimg.cn/20190818094715336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="感触"><a href="#感触" class="headerlink" title="感触"></a>感触</h1><p>对于新手而言，前期数据处理还是挺好玩的，刨除数据挖掘不说，自己搞点小东西玩玩也是好玩的。到真正的挖掘分析部分就有点吃不消了，书上那些人家总结好的算法，说实话，不能很好理解，只能是按照人家分析步骤自己也照着做，最终得出个什么结果。</p>
<p><a href="#top">返回顶部</a></p>
]]></content>
      <tags>
        <tag>Python数据分析与挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>各种排序算法总结</title>
    <url>/2019/08/16/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<body>
<div id="top"></div>
</body>


<h1 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h1><p><img src="https://img-blog.csdnimg.cn/20190813093822560.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190813094628596.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190813095002725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong><em>快速记忆不稳定排序有哪些：快（快速排序）些（希尔排序）选（选择排序）一堆（堆排序）美女</em></strong></p>
<p><a href="#top">返回顶部</a></p>
<h1 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h1><p><strong><em>思想：</em></strong> 两两比较相邻关键字，及时交换。<br>*<strong>过程：*** 每一趟沉淀一个最大的数。整个过程就像水泡的浮起过程，故因此而得名。<br>*</strong>实现代码：***</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void BubbleSort1(int a[],int n)&#123;&#x2F;&#x2F;冒泡排序 </span><br><span class="line">	for(int i&#x3D;0;i&lt;n-1;i++)&#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;n-1-i;j++)&#123;</span><br><span class="line">			if(a[j]&gt;a[j+1])&#123;</span><br><span class="line">				swap(a[j],a[j+1]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>运行结果：</em></strong><br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190813103433712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190813103433712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =500x)<br>上述代码有一点问题，就是如果某一趟没有发生任何关键字的交换（说明关键字已经有序了），这时就不在需要再继续去比较了。</p>
<p><strong><em>改进后的冒泡排序：</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void BubbleSort2(int a[],int n)&#123;&#x2F;&#x2F;改进的冒泡排序 </span><br><span class="line">	int bound,exchange&#x3D;n-1;</span><br><span class="line">	while(exchange!&#x3D;0)&#123;</span><br><span class="line">		bound&#x3D;exchange;</span><br><span class="line">		exchange&#x3D;0;</span><br><span class="line">		for(int j&#x3D;0;j&lt;bound;j++)&#123;			</span><br><span class="line">			if(a[j]&gt;a[j+1])&#123;</span><br><span class="line">				swap(a[j],a[j+1]);</span><br><span class="line">				exchange&#x3D;j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><strong><em>运行结果：</em></strong><br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190813104148847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190813104148847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =500x)<br><strong><em>算法分析：</em></strong><br>最好情况（正序）：<br>只需一趟排序，比较n-1次且不移动记录。</p>
<p>最坏情况（逆序）：<br>需n-1趟排序。每一趟比较n-1,n-2,…1次,等差数列，每次交换移动3次记录。<br>总的比较次数 <strong><em>KCN=n(n-1)/ 2</em></strong><br>总的移动次数 <strong><em>RMN=3n(n-1)/ 2</em></strong></p>
<p>平均情况下：<br>比较次数： <strong><em>(n-1)(n+2)/4</em></strong> ,约为 <strong><em>n^2^/4</em></strong><br>移动次数：   <strong><em>3n(n-1)/4</em></strong>,约为 <strong><em>3n^2^/4</em></strong></p>
<p><strong><em>时间复杂度：O(n^2^)</em></strong><br><strong><em>空间复杂度： O(1)</em></strong> </p>
<p><strong><em>算法特点：</em></strong></p>
<ul>
<li>是稳定排序</li>
<li>可用于链式存储结构</li>
<li>当初始记录无序，n比较大时，此算法不宜采用。</li>
</ul>
<p><a href="#top">返回顶部</a></p>
<h1 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h1><p><strong><em>思想：</em></strong> 选取一个关键字作为分界点，右边的值都比它大，左边值都比它小。左右的                        数据可以独立的排序。这是一个递归定义。<br>*<strong>过程：*** 每一趟将数据分为两部分，左小右大，直至low==high。<br>*</strong>实现代码：***</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Partition(int a[],int low,int high)&#123;	</span><br><span class="line">	int pivokey&#x3D;a[low];</span><br><span class="line">	while(low &lt; high) &#123;</span><br><span class="line">		while(a[high]&gt;&#x3D;pivokey&amp;&amp;low &lt; high)  high--;	&#x2F;&#x2F;直到找到一个小的 </span><br><span class="line">		a[low]&#x3D;a[high];			&#x2F;&#x2F;正是因为选取第一个元素为基准，才能这样，要不然值都被覆盖了 </span><br><span class="line">		while(a[low]&lt;&#x3D;pivokey&amp;&amp;low &lt; high)  low++;		&#x2F;&#x2F;直到找到一个大的 </span><br><span class="line">		a[high]&#x3D;a[low]; 	</span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	a[low]&#x3D;pivokey;</span><br><span class="line">	return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void QuickSort(int r[],int low,int high)&#123;</span><br><span class="line">	int pivot;</span><br><span class="line">	if(low&lt;high)&#123;</span><br><span class="line">		pivot&#x3D;Partition(r,low,high);</span><br><span class="line">		QuickSort(r,low,pivot-1);</span><br><span class="line">		QuickSort(r,pivot+1,high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>运行结果：</em></strong><br><img src="https://img-blog.csdnimg.cn/20190813194652618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上述代码有一点问题，就是选取第一个或者最后一个元素作为基准，这样在数组已经有序的情况下，每次划分将得到最坏的结果。<br>一种比较常见的优化方法是随机化算法，即随机选取一个元素作为基准。这种情况下最坏情况不再依赖于输入数据，而是由随机函数决定。实际上，随机化快速排序得到理论最坏情况的可能性仅为    <strong><em>1/(2n)。</em></strong></p>
<p><strong><em>改进后的快速排序：</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void QuickSort(int array[],int low,int high)&#123;</span><br><span class="line">	srand(unsigned(time(0)));</span><br><span class="line">    int sc&#x3D;rand()%(high-low)+1+low;</span><br><span class="line">    cout&lt;&lt;&quot;随机数&quot;&lt;&lt;sc&lt;&lt;endl;</span><br><span class="line">    swap(array[sc],array[low]);</span><br><span class="line">    show(array,11);</span><br><span class="line">    int par&#x3D;Partition(array,low,high);</span><br><span class="line">    if (par&gt;low+1)&#123;</span><br><span class="line">        QuickSort(array,low,par-1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (par&lt;high-1)&#123;</span><br><span class="line">        QuickSort(array,par+1,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>运行结果：</em></strong><br><img src="https://img-blog.csdnimg.cn/20190813195938346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong><em>算法分析：</em></strong><br>最好情况：<br>每一次分割都是长度大致相等的子表</p>
<p>最坏情况（有序）：<br>每一次分割只能得到比上一次记录少一个的子序列。</p>
<p><strong><em>平均时间复杂度：O(nlog<del>2</del>n)</em></strong><br><strong><em>空间复杂度： 最好O(log<del>2</del>n)、最差O(n)</em></strong> </p>
<p><strong><em>算法特点：</em></strong></p>
<ul>
<li>是不稳定排序</li>
<li>很难于链式存储结构</li>
<li>当初始记录无序，n比较大时，此算法宜采用。</li>
</ul>
<p><a href="#top">返回顶部</a></p>
<h1 id="直接插入排序（Straight-Insertion-Sort）"><a href="#直接插入排序（Straight-Insertion-Sort）" class="headerlink" title="直接插入排序（Straight Insertion Sort）"></a>直接插入排序（Straight Insertion Sort）</h1><p><strong><em>思想：</em></strong> 与怕扑克牌一样，拿起一张牌，插入合适位置。<br>*<strong>过程：*** 每一趟将一个待排序记录插入到适当位置。<br>*</strong>实现代码：***</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void InsertSort(int r[],int n)&#123;&#x2F;&#x2F;第0位置设置观察哨，第1位置为有序区，从第二个开始扫描插入 </span><br><span class="line">	int i,j;</span><br><span class="line">	for(i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		r[0]&#x3D;r[i];</span><br><span class="line">		for(j&#x3D;i-1;r[0]&lt;r[j];j--)&#123;&#x2F;&#x2F;带插入的数依次和有序区比，寻找插入位置 </span><br><span class="line">			r[j+1]&#x3D;r[j];</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		r[j+1]&#x3D;r[0];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>运行结果：</em></strong><br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190814094506479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190814094506479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =500x)<br>红线左边的是作为观察哨用的，也就是数组中第0位置被设为观察哨。</p>
<p><strong><em>算法分析：</em></strong><br>最好情况（正序）：<br>每一趟排序，比较1次且不移动。</p>
<p>最坏情况（逆序）：<br>每一趟排序。比较i次，移动i+1次。</p>
<p>整个过程（需执行n-1趟）：<br>最好情况，比较n-1次且不移动记录。<br>最坏情况，每一趟比较2,3,…,n,等差数列。移动3,4,…n+1次，等差数列。<br>总的比较次数 <strong><em>KCN=(n-1)(n+2)/ 2</em></strong><br>总的移动次数 <strong><em>RMN=(n+4)(n-1)/ 2</em></strong></p>
<p>平均情况下：<br>比较次数： <strong><em>(n-1)(n+4)/4</em></strong> ,约为 <strong><em>n^2^/4</em></strong><br>移动次数：   <strong><em>(n+4)(n-1)/4</em></strong>,约为 <strong><em>n^2^/4</em></strong><br><strong><em>时间复杂度：O(n^2^)</em></strong><br><strong><em>空间复杂度： O(1)</em></strong> </p>
<p><strong><em>算法特点：</em></strong></p>
<ul>
<li>是稳定排序</li>
<li>可用于链式存储结构</li>
<li>当初始记录无序，n比较大时，此算法不宜采用。</li>
</ul>
<p><a href="#top">返回顶部</a></p>
<h1 id="折半插入排序（Binary-Insertion-Sort）"><a href="#折半插入排序（Binary-Insertion-Sort）" class="headerlink" title="折半插入排序（Binary Insertion Sort）"></a>折半插入排序（Binary Insertion Sort）</h1><p>与直接插入排序区别不大，直接插入排序是以顺序查找方式找插入位置，这里只是将其换为折半查找方式来找插入位置。</p>
<p><strong><em>实现代码：</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void BInsertSort(int Array[],int n)		&#x2F;&#x2F; 折半插入排序升序排列</span><br><span class="line">&#123;</span><br><span class="line">	int i,j,m;      &#x2F;&#x2F;m充当比较区间的中点</span><br><span class="line">	int low,high;     </span><br><span class="line">	for (i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Array[0] &#x3D; Array[i];</span><br><span class="line">		low &#x3D; 1; high &#x3D; i-1;   </span><br><span class="line">	</span><br><span class="line">		while (low &lt;&#x3D; high)&#123;</span><br><span class="line">			m &#x3D; (low + high)&#x2F;2;</span><br><span class="line">			if (Array[0] &gt; Array[m])  low &#x3D; m+1;</span><br><span class="line">			else  high &#x3D; m-1;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;*确定好位置后，将位置之后的数据后移，插入待排序数据*&#x2F;</span><br><span class="line">		for (j &#x3D; i-1;j &gt; high; j--)&#123;</span><br><span class="line">			Array[j+1] &#x3D; Array[j];</span><br><span class="line">		&#125;</span><br><span class="line">		Array[j+1] &#x3D; Array[0];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>运行结果与直接插入排序一样</em></strong></p>
<p><strong><em>算法分析：</em></strong><br>平均情况下，折半查找比顺序查找快，但移动次数不变。</p>
<p><strong><em>时间复杂度：O(n^2^)</em></strong><br><strong><em>空间复杂度： O(1)</em></strong> </p>
<p><strong><em>算法特点：</em></strong></p>
<ul>
<li>是稳定排序</li>
<li>不可用于链式存储结构</li>
<li>适合初始记录无序，n比较大时。</li>
</ul>
<p><a href="#top">返回顶部</a></p>
<h1 id="希尔排序（Shell’s-Sort）"><a href="#希尔排序（Shell’s-Sort）" class="headerlink" title="希尔排序（Shell’s Sort）"></a>希尔排序（Shell’s Sort）</h1><p><strong><em>思想：</em></strong> 通过 <strong><em>增量</em></strong> 将整个待排序列分割成几组，对每组分别进行直接插入排序。然后改变增量，重新分组，增加每组的数据量。直到所取增量为1，所有记录在同一组中进行直接插入排序。<br>*<strong>过程：*** 每一趟分组排序，使得整个待排序列趋于 *</strong>“基本有序”。*** 最后在一个组中直接插入排序的时候效率高。</p>
<p><strong><em>实现代码：</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ShellInsertSort(int a[], int n)			&#x2F;&#x2F;希尔排序 </span><br><span class="line">&#123; </span><br><span class="line">    int d, i, j; &#x2F;&#x2F;d为增量</span><br><span class="line">    for(d &#x3D; n&#x2F;2;d &gt;&#x3D; 1;d &#x3D; d&#x2F;2)&#123; &#x2F;&#x2F;增量递减到1使完成排序  </span><br><span class="line">        </span><br><span class="line">		for(i &#x3D; d; i &lt; n;i++)&#123;   &#x2F;&#x2F;插入排序的一轮       </span><br><span class="line">            a[0] &#x3D; a[i];</span><br><span class="line">            for(j &#x3D; i - d;(j &gt;&#x3D; 0) &amp;&amp; (a[j] &gt; a[0]);j &#x3D; j-d)&#123;</span><br><span class="line">                a[j + d] &#x3D; a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        	a[j + d] &#x3D; a[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>运行结果：</em></strong><br><img src="https://img-blog.csdnimg.cn/20190814130523550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong><em>算法分析：</em></strong><br>增量大于1时，关键字是跳跃移动的，最后一趟只需做少量比较和移动即可完成排序。</p>
<p><strong><em>时间复杂度：O(n^1.3^)</em></strong><br><strong><em>空间复杂度： O(1)</em></strong> </p>
<p><strong><em>算法特点：</em></strong></p>
<ul>
<li>是不稳定排序</li>
<li>不可用于链式存储结构</li>
<li>适合初始记录无序，n比较大时。</li>
</ul>
<p><a href="#top">返回顶部</a></p>
<h1 id="简单选择排序（Simple-Selection-Sort）"><a href="#简单选择排序（Simple-Selection-Sort）" class="headerlink" title="简单选择排序（Simple Selection Sort）"></a>简单选择排序（Simple Selection Sort）</h1><p><strong><em>也叫直接选择排序</em></strong></p>
<p><strong><em>思想：</em></strong> 每一趟选择待排记录中关键字最小的记录。<br>*<strong>过程：*** 经过n-1趟，排序完成。<br>*</strong>实现代码：***</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SelectionSort(int a[], int n) &#123;	&#x2F;&#x2F;直接选择排序 </span><br><span class="line">    int i,j,pos;</span><br><span class="line">	for(i&#x3D;0;i&lt;n-1;i++)&#123;</span><br><span class="line">        for (pos&#x3D;i, j&#x3D;i+1; j&lt;n; j++)</span><br><span class="line">            if (a[pos]&gt;a[j])</span><br><span class="line">                pos&#x3D;j;</span><br><span class="line">        if (pos !&#x3D; i) &#123;</span><br><span class="line">            swap(a[i],a[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>运行结果：</em></strong><br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190815104444647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190815104444647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =500x)<br><strong><em>算法分析：</em></strong><br>最好情况（正序）：不移动记录。<br>最坏情况（逆序）：移动3(n-1)次记录。</p>
<p>无论如何，比较次数均为： <strong><em>KCN=n(n-1)/ 2</em></strong></p>
<p><strong><em>时间复杂度：O(n^2^)</em></strong><br><strong><em>空间复杂度： O(1)</em></strong> </p>
<p><strong><em>算法特点：</em></strong></p>
<ul>
<li>是不稳定排序</li>
<li>可用于链式存储结构</li>
<li>适用于每一记录占用空间较多，移动次数较少。</li>
</ul>
<p><a href="#top">返回顶部</a></p>
<h1 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h1><hr>
<p><strong><em>什么是堆：</em></strong><br>n个元素的序列{k<del>1</del>，k<del>2</del>，…，k<del>n</del>}，满足：<br>*<strong>k<del>i</del>&gt;=k<del>2i</del> 且 k<del>i</del>&gt;=k<del>2i+1</del>***<br> 或 *</strong>k<del>i</del>&lt;=k<del>2i</del> 且 k<del>i</del>&lt;=k<del>2i+1</del>***<br> 称之为 <strong><em>堆</em></strong></p>
<hr>
<p>将待排数组记录看成是一棵完全二叉树的顺序存储结构，则堆实质上是满足如下性质的完全二叉树：</p>
<p><strong><em>树中所有非终端结点的值均不大于（或不小于）其左右孩子结点的值</em></strong></p>
<p>对应大根堆与小根堆。</p>
<hr>
<p><strong><em>思想：</em></strong> 利用大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，每次都选择堆的堆顶。<br>**<em>过程：**</em> 每拿走一个堆顶（把堆顶记录与最后一个记录交换），重新调整为堆，继续拿。</p>
<p><strong><em>实现代码：</em></strong><br><strong><em>调整堆：</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void heapAdjust(int a[], int i, int nLength) 	&#x2F;&#x2F;调整堆</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;*2*i+1与2*i+2为i的孩子，是因为数组从0位置开始存。</span><br><span class="line">	如果0位置不用，那就是2*i与2*i+1为i的孩子*&#x2F; </span><br><span class="line">    int child;		 </span><br><span class="line">    for (; 2 * i + 1 &lt; nLength; i &#x3D; child)</span><br><span class="line">    &#123; </span><br><span class="line">        child &#x3D; 2 * i + 1;</span><br><span class="line">        </span><br><span class="line">        if ( child &lt; nLength-1 &amp;&amp; a[child + 1] &gt; a[child])	&#x2F;&#x2F; 得到子结点中较大的结点</span><br><span class="line">            ++child;</span><br><span class="line">        </span><br><span class="line">        if (a[i] &lt; a[child])&#123;		&#x2F;&#x2F; 如果较大的子结点大于父结点,交换 </span><br><span class="line">        	swap(a[i],a[child]);</span><br><span class="line">        &#125;</span><br><span class="line">        else  break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>建初堆：</em></strong><br>在完全二叉树中，所有序号大于⌊n/2⌋ 的结点都是叶子，以这些结点为根的子树已是堆，不用调整。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void CreatHeap(int a[],int n)&#123;				&#x2F;&#x2F;建初堆</span><br><span class="line">	for (int i &#x3D; n &#x2F; 2 - 1; i &gt;&#x3D; 0; --i)	&#x2F;&#x2F;length&#x2F;2-1是第一个非叶节点</span><br><span class="line">        heapAdjust(a, i, n);</span><br><span class="line">        show(a,11); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>堆排序：</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void HeapSort(int a[],int length)	&#x2F;&#x2F; 堆排序</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;&quot;初始大根堆如下：&quot;&lt;&lt;endl;</span><br><span class="line">    CreatHeap(a,length);			&#x2F;&#x2F;把无序序列变成大根堆</span><br><span class="line">	 </span><br><span class="line">    &#x2F;&#x2F; 从最后一个元素开始对序列进行调整</span><br><span class="line">    for (int i &#x3D; length - 1; i &gt; 0; --i)</span><br><span class="line">    &#123;    </span><br><span class="line">      	swap(a[i],a[0]);			&#x2F;&#x2F; 把第一个元素和当前的最后一个元素交换，       </span><br><span class="line">        heapAdjust(a, 0, i);		&#x2F;&#x2F;不断的缩小调整的范围直到第一个元素     </span><br><span class="line">		cout&lt;&lt;&quot;后续调整堆如下：&quot;&lt;&lt;endl;</span><br><span class="line">		show(a,11); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>运行结果：</em></strong><br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190815141747483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190815141747483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =500x)<br><strong><em>算法分析：</em></strong></p>
<p><strong><em>时间复杂度：O(nlog<del>2</del>n)</em></strong><br><strong><em>空间复杂度： O(1)</em></strong> </p>
<p><strong><em>算法特点：</em></strong></p>
<ul>
<li>是不稳定排序</li>
<li>不可用于链式存储结构</li>
<li>数据较多时较为高效。</li>
</ul>
<p><a href="#top">返回顶部</a></p>
<h1 id="归并排序（Merging-Sort）"><a href="#归并排序（Merging-Sort）" class="headerlink" title="归并排序（Merging Sort）"></a>归并排序（Merging Sort）</h1><p><strong><em>思想：</em></strong> 将两个或两个以上的有序表合并成一个有序表。<br>**<em>过程：**</em> 初始序列可看成是n个有序的子序列，每个字序列长度为1，然后两两归并，重复，直到得到长度为n的有序序列为止。</p>
<p><strong><em>实现代码：</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Merge(int r[],int r1[],int s,int m,int t)&#123;&#x2F;&#x2F;归并 </span><br><span class="line">	int i&#x3D;s,j&#x3D;m+1,k&#x3D;s;</span><br><span class="line">	while(i&lt;&#x3D;m&amp;&amp;j&lt;&#x3D;t)&#123;</span><br><span class="line">		if(r[i]&lt;r[j]) r1[k++]&#x3D;r[i++];</span><br><span class="line">		else r1[k++]&#x3D;r[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	while(i&lt;&#x3D;m)&#123;</span><br><span class="line">		r1[k++]&#x3D;r[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	while(j&lt;&#x3D;t)&#123;</span><br><span class="line">		r1[k++]&#x3D;r[j++];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MergeSort(int r[],int s,int t)&#123;</span><br><span class="line">	int m,r1[t];</span><br><span class="line">	if(s&#x3D;&#x3D;t) return;</span><br><span class="line">	else&#123;</span><br><span class="line">		m&#x3D;(s+t)&#x2F;2;						&#x2F;&#x2F;分割序列</span><br><span class="line">		MergeSort(r,s,m);				&#x2F;&#x2F;递归</span><br><span class="line">		MergeSort(r,m+1,t);</span><br><span class="line">		Merge(r,r1,s,m,t);				&#x2F;&#x2F;归并</span><br><span class="line">		for(int i&#x3D;s;i&lt;&#x3D;t;i++)&#123;			&#x2F;&#x2F;将排好序的部分写回原数组</span><br><span class="line">			r[i]&#x3D;r1[i];</span><br><span class="line">		&#125;			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>运行结果：</em></strong><br><img src="https://img-blog.csdnimg.cn/20190816085507465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong><em>算法分析：</em></strong></p>
<p><strong><em>时间复杂度：O(nlog<del>2</del>n)</em></strong><br><strong><em>空间复杂度： O(n)</em></strong> </p>
<p><strong><em>算法特点：</em></strong></p>
<ul>
<li>是稳定排序</li>
<li>可用于链式存储结构</li>
</ul>
<p><a href="#top">返回顶部</a></p>
<h1 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h1><p>它是和前面所述各类排序方法完全不同的一种排序方法。前面的各类排序方法都是建立在关键字比较的基础上的，而基数排序不比较关键字的大小，是一种借助于多关键字排序的思想对单关键字排序的方法。</p>
<p><strong><em>怎么理解呢？</em></strong><br>以扑克牌为例，扑克牌由面值和花色构成（多关键字），要对这副牌进行排序有两种策略（**<em>以花色大于面值，且红桃&gt;黑桃&gt;梅话&gt;方块来说明**</em>）：</p>
<ol>
<li><p>最高位优先法（MSD（Most significant digital））<br> 先将牌按花色分为四堆，然后每一堆按面值进行排序。<br> ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190816101333149.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190816101333149.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =500x)<br> ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190816101346922.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190816101346922.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =500x)<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190816101808363.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190816101808363.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =500x)<br>这样，这副牌就按从小到大顺序排好了。</p>
</li>
<li><p>最低位优先法（LSD（Least significant digital））<br> 这是一种“分配”与“收集”交替进行的方法。<br> 先将牌按面值分成13堆（完整的牌），从小到大收集起来，再把花色一样的放在一起即可。<br> ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190816102832412.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190816102832412.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =500x)<br> ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190816102847107.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190816102847107.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =500x)<br> ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190816102857384.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190816102857384.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =500x)<br>这样，这副牌就按从小到大顺序排好了。</p>
</li>
</ol>
<p><strong><em>基数排序思想：</em></strong> 一个关键字可以看成是“多个关键字”组成，个位、十位、百位等，从而借助于多关键字排序对单关键字排序。<br>*<strong>过程：*** 从低位到高位，将值相同的收集起来放在一个队里。再分配，再收集，最终完成排序<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190816104257593.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190816104257593.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =500x)<br>*</strong>实现代码：***</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getNumInPos(int num,int pos) &#x2F;&#x2F;获得某个数字的第pos位的值</span><br><span class="line">&#123;</span><br><span class="line">    int temp &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; pos - 1; i++)</span><br><span class="line">        temp *&#x3D; 10;</span><br><span class="line"> </span><br><span class="line">    return (num &#x2F; temp) % 10;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#define RADIX 10    &#x2F;&#x2F;可能是0-9，需要10个桶 </span><br><span class="line">#define KEYNUM 5     &#x2F;&#x2F;整数位数</span><br><span class="line">void RadixSort(int a[], int n)		&#x2F;&#x2F;基数排序 </span><br><span class="line">&#123;</span><br><span class="line">    int *radixArrays[RADIX];    &#x2F;&#x2F;分别为0~9的序列空间</span><br><span class="line">    for (int i &#x3D; 0; i &lt; RADIX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        radixArrays[i] &#x3D; new int[n];</span><br><span class="line">        radixArrays[i][0] &#x3D; 0;    </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (int pos &#x3D; 1; pos &lt;&#x3D; KEYNUM; pos++)    &#x2F;&#x2F;从个位开始</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++)    &#x2F;&#x2F;分配过程</span><br><span class="line">        &#123;</span><br><span class="line">            int num &#x3D; getNumInPos(a[i], pos);</span><br><span class="line">            int index &#x3D; ++radixArrays[num][0];</span><br><span class="line">            radixArrays[num][index] &#x3D; a[i];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        for (int i &#x3D; 0, j &#x3D;0; i &lt; RADIX; i++) &#x2F;&#x2F;写回到原数组中</span><br><span class="line">        &#123;</span><br><span class="line">            for (int k &#x3D; 1; k &lt;&#x3D; radixArrays[i][0]; k++)</span><br><span class="line">                a[j++] &#x3D; radixArrays[i][k];</span><br><span class="line">            radixArrays[i][0] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>运行结果：</em></strong><br><img src="https://img-blog.csdnimg.cn/20190816110325618.png" alt="在这里插入图片描述"></p>
<p><strong><em>算法分析：</em></strong><br>对于n个记录，假设每个记录含d个关键字，每个关键字的取值范围为rd个值，每一趟分配的时间复杂度为 <strong><em>O(n)</em></strong> ，每一趟收集的时间复杂度为 <strong><em>O(rd)</em></strong> 。整个排序需进行d趟分配与收集。<br>*<strong>时间复杂度：O(d(n+rd))***<br>*</strong>空间复杂度： O(n+rd)*** </p>
<p><strong><em>算法特点：</em></strong></p>
<ul>
<li>是稳定排序</li>
<li>可用于链式存储结构</li>
<li>时间复杂度能突破基于关键字比较方法的下界 <strong><em>O(nlog<del>2</del>n)。</em></strong> 达到 <strong><em>O(n)。</em></strong></li>
</ul>
<p><a href="#top">返回顶部</a></p>
<h1 id="总的代码："><a href="#总的代码：" class="headerlink" title="总的代码："></a>总的代码：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void swap(int &amp;a,int &amp;b)&#123;</span><br><span class="line">	int temp&#x3D;a;a&#x3D;b;b&#x3D;temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show(int a[],int n)&#123;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BubbleSort1(int a[],int n)&#123;&#x2F;&#x2F;冒泡排序</span><br><span class="line">	show(a,n); </span><br><span class="line">	for(int i&#x3D;0;i&lt;n-1;i++)&#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;n-1-i;j++)&#123;</span><br><span class="line">			if(a[j]&gt;a[j+1])&#123;</span><br><span class="line">				swap(a[j],a[j+1]);				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;&quot;第&quot;&lt;&lt;i+1&lt;&lt;&quot;趟比较结果：&quot;&lt;&lt;endl;</span><br><span class="line">		show(a,n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BubbleSort2(int a[],int n)&#123;&#x2F;&#x2F;改进的冒泡排序 </span><br><span class="line">	show(a,n); </span><br><span class="line">	int bound,exchange&#x3D;n-1;</span><br><span class="line">	int i&#x3D;0;</span><br><span class="line">	while(exchange!&#x3D;0)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;第&quot;&lt;&lt;++i&lt;&lt;&quot;趟比较结果：&quot;&lt;&lt;endl;</span><br><span class="line">			show(a,n);</span><br><span class="line">		bound&#x3D;exchange;</span><br><span class="line">		exchange&#x3D;0;</span><br><span class="line">		for(int j&#x3D;0;j&lt;bound;j++)&#123;			</span><br><span class="line">			if(a[j]&gt;a[j+1])&#123;</span><br><span class="line">				swap(a[j],a[j+1]);</span><br><span class="line">				exchange&#x3D;j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void quicksort(int a[],int low,int high)&#123;&#x2F;&#x2F;快速排序 </span><br><span class="line"> </span><br><span class="line">	if(low&gt;high) return;</span><br><span class="line">	int pivokey&#x3D;a[low];</span><br><span class="line">	int left&#x3D;low;</span><br><span class="line">	int right&#x3D;high;</span><br><span class="line">	while(left&lt;right) &#123;</span><br><span class="line">		while(a[right]&gt;&#x3D;pivokey&amp;&amp;left&lt;right)  right--;		&#x2F;&#x2F;直到找到一个小的 </span><br><span class="line">		while(a[left]&lt;&#x3D;pivokey&amp;&amp;left&lt;right)  left++;		&#x2F;&#x2F;直到找到一个大的 </span><br><span class="line">		if(left&lt;right)  swap(a[left],a[right]); 		</span><br><span class="line">	&#125;  	</span><br><span class="line">	a[low]&#x3D;a[left];			&#x2F;&#x2F;正是因为选取第一个元素为基准，才能这样，要不然值都被覆盖了 </span><br><span class="line">	a[left]&#x3D;pivokey;</span><br><span class="line">	</span><br><span class="line">	quicksort(a,low,left-1);</span><br><span class="line">	quicksort(a,left+1,high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;int Partition(int r[],int low,int high)&#123;</span><br><span class="line">&#x2F;&#x2F;	int i&#x3D;low,j&#x3D;high;</span><br><span class="line">&#x2F;&#x2F;	while(i&lt;j)&#123;</span><br><span class="line">&#x2F;&#x2F;		while(i&lt;j&amp;&amp;r[i]&lt;&#x3D;r[j]) j--;			&#x2F;&#x2F;直到找到一个小的 </span><br><span class="line">&#x2F;&#x2F;		if(i&lt;j)&#123;</span><br><span class="line">&#x2F;&#x2F;			cout&lt;&lt;r[i]&lt;&lt;&quot;和&quot;&lt;&lt;r[j]&lt;&lt;&quot;交换&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;			swap(r[i],r[j]);</span><br><span class="line">&#x2F;&#x2F;			&#x2F;&#x2F;i++;</span><br><span class="line">&#x2F;&#x2F;		&#125;</span><br><span class="line">&#x2F;&#x2F;		while(i&lt;j&amp;&amp;r[i]&lt;&#x3D;r[j]) i++;			&#x2F;&#x2F;直到找到一个大的 </span><br><span class="line">&#x2F;&#x2F;		if(i&lt;j)&#123;</span><br><span class="line">&#x2F;&#x2F;			cout&lt;&lt;r[i]&lt;&lt;&quot;和&quot;&lt;&lt;r[j]&lt;&lt;&quot;交换&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;			swap(r[i],r[j]);</span><br><span class="line">&#x2F;&#x2F;			&#x2F;&#x2F;j--;</span><br><span class="line">&#x2F;&#x2F;		&#125;</span><br><span class="line">&#x2F;&#x2F;		show(r,11);</span><br><span class="line">&#x2F;&#x2F;	&#125;</span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;endl&lt;&lt;&quot;位置&quot;&lt;&lt;i&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	return i;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">int Partition(int a[],int low,int high)&#123;	</span><br><span class="line">	int pivokey&#x3D;a[low];</span><br><span class="line">	while(low &lt; high) &#123;</span><br><span class="line">		while(a[high]&gt;&#x3D;pivokey&amp;&amp;low &lt; high)  high--;	&#x2F;&#x2F;直到找到一个小的 </span><br><span class="line">		a[low]&#x3D;a[high];			&#x2F;&#x2F;正是因为选取第一个元素为基准，才能这样，要不然值都被覆盖了 </span><br><span class="line">		while(a[low]&lt;&#x3D;pivokey&amp;&amp;low &lt; high)  low++;		&#x2F;&#x2F;直到找到一个大的 </span><br><span class="line">		a[high]&#x3D;a[low]; 	</span><br><span class="line">	</span><br><span class="line">	&#125;  </span><br><span class="line">	a[low]&#x3D;pivokey;</span><br><span class="line">	return low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;void QuickSort(int r[],int low,int high)&#123;</span><br><span class="line">&#x2F;&#x2F;	int pivot;</span><br><span class="line">&#x2F;&#x2F;	if(low&lt;high)&#123;</span><br><span class="line">&#x2F;&#x2F;		pivot&#x3D;Partition(r,low,high);</span><br><span class="line">&#x2F;&#x2F;		QuickSort(r,low,pivot-1);</span><br><span class="line">&#x2F;&#x2F;		QuickSort(r,pivot+1,high);</span><br><span class="line">&#x2F;&#x2F;	&#125;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">void QuickSort(int array[],int low,int high)&#123;&#x2F;&#x2F;随机化法改进的快速排序 </span><br><span class="line">	srand(unsigned(time(0)));</span><br><span class="line">    int sc&#x3D;rand()%(high-low)+1+low;</span><br><span class="line">    cout&lt;&lt;&quot;随机数&quot;&lt;&lt;sc&lt;&lt;endl;</span><br><span class="line">    swap(array[sc],array[low]);</span><br><span class="line">    int par&#x3D;Partition(array,low,high);</span><br><span class="line">    if (par&gt;low+1)&#123;</span><br><span class="line">        QuickSort(array,low,par-1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (par&lt;high-1)&#123;</span><br><span class="line">        QuickSort(array,par+1,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int SelectMink(int r[],int low,int high,int k)&#123; </span><br><span class="line">	int s&#x3D; Partition(r,low,high);</span><br><span class="line">	if(s&#x3D;&#x3D;k) return r[s];</span><br><span class="line">	if(s&gt;k) return SelectMink(r,low,s-1,k);</span><br><span class="line">	else return SelectMink(r,s+1,high,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InsertSort(int r[],int n)&#123;&#x2F;&#x2F;第0位置设置观察哨，第1位置为有序区，从第二个开始扫描插入 </span><br><span class="line">	int i,j;</span><br><span class="line">	for(i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">		r[0]&#x3D;r[i];</span><br><span class="line">		for(j&#x3D;i-1;r[0]&lt;r[j];j--)&#123;&#x2F;&#x2F;带插入的数依次和有序区比，寻找插入位置 </span><br><span class="line">			r[j+1]&#x3D;r[j];</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		r[j+1]&#x3D;r[0];</span><br><span class="line">		cout&lt;&lt;&quot;第&quot;&lt;&lt;i-1&lt;&lt;&quot;趟结果：&quot;&lt;&lt;endl;</span><br><span class="line">		show(r,11);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BInsertSort(int Array[],int n)		&#x2F;&#x2F;第0位置设置观察哨，折半插入排序升序排列</span><br><span class="line">&#123;</span><br><span class="line">	int i,j,m;      &#x2F;&#x2F;m充当比较区间的中点</span><br><span class="line">	int low,high;     </span><br><span class="line">	for (i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Array[0] &#x3D; Array[i];</span><br><span class="line">		low &#x3D; 1; high &#x3D; i-1;   </span><br><span class="line">	</span><br><span class="line">		while (low &lt;&#x3D; high)&#123;</span><br><span class="line">			m &#x3D; (low + high)&#x2F;2;</span><br><span class="line">			if (Array[0] &gt; Array[m])  low &#x3D; m+1;</span><br><span class="line">			else  high &#x3D; m-1;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;*确定好位置后，将位置之后的数据后移，插入待排序数据*&#x2F;</span><br><span class="line">		for (j &#x3D; i-1;j &gt; high; j--)&#123;</span><br><span class="line">			Array[j+1] &#x3D; Array[j];</span><br><span class="line">		&#125;</span><br><span class="line">		Array[j+1] &#x3D; Array[0];</span><br><span class="line">		cout&lt;&lt;&quot;第&quot;&lt;&lt;i-1&lt;&lt;&quot;趟结果：&quot;&lt;&lt;endl;</span><br><span class="line">		show(Array,11);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ShellInsertSort(int a[], int n)			&#x2F;&#x2F;希尔排序 </span><br><span class="line">&#123; </span><br><span class="line">    int d, i, j; &#x2F;&#x2F;d为增量</span><br><span class="line">    for(d &#x3D; n&#x2F;2;d &gt;&#x3D; 1;d &#x3D; d&#x2F;2)&#123; &#x2F;&#x2F;增量递减到1使完成排序  </span><br><span class="line">        </span><br><span class="line">		for(i &#x3D; d; i &lt; n;i++)&#123;   &#x2F;&#x2F;插入排序的一轮       </span><br><span class="line">            a[0] &#x3D; a[i];</span><br><span class="line">            for(j &#x3D; i - d;(j &gt;&#x3D; 0) &amp;&amp; (a[j] &gt; a[0]);j &#x3D; j-d)&#123;</span><br><span class="line">                a[j + d] &#x3D; a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        	a[j + d] &#x3D; a[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SelectionSort(int a[], int n) &#123;	&#x2F;&#x2F;直接选择排序 </span><br><span class="line">    int i,j,pos;</span><br><span class="line">	for(i&#x3D;0;i&lt;n-1;i++)&#123;</span><br><span class="line">        for (pos&#x3D;i, j&#x3D;i+1; j&lt;n; j++)</span><br><span class="line">            if (a[pos]&gt;a[j])</span><br><span class="line">                pos&#x3D;j;</span><br><span class="line">        if (pos !&#x3D; i) &#123;</span><br><span class="line">            swap(a[i],a[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;第&quot;&lt;&lt;i+1&lt;&lt;&quot;趟结果：&quot;&lt;&lt;endl;</span><br><span class="line">		show(a,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void heapAdjust(int a[], int i, int nLength)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;*2*i+1与2*i+2为i的孩子，是因为数组从0位置开始存。</span><br><span class="line">	如果0位置不用，那就是2*i与2*i+1为i的孩子*&#x2F; </span><br><span class="line">    int child;		 </span><br><span class="line">    for (; 2 * i + 1 &lt; nLength; i &#x3D; child)</span><br><span class="line">    &#123; </span><br><span class="line">        child &#x3D; 2 * i + 1;</span><br><span class="line">        </span><br><span class="line">        if ( child &lt; nLength-1 &amp;&amp; a[child + 1] &gt; a[child])	&#x2F;&#x2F; 得到子结点中较大的结点</span><br><span class="line">            ++child;</span><br><span class="line">        </span><br><span class="line">        if (a[i] &lt; a[child])&#123;		&#x2F;&#x2F; 如果较大的子结点大于父结点,交换 </span><br><span class="line">        	swap(a[i],a[child]);</span><br><span class="line">        &#125;</span><br><span class="line">        else  break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreatHeap(int a[],int n)&#123;</span><br><span class="line">	for (int i &#x3D; n &#x2F; 2 - 1; i &gt;&#x3D; 0; --i)	&#x2F;&#x2F;length&#x2F;2-1是第一个非叶节点</span><br><span class="line">        heapAdjust(a, i, n);</span><br><span class="line">        show(a,11); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HeapSort(int a[],int length)	&#x2F;&#x2F; 堆排序</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;&quot;初始大根堆如下：&quot;&lt;&lt;endl;</span><br><span class="line">    CreatHeap(a,length);			&#x2F;&#x2F;把无序序列变成大根堆</span><br><span class="line">	 </span><br><span class="line">    &#x2F;&#x2F; 从最后一个元素开始对序列进行调整</span><br><span class="line">    for (int i &#x3D; length - 1; i &gt; 0; --i)</span><br><span class="line">    &#123;    </span><br><span class="line">      	swap(a[i],a[0]);			&#x2F;&#x2F; 把第一个元素和当前的最后一个元素交换，       </span><br><span class="line">        heapAdjust(a, 0, i);		&#x2F;&#x2F;不断的缩小调整的范围直到第一个元素     </span><br><span class="line">		cout&lt;&lt;&quot;后续调整堆如下：&quot;&lt;&lt;endl;</span><br><span class="line">		show(a,11); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Merge(int r[],int r1[],int s,int m,int t)&#123;&#x2F;&#x2F;归并 </span><br><span class="line">	int i&#x3D;s,j&#x3D;m+1,k&#x3D;s;</span><br><span class="line">	while(i&lt;&#x3D;m&amp;&amp;j&lt;&#x3D;t)&#123;</span><br><span class="line">		if(r[i]&lt;r[j]) r1[k++]&#x3D;r[i++];</span><br><span class="line">		else r1[k++]&#x3D;r[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	while(i&lt;&#x3D;m)&#123;</span><br><span class="line">		r1[k++]&#x3D;r[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	while(j&lt;&#x3D;t)&#123;</span><br><span class="line">		r1[k++]&#x3D;r[j++];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MergeSort(int r[],int s,int t)&#123;</span><br><span class="line">	int m,r1[t];</span><br><span class="line">	if(s&#x3D;&#x3D;t) return;</span><br><span class="line">	else&#123;</span><br><span class="line">		m&#x3D;(s+t)&#x2F;2;</span><br><span class="line">		MergeSort(r,s,m);</span><br><span class="line">		MergeSort(r,m+1,t);</span><br><span class="line">		Merge(r,r1,s,m,t);</span><br><span class="line">		cout&lt;&lt;s&lt;&lt;&quot;-&gt;&quot;&lt;&lt;t&lt;&lt;&quot;位置已排好序&quot;&lt;&lt;endl;</span><br><span class="line">		for(int i&#x3D;s;i&lt;&#x3D;t;i++)&#123;</span><br><span class="line">			r[i]&#x3D;r1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		show(r,11);			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getNumInPos(int num,int pos) &#x2F;&#x2F;获得某个数字的第pos位的值</span><br><span class="line">&#123;</span><br><span class="line">    int temp &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; pos - 1; i++)</span><br><span class="line">        temp *&#x3D; 10;</span><br><span class="line"> </span><br><span class="line">    return (num &#x2F; temp) % 10;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#define RADIX 10    &#x2F;&#x2F;可能是0-9，需要10个桶 </span><br><span class="line">#define KEYNUM 5     &#x2F;&#x2F;整数位数</span><br><span class="line">void RadixSort(int a[], int n)		&#x2F;&#x2F;基数排序 </span><br><span class="line">&#123;</span><br><span class="line">    int *radixArrays[RADIX];    &#x2F;&#x2F;分别为0~9的序列空间</span><br><span class="line">    for (int i &#x3D; 0; i &lt; RADIX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        radixArrays[i] &#x3D; new int[n];</span><br><span class="line">        radixArrays[i][0] &#x3D; 0;    </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (int pos &#x3D; 1; pos &lt;&#x3D; KEYNUM; pos++)    &#x2F;&#x2F;从个位开始</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++)    &#x2F;&#x2F;分配过程</span><br><span class="line">        &#123;</span><br><span class="line">            int num &#x3D; getNumInPos(a[i], pos);</span><br><span class="line">            int index &#x3D; ++radixArrays[num][0];</span><br><span class="line">            radixArrays[num][index] &#x3D; a[i];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        for (int i &#x3D; 0, j &#x3D;0; i &lt; RADIX; i++) &#x2F;&#x2F;写回到原数组中</span><br><span class="line">        &#123;</span><br><span class="line">            for (int k &#x3D; 1; k &lt;&#x3D; radixArrays[i][0]; k++)</span><br><span class="line">                a[j++] &#x3D; radixArrays[i][k];</span><br><span class="line">            radixArrays[i][0] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  	int n&#x3D;11;</span><br><span class="line">    int a[n]&#x3D;&#123;5,3,8,1,4,6,9,2,7,10,11&#125;;</span><br><span class="line">&#x2F;&#x2F;    srand(unsigned(time(0)));</span><br><span class="line">&#x2F;&#x2F;    for (int i &#x3D; 0; i &lt;n ; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;        a[i] &#x3D; rand()%100+1;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;&quot;直接插入排序:&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	show(a,n);</span><br><span class="line">&#x2F;&#x2F;	InsertSort(a,n-1); </span><br><span class="line">&#x2F;&#x2F;	show(a,n);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;&quot;折半插入排序:&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	show(a,n);</span><br><span class="line">&#x2F;&#x2F;	BInsertSort(a,n-1); </span><br><span class="line">&#x2F;&#x2F;	show(a,n);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;&quot;希尔排序:&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	show(a,n);</span><br><span class="line">&#x2F;&#x2F;	ShellInsertSort(a,n-1); </span><br><span class="line">&#x2F;&#x2F;	show(a,n);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;&quot;快速排序:&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	show(a,n);</span><br><span class="line">&#x2F;&#x2F;    QuickSort(a,0,n-1);</span><br><span class="line">&#x2F;&#x2F;	quicksort(a,0,n-1);</span><br><span class="line">&#x2F;&#x2F;	show(a,n);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;endl&lt;&lt;&quot;冒泡排序:&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	BubbleSort1(a,n);</span><br><span class="line">&#x2F;&#x2F;	show(a,n);</span><br><span class="line">&#x2F;&#x2F;	</span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;endl&lt;&lt;&quot;改进的冒泡排序:&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	BubbleSort2(a,n);</span><br><span class="line">&#x2F;&#x2F;	show(a,n);</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;endl&lt;&lt;&quot;直接选择排序:&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	show(a,n);</span><br><span class="line">&#x2F;&#x2F;	SelectionSort(a,n);</span><br><span class="line">&#x2F;&#x2F;	show(a,n);</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;&quot;堆排序:&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	show(a,n);</span><br><span class="line">&#x2F;&#x2F;	HeapSort(a,n);</span><br><span class="line">&#x2F;&#x2F;	show(a,n);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;    cout&lt;&lt;endl&lt;&lt;&quot;归并排序:&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;    show(a,n);</span><br><span class="line">&#x2F;&#x2F;    MergeSort(a,0,n-1);</span><br><span class="line">&#x2F;&#x2F;   	show(a,n);</span><br><span class="line">   	</span><br><span class="line">&#x2F;&#x2F;   	cout&lt;&lt;endl&lt;&lt;&quot;基数排序:&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;    show(a,n);</span><br><span class="line">&#x2F;&#x2F;    RadixSort(a,n);</span><br><span class="line">&#x2F;&#x2F;   	show(a,n);</span><br><span class="line">   	</span><br><span class="line">    int choose;</span><br><span class="line">    show(a,n);</span><br><span class="line">    cout&lt;&lt;&quot;请输入要查询第几小的数:&quot;&lt;&lt;endl; </span><br><span class="line">    cin&gt;&gt;choose; </span><br><span class="line">    printf(&quot;第%d小的数是：%d\n&quot;,choose,SelectMink(a,0,n,choose));</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">返回顶部</a></p>
]]></content>
      <tags>
        <tag>各种排序算法总结</tag>
      </tags>
  </entry>
  <entry>
    <title>scanf函数</title>
    <url>/2019/08/15/scanf%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="scanf-函数最容易出问题的地方就是"><a href="#scanf-函数最容易出问题的地方就是" class="headerlink" title="scanf()函数最容易出问题的地方就是"></a>scanf()函数最容易出问题的地方就是</h2><h1 id="格式化读取与缓冲区的问题。"><a href="#格式化读取与缓冲区的问题。" class="headerlink" title="格式化读取与缓冲区的问题。"></a><em>格式化读取与缓冲区的问题。</em></h1><p>结合代码来看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int a&#x3D;1,b&#x3D;1;</span><br><span class="line">	char c&#x3D;&#39;a&#39;;</span><br><span class="line">	printf(&quot;before：\n&quot;);   </span><br><span class="line">    printf(&quot;%d,%d,%c\n&quot;,a,b,c);   &#x2F;&#x2F;输出初始化状态</span><br><span class="line">    </span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;清空缓冲区</span><br><span class="line">    &#x2F;&#x2F;fflush( stdin );</span><br><span class="line">    &#x2F;&#x2F;scanf(&quot;%*[^\n]%*c&quot;);</span><br><span class="line">    </span><br><span class="line">    scanf(&quot;%c&quot;,&amp;c);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d,%d,%c\n&quot;,a,b,c);   &#x2F;&#x2F;输出之后的变化</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一开始输出1,1，a这没问题。<br><img src="https://img-blog.csdnimg.cn/20190815093047723.png" alt="在这里插入图片描述"></p>
<h2 id="scanf-从缓冲区格式化读取东西，如果缓冲区不为空，无需等待用户输入，直接从缓冲区继续读取。"><a href="#scanf-从缓冲区格式化读取东西，如果缓冲区不为空，无需等待用户输入，直接从缓冲区继续读取。" class="headerlink" title="scanf()从缓冲区格式化读取东西，如果缓冲区不为空，无需等待用户输入，直接从缓冲区继续读取。"></a><em>scanf()从缓冲区格式化读取东西，如果缓冲区不为空，无需等待用户输入，直接从缓冲区继续读取。</em></h2><ul>
<li><p><strong><em>当我输入2 b时，结果如下：</em></strong><br><img src="https://img-blog.csdnimg.cn/20190815093800725.png" alt="在这里插入图片描述"><br>分析：</p>
<h2 id="scanf-“-d-d”-amp-a-amp-b"><a href="#scanf-“-d-d”-amp-a-amp-b" class="headerlink" title="scanf(“%d%d”,&amp;a,&amp;b);"></a><em>scanf(“%d%d”,&amp;a,&amp;b);</em></h2><p>想要读取两个整型数据，先读取到2符合，存到了a；然后读到空格，忽略；(直接输2b结果一样)。在读取b字符型不是整型，退出scanf()函数，b变量并未被赋值。<br>**<em>此时，缓冲区中剩余字符b。**</em></p>
<p>   然后执行</p>
<h2 id="scanf-“-c”-amp-c"><a href="#scanf-“-c”-amp-c" class="headerlink" title="scanf(“%c”,&amp;c);"></a><em>scanf(“%c”,&amp;c);</em></h2><p>   因为缓冲区中有字符b，直接读取b，存到了c变量。</p>
</li>
<li><p><strong><em>清空缓冲区：</em></strong><br>  代码中加入下列两个函数之一都可以清空缓冲区。</p>
<h2 id="fflush-stdin"><a href="#fflush-stdin" class="headerlink" title="fflush( stdin );"></a><em>fflush( stdin );</em></h2><h2 id="scanf-“-n-c”"><a href="#scanf-“-n-c”" class="headerlink" title="scanf(“%[^\n]%c”);"></a><em>scanf(“%</em>[^\n]%<em>c”);</em></h2><p>  <img src="https://img-blog.csdnimg.cn/20190815095630577.png" alt="在这里插入图片描述"><br>  输入2b之后，缓冲区被清，第二个scanf()函数等待用户输入。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>scanf函数</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现视频转字符</title>
    <url>/2019/08/11/python%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E8%BD%AC%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h3 id="抖音上看到那种把舞蹈变成字符型的小视频，如下图那种。就一直想弄一个。参考了网上写的好多代码，自己整理了一个。"><a href="#抖音上看到那种把舞蹈变成字符型的小视频，如下图那种。就一直想弄一个。参考了网上写的好多代码，自己整理了一个。" class="headerlink" title="抖音上看到那种把舞蹈变成字符型的小视频，如下图那种。就一直想弄一个。参考了网上写的好多代码，自己整理了一个。"></a><em>抖音上看到那种把舞蹈变成字符型的小视频，如下图那种。就一直想弄一个。参考了网上写的好多代码，自己整理了一个。</em></h3><p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/2019081121230937.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/2019081121230937.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =300x)</p>
<h3 id="大概思路："><a href="#大概思路：" class="headerlink" title="大概思路："></a>大概思路：</h3><ol>
<li>先将原视频分割为一张一张的图片</li>
<li>再将这些图片转换为字符型的</li>
<li>又将这些字符型的图片串成视频即可</li>
</ol>
<h3 id="废话不多说，完整代码如下，有注释说明，只需更改一下视频路径及其存储路径即可。"><a href="#废话不多说，完整代码如下，有注释说明，只需更改一下视频路径及其存储路径即可。" class="headerlink" title="废话不多说，完整代码如下，有注释说明，只需更改一下视频路径及其存储路径即可。"></a><em>废话不多说，完整代码如下，有注释说明，只需更改一下视频路径及其存储路径即可。</em></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Sun Aug 11 20:55:29 2019</span><br><span class="line"></span><br><span class="line">@author: Administrator</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import cv2</span><br><span class="line">import os</span><br><span class="line">from PIL import Image, ImageDraw, ImageFont</span><br><span class="line"></span><br><span class="line">WIDTH &#x3D; 80  #定义输出画面的宽度</span><br><span class="line">HEIGHT &#x3D; 45  #定义</span><br><span class="line">ascii_char &#x3D; list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft&#x2F;\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\&quot;^&#96;&#39;. &quot;)  #所用字符列表</span><br><span class="line"></span><br><span class="line"># 将256灰度映射到70个字符上</span><br><span class="line">def get_char(r, g, b, alpha&#x3D;256):  # alpha透明度</span><br><span class="line">    if alpha &#x3D;&#x3D; 0:</span><br><span class="line">        return &#39; &#39;</span><br><span class="line">    length &#x3D; len(ascii_char)</span><br><span class="line">    gray &#x3D; int(0.2126 * r + 0.7152 * g + 0.0722 * b)  # 计算灰度</span><br><span class="line">    unit &#x3D; (256.0 + 1) &#x2F; length</span><br><span class="line">    return ascii_char[int(gray &#x2F; unit)]  # 不同的灰度对应着不同的字符</span><br><span class="line"></span><br><span class="line">#通过灰度来区分色块</span><br><span class="line">#该部分以下和灰度值字符画区别所在</span><br><span class="line">def PictureToChar(sourcePath,storagePath):</span><br><span class="line">    print(&quot;开始将图片转为字符型：&quot;)</span><br><span class="line">    # 循环最多读取1100张图片，自己可更改</span><br><span class="line">    for icount in range(1, 1100):</span><br><span class="line">        IMG &#x3D; sourcePath+str(icount)+&#39;.jpg&#39; #文件路径</span><br><span class="line">        if os.path.exists(IMG):</span><br><span class="line">            im &#x3D; Image.open(IMG)</span><br><span class="line">            #视频分割后图片的长与宽，与合成视频时要相统一,保存下来，合成字符视频时用到</span><br><span class="line">            sourceImage&#x3D;im</span><br><span class="line">            WIDTH &#x3D; int(im.width&#x2F;6) #高度比例为原图的1&#x2F;6较好，由于字体宽度</span><br><span class="line">            HEIGHT &#x3D; int(im.height&#x2F;15)  #高度比例为原图的1&#x2F;15较好，由于字体高度</span><br><span class="line">            im_txt &#x3D; Image.new(&quot;RGB&quot;,(im.width,im.height),(255,255,255))</span><br><span class="line">            im &#x3D; im.resize((WIDTH,HEIGHT),Image.NEAREST)</span><br><span class="line">            txt &#x3D; &quot;&quot;</span><br><span class="line">            colors &#x3D; []</span><br><span class="line">            for i in range(HEIGHT):</span><br><span class="line">                for j in range(WIDTH):</span><br><span class="line">                    pixel &#x3D; im.getpixel((j,i))</span><br><span class="line">                    colors.append((pixel[0],pixel[1],pixel[2]))#记录像素颜色信息</span><br><span class="line">                    if(len(pixel) &#x3D;&#x3D; 4):</span><br><span class="line">                        txt +&#x3D; get_char(pixel[0],pixel[1],pixel[2],pixel[3])</span><br><span class="line">                    else:</span><br><span class="line">                        txt +&#x3D; get_char(pixel[0],pixel[1],pixel[2])</span><br><span class="line">                txt +&#x3D; &#39;\n&#39;</span><br><span class="line">                colors.append((255,255,255))</span><br><span class="line">            dr &#x3D; ImageDraw.Draw(im_txt)</span><br><span class="line">            font&#x3D;ImageFont.load_default().font#获取字体</span><br><span class="line">            x&#x3D;y&#x3D;0</span><br><span class="line">            #获取字体的宽高</span><br><span class="line">            font_w,font_h&#x3D;font.getsize(txt[1])</span><br><span class="line">            font_h *&#x3D; 1.37 #调整后更佳</span><br><span class="line">            #ImageDraw为每个ascii码进行上色</span><br><span class="line">            for i in range(len(txt)):</span><br><span class="line">                if(txt[i]&#x3D;&#x3D;&#39;\n&#39;):</span><br><span class="line">                    x+&#x3D;font_h</span><br><span class="line">                    y&#x3D;-font_w</span><br><span class="line">                dr.text([y,x],txt[i],colors[i])</span><br><span class="line">                y+&#x3D;font_w</span><br><span class="line">            #输出</span><br><span class="line">            name &#x3D; str(icount) + &#39;.jpg&#39;</span><br><span class="line">            print(name)</span><br><span class="line">            im_txt.save(storagePath + str(icount) + &#39;.jpg&#39;)</span><br><span class="line">    return sourceImage</span><br><span class="line"></span><br><span class="line">def charToVideo(storagePath,sourceImage): </span><br><span class="line">    # 设置视频编码器,这里使用使用MJPG编码器</span><br><span class="line">    #fourcc &#x3D; cv2.VideoWriter_fourcc(*&#39;MJPG&#39;)</span><br><span class="line">    </span><br><span class="line">    #这里是mp4格式</span><br><span class="line">    fourcc &#x3D; cv2.VideoWriter_fourcc(&#39;D&#39;, &#39;I&#39;, &#39;V&#39;, &#39;X&#39;)#不同视频编码对应不同视频格式（例：&#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39; 对应avi格式）</span><br><span class="line"> </span><br><span class="line">    print(&quot;开始将字符型图片变为视频：&quot;)</span><br><span class="line">    #输出视频参数设置,包含视频文件名、编码器、帧率、视频宽高(此处参数需和字符图片大小一致)</span><br><span class="line">    videoWriter &#x3D; cv2.VideoWriter(storagePath+&#39;test.mp4&#39;, fourcc, 30.0, (sourceImage.width,sourceImage.height))</span><br><span class="line">     </span><br><span class="line">    #循环最多读取1100张图片，自己可更改</span><br><span class="line">    for i in range(1, 1100):</span><br><span class="line">        filename &#x3D; storagePath +str(i)+&#39;.jpg&#39;</span><br><span class="line">        # 判断图片是否存在</span><br><span class="line">        if os.path.exists(filename):</span><br><span class="line">            img &#x3D; cv2.imread(filename&#x3D;filename)</span><br><span class="line">            # 在一个给定的时间内(单位ms)等待用户按键触发,100ms</span><br><span class="line">            cv2.waitKey(100)</span><br><span class="line">            # 将图片写入视频中</span><br><span class="line">            videoWriter.write(img)</span><br><span class="line">            print(str(i) + &#39;.jpg&#39; + &#39; done!&#39;)</span><br><span class="line">    # 视频释放</span><br><span class="line">    videoWriter.release()</span><br><span class="line">    print(&quot;字符视频已成功生成!!!&quot;)</span><br><span class="line">    </span><br><span class="line">def VideoToPicture(path):</span><br><span class="line">    # 在当前目录下新建文件夹</span><br><span class="line">    folder_path &#x3D; &quot;imgbear&#x2F;&quot;</span><br><span class="line">    os.makedirs(folder_path)</span><br><span class="line">    # 进行视频的载入</span><br><span class="line">    vc &#x3D; cv2.VideoCapture(path)</span><br><span class="line">    print(&quot;开始将原视频分割为图片：&quot;)</span><br><span class="line">    c &#x3D; 0</span><br><span class="line">    # 判断载入的视频是否可以打开</span><br><span class="line">    ret &#x3D; vc.isOpened()</span><br><span class="line">    # 循环读取视频帧</span><br><span class="line">    while ret:</span><br><span class="line">        c &#x3D; c + 1</span><br><span class="line">        # 进行单张图片的读取,ret的值为True或者Flase,frame表示读入的图片</span><br><span class="line">        ret, frame &#x3D; vc.read()</span><br><span class="line">        if ret:</span><br><span class="line">            # 存储为图像</span><br><span class="line">            cv2.imwrite(folder_path+str(c) + &#39;.jpg&#39;, frame)</span><br><span class="line">            # 输出图像名称</span><br><span class="line">            print(folder_path+str(c) + &#39;.jpg&#39;)</span><br><span class="line">            # 在一个给定的时间内(单位ms)等待用户按键触发,1ms</span><br><span class="line">            cv2.waitKey(1)</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">    # 视频释放</span><br><span class="line">    vc.release()</span><br><span class="line">    return folder_path</span><br><span class="line">    </span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:  </span><br><span class="line">    </span><br><span class="line">    #视频所在路径</span><br><span class="line">    path&#x3D;&#39;C:&#x2F;&#x2F;Users&#x2F;&#x2F;Administrator&#x2F;&#x2F;Desktop&#x2F;&#x2F;aa.mp4&#39;</span><br><span class="line">    #存储路径，路径上的文件夹必须已经存在</span><br><span class="line">    storagePath&#x3D;&#39;C:&#x2F;&#x2F;Users&#x2F;&#x2F;Administrator&#x2F;&#x2F;Desktop&#x2F;&#x2F;1&#x2F;&#x2F;&#39;</span><br><span class="line">    sourcePath &#x3D; VideoToPicture(path)</span><br><span class="line">    sourceImage &#x3D; PictureToChar(sourcePath,storagePath) </span><br><span class="line">    charToVideo(storagePath,sourceImage)</span><br></pre></td></tr></table></figure>
<h3 id="最后结果如下："><a href="#最后结果如下：" class="headerlink" title="最后结果如下："></a>最后结果如下：</h3><p><img src="https://img-blog.csdnimg.cn/20190811221154805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>python实现视频转字符</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表</title>
    <url>/2019/08/11/%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<body>
<div id="top"></div>
</body>


<h1 id="散列表概念"><a href="#散列表概念" class="headerlink" title="散列表概念"></a>散列表概念</h1><ul>
<li>散列函数和散列地址：类似于函数y=f(x),给定一个x，能得到一个y。散列函数，给定一个关键字，可以得到一个地址。但有时不同的key可能得到相同的p，需要 <strong><em>处理冲突。</em></strong> p=Hey(key)。</li>
<li>散列表：一个有限连续的地址空间，用以存储散列函数计算得到相应散列地址的数据记录。</li>
</ul>
<h1 id="散列表主要两个问题"><a href="#散列表主要两个问题" class="headerlink" title="散列表主要两个问题"></a>散列表主要两个问题</h1><h2 id="散列函数的构造"><a href="#散列函数的构造" class="headerlink" title="散列函数的构造"></a>散列函数的构造</h2><ol>
<li>数字分析法：事先必须明确知道左右的关键字每一位上各种数字的分布情况，选取随机的几位作为散列地址。</li>
<li>平方取中法：顾名思义，就是将关键字平方之后取中间的几位作为散列地址。</li>
<li>折叠法：将关键字分割成位数相同的几部分，最后一部分的位数可以不同，然后取这几部分的叠加和作为散列地址。<br> <strong><em>又可以分为两种：</em></strong><br> 例如：key=45387765213，从左到右按3位分割，可以得到4部分：453,877,652,13 。<br> ①移位叠加：<br> <img src="https://img-blog.csdnimg.cn/20190811092706801.png" alt="在这里插入图片描述"><br> ②边界叠加：<br> <img src="https://img-blog.csdnimg.cn/20190811093839738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>除留余数法：顾名思义，用关键字去除以不大于表长的数，然后取余数为散列地址。这是最常用的构造散列函数的方法。 <h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2></li>
<li>开放地址发：所谓开放地址，是指在寻找“下一个”空的散列地址时，原来的数组空间对所有的元素都是开放的。把寻找“下一个”位置的过程叫 <strong><em>探测。</em></strong><br> <strong><em>H<del>i</del>=(H(key)+d<del>i</del>)%m</em></strong><br>①线性探测法：d<del>i</del>=1,2,3,…,m-1<br>②二次探测法：d<del>i</del>=1^2^,-1^2^,2^2^,-2^2^,…,k^2^,-k^2^ (k&lt;=m/2)<br>③伪随机探测法：d<del>i</del>=伪随机生成数<br><img src="https://img-blog.csdnimg.cn/20190811100237515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>链地址法：它和邻接表存储图有几分相似。把具有相同散列地址的记录放在同一个链表中，同时用一个数组存放各个链表的头指针。凡是散列地址为i的记录都已结点方式插入到以H[i]为头结点的单链表中。</li>
</ol>
<p><a href="#top">返回顶部</a></p>
<h1 id="散列表的查找"><a href="#散列表的查找" class="headerlink" title="散列表的查找"></a>散列表的查找</h1><p>在散列表上进行查找的过程和创建散列表的过程基本一致。</p>
<ol>
<li><p>给定关键字key，根据构造的散列函数计算H<del>0</del>=H（key）。</p>
</li>
<li><p>若单元H<del>0</del>为空，则所查元素不存在。</p>
</li>
<li><p>若单元H<del>0</del>中的关键字为key，则查找成功。</p>
</li>
<li><p>若单元H<del>0</del>中的关键字不为key，则按照所采用的处理冲突的方法继续查找。<br> ①计算下一个散列地址H<del>i</del>；<br> ②若单元H<del>i</del>为空，则所查元素不存在。<br> ③若单元H<del>i</del>中的关键字为key，则查找成功。<br> ④若单元H<del>i</del>中的关键字不为key，则继续。</p>
<p> 散列表的装填因子 <strong><em>α</em></strong> 定义为：<br><img src="https://img-blog.csdnimg.cn/20190811103844307.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190811103434341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h2></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define m 12 			&#x2F;&#x2F;散列表表长</span><br><span class="line">#define NULLKEY -1		&#x2F;&#x2F;单元为空的标记 </span><br><span class="line"> </span><br><span class="line">typedef struct			&#x2F;&#x2F;散列表结点类型</span><br><span class="line">&#123;</span><br><span class="line">    int *elem;  		&#x2F;&#x2F;数据元素存储基地址，动态分配数组</span><br><span class="line">    int count;  		&#x2F;&#x2F;当前数据元素个数</span><br><span class="line">&#125;HashTable;     </span><br><span class="line"></span><br><span class="line">int InitHashTable(HashTable *h)		&#x2F;&#x2F;初始化散列表</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	h-&gt;elem &#x3D; (int *)malloc(sizeof(int) * m );</span><br><span class="line">	h-&gt;count&#x3D;0;</span><br><span class="line">	if(h-&gt;elem &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;分配内存失败\n&quot;);</span><br><span class="line">	 	exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line">	for(i &#x3D; 0; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	 	h-&gt;elem[i] &#x3D; NULLKEY;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int Hash(int key)		&#x2F;&#x2F;散列函数</span><br><span class="line">&#123;</span><br><span class="line">	return key % m;    &#x2F;&#x2F;除留余数法</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void InsertHash(HashTable *h, int key)	&#x2F;&#x2F;将关键字插入散列表</span><br><span class="line">&#123;</span><br><span class="line">	int addr &#x3D; Hash(key);              	&#x2F;&#x2F;求散列地址</span><br><span class="line">	while(h-&gt;elem[addr] !&#x3D; NULLKEY) 	&#x2F;&#x2F;如果不为空，则冲突</span><br><span class="line">	&#123;</span><br><span class="line">	 	addr &#x3D; (addr + 1) % m;         	&#x2F;&#x2F;线性探测</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	h-&gt;elem[addr] &#x3D; key;                &#x2F;&#x2F;直到有空位后插入关键字</span><br><span class="line">	h-&gt;count++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int SearchHash(HashTable h, int key)		&#x2F;&#x2F;散列表查找关键字</span><br><span class="line">&#123;</span><br><span class="line">	int addr &#x3D; Hash(key);                   &#x2F;&#x2F;求散列地址</span><br><span class="line">	if(h.elem[addr]&#x3D;&#x3D;NULLKEY) return -1;	&#x2F;&#x2F;如果为空，则元素不存在 </span><br><span class="line">	else if(h.elem[addr] &#x3D;&#x3D; key)   </span><br><span class="line">		return addr;						&#x2F;&#x2F;如果单元中的关键字为key，则查找成功 </span><br><span class="line">	else&#123;  </span><br><span class="line">		int i&#x3D;0;</span><br><span class="line">		for(i&#x3D;1;i&lt;m;i++) &#123;</span><br><span class="line">			addr &#x3D; (addr + 1) % m;     		&#x2F;&#x2F;线性探测</span><br><span class="line">			if(h.elem[addr] &#x3D;&#x3D; NULLKEY) </span><br><span class="line">				return -1;</span><br><span class="line">			else if(h.elem[addr] &#x3D;&#x3D; key)</span><br><span class="line">				return addr;	</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">int main()</span><br><span class="line">&#123;	</span><br><span class="line">	int i&#x3D;0;</span><br><span class="line">	HashTable h;	</span><br><span class="line">	</span><br><span class="line">	InitHashTable(&amp;h);		&#x2F;&#x2F;初始化Hash表</span><br><span class="line"></span><br><span class="line">	printf(&quot;Hash表初始化为:\n&quot;);</span><br><span class="line">	for(i &#x3D; 0; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	  printf(&quot;%d &quot;, h.elem[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	</span><br><span class="line">	printf(&quot;输入数据，以#结束\n&quot;);	</span><br><span class="line">	while(scanf(&quot;%d&quot;, &amp;i)) </span><br><span class="line">	&#123; </span><br><span class="line">		if(i &#x3D;&#x3D; &#39;#&#39;)  break;</span><br><span class="line">		</span><br><span class="line">		InsertHash(&amp;h,i); </span><br><span class="line">	  </span><br><span class="line">		if(h.count &gt;&#x3D; m)</span><br><span class="line">		&#123;</span><br><span class="line">		  printf(&quot;Hash表已满，自动退出插入\n&quot;);</span><br><span class="line">		  break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	printf(&quot;插入了%d个元素，为:\n&quot;,h.count);</span><br><span class="line">	for(i &#x3D; 0; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(h.elem[i]&#x3D;&#x3D;-1) continue;</span><br><span class="line">	    else printf(&quot;%d  &quot;, h.elem[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;hash表如下:\n&quot;);</span><br><span class="line">	for(i &#x3D; 0; i &lt; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d  &quot;, h.elem[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	</span><br><span class="line">	printf(&quot;请输入关键字查询,以#结束\n&quot;);</span><br><span class="line">	int key;</span><br><span class="line">	scanf(&quot;%*[^\n]%*c&quot;);	&#x2F;&#x2F;清空缓存区 </span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;key)) </span><br><span class="line">	&#123; </span><br><span class="line">		if(key &#x3D;&#x3D; &#39;#&#39;)  break;</span><br><span class="line">		if(SearchHash(h, key)&#x3D;&#x3D;-1)</span><br><span class="line">			printf(&quot;%d不存在\n&quot;,key);</span><br><span class="line">		else printf(&quot;%d在表中%d个位置\n&quot;,key,SearchHash(h, key)); </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p><img src="https://img-blog.csdnimg.cn/20190811125919394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><a href="#top">返回顶部</a></p>
]]></content>
      <tags>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>free函数</title>
    <url>/2019/08/05/free%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做到一个题，要求删除链表结点后释放内存，乍一看，挺简单的，不就delete或free一下就可以了吗。调试时还是有点不一样的收获的，记录一下。</p>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>就是如果开辟了内存，而没有去释放它，可能造成失去控制权而不能再使用内存，即内存泄漏。</p>
<h1 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h1><p>代码片段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;&quot;before&quot;&lt;&lt;maxPrev;</span><br><span class="line">free(maxPrev);</span><br><span class="line">cout&lt;&lt;&quot;after&quot;&lt;&lt;maxPrev;</span><br><span class="line">maxPrev&#x3D;NULL;</span><br><span class="line">cout&lt;&lt;&quot;after&quot;&lt;&lt;maxPrev;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20190805105604704.png" alt="在这里插入图片描述"><br>如果使用 <strong><em>free(maxPrev);</em></strong> 释放之后，原来的数据还在。但的确是释放了，释放的意思是这个内存可以分配给人家使用，当然，人家用了之后数据就会是人家需要的内容了。<br>这就好比你租房子之后退了，房里留下了一些东西，其他人在来租之后，使用权是人家的，人家爱怎么布置怎么布置。<br>但上面存在的问题就是数据还在那，所以 <strong><em>free</em></strong> 之后，紧跟着清空。房子清空了再租给人家。</p>
]]></content>
      <tags>
        <tag>free了</tag>
        <tag>为什么还在</tag>
      </tags>
  </entry>
  <entry>
    <title>关于链表的一些题目</title>
    <url>/2019/08/05/%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<body>
<div id="top"></div>
</body>


<h1 id="1-删除链表中的重复元素"><a href="#1-删除链表中的重复元素" class="headerlink" title="1.删除链表中的重复元素"></a>1.删除链表中的重复元素</h1><p>前一个与后一个比较，相同就删除结点，并释放内存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void DeleteEqual(PNODE &amp;pHead)&#123;		&#x2F;&#x2F;删除链表中的重复元素</span><br><span class="line">	PNODE p,q,prev;</span><br><span class="line">	if (p&#x3D;pHead-&gt;next)&#123;</span><br><span class="line">		prev&#x3D;p;</span><br><span class="line">		p&#x3D;p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	while (p)&#123;</span><br><span class="line">		if (p-&gt;data&#x3D;&#x3D;prev-&gt;data)&#123;</span><br><span class="line">			q&#x3D;p;</span><br><span class="line">			p&#x3D;p-&gt;next;</span><br><span class="line">			prev-&gt;next&#x3D;p;</span><br><span class="line">			free(q);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			prev&#x3D;p;</span><br><span class="line">			p&#x3D;p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p><img src="https://img-blog.csdnimg.cn/20190805111825512.png" alt="在这里插入图片描述"><br><a href="#top">返回顶部</a></p>
<h1 id="2-删除递增有序链表中大于min，小于max的元素"><a href="#2-删除递增有序链表中大于min，小于max的元素" class="headerlink" title="2.删除递增有序链表中大于min，小于max的元素"></a>2.删除递增有序链表中大于min，小于max的元素</h1><p>先找到两个前驱，释放中间结点，并且将链表重新链起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void DeleteSelect(PNODE &amp;pHead,int min,int max)&#123;		&#x2F;&#x2F;删除递增有序链表中大于min，小于max的元素</span><br><span class="line">	</span><br><span class="line">	PNODE p&#x3D;pHead,minPrev,maxPrev;</span><br><span class="line">	 	</span><br><span class="line">	int flag&#x3D;0;</span><br><span class="line">	while (p-&gt;next)&#123;</span><br><span class="line">		if(p-&gt;next-&gt;data&gt;min&amp;&amp;!flag)&#123;</span><br><span class="line">			minPrev&#x3D;p;</span><br><span class="line">			flag&#x3D;1;	</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		if(p-&gt;next-&gt;data&gt;&#x3D;max)&#123;</span><br><span class="line">			maxPrev&#x3D;p;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		p&#x3D;p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	PNODE temp,start;</span><br><span class="line">	start&#x3D;minPrev-&gt;next;</span><br><span class="line">	while(start-&gt;data!&#x3D;maxPrev-&gt;data)&#123;</span><br><span class="line">		temp&#x3D;start;</span><br><span class="line">		start&#x3D;start-&gt;next;</span><br><span class="line">		free(temp);</span><br><span class="line">		temp&#x3D;NULL; </span><br><span class="line">	&#125;</span><br><span class="line">	minPrev-&gt;next&#x3D;maxPrev-&gt;next;</span><br><span class="line">	free(maxPrev);</span><br><span class="line">	maxPrev&#x3D;NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果：-1"><a href="#运行结果：-1" class="headerlink" title="运行结果："></a>运行结果：</h2><p><img src="https://img-blog.csdnimg.cn/20190805112221405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#top">返回顶部</a></p>
<h1 id="3-逆置链表"><a href="#3-逆置链表" class="headerlink" title="3.逆置链表"></a>3.逆置链表</h1><h2 id="第一种策略（三指针）："><a href="#第一种策略（三指针）：" class="headerlink" title="第一种策略（三指针）："></a>第一种策略（三指针）：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">       ListNode pre &#x3D; null;</span><br><span class="line">       ListNode current &#x3D; head;</span><br><span class="line"></span><br><span class="line">       while(current!&#x3D;null)&#123;</span><br><span class="line">           ListNode next &#x3D; current.next;</span><br><span class="line">           current.next &#x3D; pre;</span><br><span class="line">           pre &#x3D; current;</span><br><span class="line">           current &#x3D; next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二种策略（递归）："><a href="#第二种策略（递归）：" class="headerlink" title="第二种策略（递归）："></a>第二种策略（递归）：</h2><p>总是做相同的事，就可以考虑递归的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PNODE re_list(NODE *node) &#123;      &#x2F;&#x2F;递归       </span><br><span class="line">    if (node &#x3D;&#x3D; NULL|| node-&gt;next &#x3D;&#x3D; NULL)  return node;  </span><br><span class="line">    else&#123;     </span><br><span class="line">        NODE *head &#x3D; re_list(node-&gt;next);  &#x2F;&#x2F;一直到最后一个，head为最后一个的引用，下面的语句反向 </span><br><span class="line">        node-&gt;next-&gt;next &#x3D; node;  </span><br><span class="line">        node-&gt;next &#x3D; NULL;  		&#x2F;&#x2F;逆置后的最后一个指向空 </span><br><span class="line">        return head;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LinkListReverse2(PNODE &amp;pHead)&#123;			&#x2F;&#x2F;逆置链表 </span><br><span class="line">    if (pHead &#x3D;&#x3D; NULL || pHead-&gt;next &#x3D;&#x3D; NULL)&#123;  </span><br><span class="line">        return ;  </span><br><span class="line">    &#125;  </span><br><span class="line">	NODE *tmp &#x3D; re_list(pHead); </span><br><span class="line">    pHead &#x3D; tmp;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><a href="#top">返回顶部</a></p>
<h1 id="4-合并两个链表"><a href="#4-合并两个链表" class="headerlink" title="4. 合并两个链表"></a>4. 合并两个链表</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode head &#x3D; new ListNode(-1);</span><br><span class="line">        ListNode p &#x3D; head;</span><br><span class="line">        while(l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null) &#123;</span><br><span class="line">            if (l1.val &lt; l2.val) &#123;</span><br><span class="line">                p.next &#x3D; l1;</span><br><span class="line">                l1 &#x3D; l1.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                p.next &#x3D; l2;</span><br><span class="line">                l2 &#x3D; l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p &#x3D; p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (l1 !&#x3D; null) &#123;</span><br><span class="line">            p.next &#x3D; l1;</span><br><span class="line">        &#125; else if (l2 !&#x3D; null) &#123;</span><br><span class="line">            p.next &#x3D; l2;</span><br><span class="line">        &#125;</span><br><span class="line">        return head.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-合并n个链表-分治法"><a href="#4-合并n个链表-分治法" class="headerlink" title="4. 合并n个链表(分治法)"></a>4. 合并n个链表(分治法)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class="line">       int len &#x3D; lists.length;</span><br><span class="line">       if (len &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;    </span><br><span class="line">       &#x2F;&#x2F; 将n个链表以中间为对称，两两合并 </span><br><span class="line">       while(len&gt;1) &#123;</span><br><span class="line">           for (int i&#x3D;0; i&lt;len&#x2F;2; i++) &#123;</span><br><span class="line">               lists[i] &#x3D; mergeTwoLists(lists[i], lists[len-1-i]);</span><br><span class="line">           &#125;</span><br><span class="line">           len &#x3D; (len+1)&#x2F;2;</span><br><span class="line">       &#125;</span><br><span class="line">       return lists[0];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt; </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Node&#x2F;&#x2F;结点</span><br><span class="line">&#123;</span><br><span class="line">	int data;&#x2F;&#x2F;数据域</span><br><span class="line">	struct Node *next;&#x2F;&#x2F;指针域</span><br><span class="line">&#125;NODE, *PNODE;&#x2F;&#x2F;NODE等价于struct Student st||PNODE等价于struct Node *next</span><br><span class="line"></span><br><span class="line">PNODE InputStudent(void)</span><br><span class="line">&#123;</span><br><span class="line">	int len;</span><br><span class="line">	NODE stu;</span><br><span class="line">	PNODE pHead &#x3D; (PNODE)malloc(sizeof(NODE));&#x2F;&#x2F;定义一个头结点并且为头结点分配内存</span><br><span class="line">	if(NULL &#x3D;&#x3D; pHead)	&#x2F;&#x2F;判断内存是否为空</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;内存分配失败,程序终止!\n&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line">	PNODE pTail &#x3D; pHead;&#x2F;&#x2F;定义一个指向头结点的指针</span><br><span class="line">	pTail-&gt;next &#x3D; NULL;&#x2F;&#x2F;清空指针域</span><br><span class="line">	printf(&quot;请输入个数:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;len);</span><br><span class="line">	for(int i&#x3D;0; i&lt;len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;请输入第%d个:\n&quot;, i+1);</span><br><span class="line">		cin&gt;&gt;stu.data;</span><br><span class="line"></span><br><span class="line">		PNODE pNew &#x3D; (PNODE)malloc(sizeof(NODE));	&#x2F;&#x2F;为新节点分配内存</span><br><span class="line">		if(NULL &#x3D;&#x3D; pNew)	&#x2F;&#x2F;判断内存是否为空</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;内存分配失败,程序终止!\n&quot;);</span><br><span class="line">			exit(-1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pNew-&gt;data &#x3D; stu.data;&#x2F;&#x2F;初始化结点的数据域	</span><br><span class="line">		pTail-&gt;next &#x3D; pNew;&#x2F;&#x2F;将新结点挂到老结点后</span><br><span class="line">		pNew-&gt;next &#x3D; NULL;&#x2F;&#x2F;清空新结点的指针域</span><br><span class="line">		pTail &#x3D; pNew;&#x2F;&#x2F;将pTail移到新结点上</span><br><span class="line">	&#125;</span><br><span class="line">	return pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OutputStudent(PNODE pHead)&#x2F;&#x2F;输出链表</span><br><span class="line">&#123;</span><br><span class="line">	PNODE p &#x3D; pHead-&gt;next;&#x2F;&#x2F;定义一个指针用于遍历</span><br><span class="line">	printf(&quot;\n数据如下:\n&quot;);	</span><br><span class="line">	while(NULL !&#x3D; p)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d &quot;, p-&gt;data);</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DeleteEqual(PNODE &amp;pHead)&#123;		&#x2F;&#x2F;删除链表中的重复元素</span><br><span class="line">	PNODE p,q,prev;</span><br><span class="line">	if (p&#x3D;pHead-&gt;next)&#123;</span><br><span class="line">		prev&#x3D;p;</span><br><span class="line">		p&#x3D;p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	while (p)&#123;</span><br><span class="line">		if (p-&gt;data&#x3D;&#x3D;prev-&gt;data)&#123;</span><br><span class="line">			q&#x3D;p;</span><br><span class="line">			p&#x3D;p-&gt;next;</span><br><span class="line">			prev-&gt;next&#x3D;p;</span><br><span class="line">			free(q);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			prev&#x3D;p;</span><br><span class="line">			p&#x3D;p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DeleteSelect(PNODE &amp;pHead,int min,int max)&#123;		&#x2F;&#x2F;删除递增有序链表中大于min，小于max的元素</span><br><span class="line">	</span><br><span class="line">	PNODE p&#x3D;pHead,minPrev,maxPrev;</span><br><span class="line">	 	</span><br><span class="line">	int flag&#x3D;0;</span><br><span class="line">	while (p-&gt;next)&#123;</span><br><span class="line">		if(p-&gt;next-&gt;data&gt;min&amp;&amp;!flag)&#123;</span><br><span class="line">			minPrev&#x3D;p;</span><br><span class="line">			flag&#x3D;1;	</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		if(p-&gt;next-&gt;data&gt;&#x3D;max)&#123;</span><br><span class="line">			maxPrev&#x3D;p;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		p&#x3D;p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	PNODE temp,start;</span><br><span class="line">	start&#x3D;minPrev-&gt;next;</span><br><span class="line">	while(start-&gt;data!&#x3D;maxPrev-&gt;data)&#123;</span><br><span class="line">		temp&#x3D;start;</span><br><span class="line">		start&#x3D;start-&gt;next;</span><br><span class="line">		free(temp);</span><br><span class="line">		temp&#x3D;NULL; </span><br><span class="line">	&#125;</span><br><span class="line">	minPrev-&gt;next&#x3D;maxPrev-&gt;next;</span><br><span class="line">	free(maxPrev);</span><br><span class="line">	maxPrev&#x3D;NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LinkListReverse(PNODE &amp;L)&#123;			&#x2F;&#x2F;逆置链表 </span><br><span class="line">	PNODE pre,current,nextNode;			&#x2F;&#x2F;三个指针维持实现逆置 </span><br><span class="line">	pre&#x3D;L-&gt;next;</span><br><span class="line">	current&#x3D;pre-&gt;next;</span><br><span class="line">	nextNode&#x3D;current-&gt;next;</span><br><span class="line">	pre-&gt;next&#x3D;NULL;						&#x2F;&#x2F;逆置之后为最后一个 </span><br><span class="line">	</span><br><span class="line">	while(nextNode-&gt;next)&#123;				&#x2F;&#x2F;三指针依次后移实现逆置 </span><br><span class="line">		current-&gt;next&#x3D;pre;</span><br><span class="line">		pre&#x3D;current;</span><br><span class="line">		current&#x3D;nextNode;</span><br><span class="line">		nextNode&#x3D;nextNode-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;循环出来后，最后的指针逆置 </span><br><span class="line">	current-&gt;next&#x3D;pre;</span><br><span class="line">	nextNode-&gt;next&#x3D;current;</span><br><span class="line">	L-&gt;next&#x3D;nextNode;					&#x2F;&#x2F;头结点放上就行了 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PNODE re_list(NODE *node) &#123;      &#x2F;&#x2F;递归       </span><br><span class="line">    if (node &#x3D;&#x3D; NULL|| node-&gt;next &#x3D;&#x3D; NULL)  return node;  </span><br><span class="line">    else&#123;     </span><br><span class="line">        NODE *head &#x3D; re_list(node-&gt;next);  &#x2F;&#x2F;一直到最后一个，head为最后一个的引用，下面的语句反向 </span><br><span class="line">        node-&gt;next-&gt;next &#x3D; node;  </span><br><span class="line">        node-&gt;next &#x3D; NULL;  		&#x2F;&#x2F;逆置后的最后一个指向空 </span><br><span class="line">        return head;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LinkListReverse2(PNODE &amp;pHead)&#123;			&#x2F;&#x2F;逆置链表 </span><br><span class="line">    if (pHead &#x3D;&#x3D; NULL || pHead-&gt;next &#x3D;&#x3D; NULL)&#123;  </span><br><span class="line">        return ;  </span><br><span class="line">    &#125;  </span><br><span class="line">	NODE *tmp &#x3D; re_list(pHead); </span><br><span class="line">    pHead &#x3D; tmp;   </span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	PNODE L&#x3D; InputStudent();</span><br><span class="line">	cout&lt;&lt;endl&lt;&lt;&quot;输入的数据如下:&quot;;</span><br><span class="line">	OutputStudent(L);</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;	DeleteEqual(L);</span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;endl&lt;&lt;&quot;删除后:&quot;;</span><br><span class="line">&#x2F;&#x2F;	OutputStudent(L);</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;	LinkListReverse2(L-&gt;next);</span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;endl&lt;&lt;&quot;逆置后:&quot;;</span><br><span class="line">&#x2F;&#x2F;	OutputStudent(L);</span><br><span class="line"></span><br><span class="line">	DeleteSelect(L,2,10);</span><br><span class="line">	cout&lt;&lt;endl&lt;&lt;&quot;删除后:&quot;;</span><br><span class="line">	OutputStudent(L);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">返回顶部</a></p>
]]></content>
      <tags>
        <tag>链表题目</tag>
      </tags>
  </entry>
  <entry>
    <title>有序链表的合并</title>
    <url>/2019/08/03/%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看了网上人家写的，自己拿来用一用，效果不如意，有的管都不管直接将链表2接在链表1之后，有的虽然有比较一下链表1与2的元素大小，在进行链接，但运行后有bug。自己写了一下，大概就两种策略：</p>
<ul>
<li><h1 id="需要第三方"><a href="#需要第三方" class="headerlink" title="需要第三方"></a>需要第三方</h1><p>  这种比较好理解，就是从链表1与2中依次拿过来重新组织。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void MergerList(PNODE &amp;LA,PNODE &amp;LB,PNODE &amp;LC)&#123;</span><br><span class="line">	OutputStudent(LA);</span><br><span class="line">	OutputStudent(LB);</span><br><span class="line">	</span><br><span class="line">	NODE *pa,*pb,*pc;		&#x2F;&#x2F; pa指向LA,pb指向LB,pc指向LC;</span><br><span class="line">	pa&#x3D;LA-&gt;next;</span><br><span class="line">	pb&#x3D;LB-&gt;next;</span><br><span class="line">	LC&#x3D;LA;</span><br><span class="line">	pc&#x3D;LC;						&#x2F;&#x2F;pc指向LC头指针 </span><br><span class="line">	while(pa&amp;&amp;pb)&#123;</span><br><span class="line">		if(pa-&gt;data&lt;&#x3D;pb-&gt;data)&#123;</span><br><span class="line">			pc-&gt;next&#x3D;pa;</span><br><span class="line">			pc&#x3D;pa;				&#x2F;&#x2F;更新pc的指向 </span><br><span class="line">			pa&#x3D;pa-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			pc-&gt;next&#x3D;pb;</span><br><span class="line">			pc&#x3D;pb;</span><br><span class="line">			pb&#x3D;pb-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pc-&gt;next&#x3D;pa?pa:pb;</span><br><span class="line">	delete LB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p>  <img src="https://img-blog.csdnimg.cn/20190803102330189.png" alt="在这里插入图片描述"></p>
</li>
<li><h1 id="将链表2插在链表1合适位置"><a href="#将链表2插在链表1合适位置" class="headerlink" title="将链表2插在链表1合适位置"></a>将链表2插在链表1合适位置</h1><p>  这个网上大多数也是让下面q指向A链表第一个结点，调试时你会发现如果B第一个结点比A的小，此时q又指着A的第一个结点，B怎么插在A前面。<br>  所以这里A链表只要头结点，然后依次将B插进来。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PNODE GuiblingList(PNODE A,PNODE B)&#123;</span><br><span class="line">	OutputStudent(A);</span><br><span class="line">	OutputStudent(B);</span><br><span class="line">	</span><br><span class="line">	NODE *p,*q,*r;		&#x2F;&#x2F; p指向A,q指向B;</span><br><span class="line">	q&#x3D;A;</span><br><span class="line">	p&#x3D;B-&gt;next;</span><br><span class="line">		</span><br><span class="line">	while(p)&#123;		</span><br><span class="line">		while((q-&gt;next)&amp;&amp;(q-&gt;next-&gt;data&lt;p-&gt;data))&#123;</span><br><span class="line">			q&#x3D;q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		r&#x3D;p;</span><br><span class="line">		p&#x3D;p-&gt;next;</span><br><span class="line">		r-&gt;next&#x3D;q-&gt;next;</span><br><span class="line">		q-&gt;next&#x3D;r;		</span><br><span class="line">	&#125;</span><br><span class="line">	return A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果：-1"><a href="#运行结果：-1" class="headerlink" title="运行结果："></a>运行结果：</h2><p>  <img src="https://img-blog.csdnimg.cn/20190803102547790.png" alt="在这里插入图片描述"></p>
<h1 id="总的代码："><a href="#总的代码：" class="headerlink" title="总的代码："></a>总的代码：</h1></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt; </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct Node&#x2F;&#x2F;结点</span><br><span class="line">&#123;</span><br><span class="line">	int data;&#x2F;&#x2F;数据域</span><br><span class="line">	struct Node *next;&#x2F;&#x2F;指针域</span><br><span class="line">&#125;NODE, *PNODE;&#x2F;&#x2F;NODE等价于struct Student st||PNODE等价于struct Node *next</span><br><span class="line"></span><br><span class="line">PNODE InputStudent(void)</span><br><span class="line">&#123;</span><br><span class="line">	int len;&#x2F;&#x2F;学生的人数</span><br><span class="line">	NODE stu;</span><br><span class="line">	PNODE pHead &#x3D; (PNODE)malloc(sizeof(NODE));&#x2F;&#x2F;定义一个头结点并且为头结点分配内存</span><br><span class="line">	if(NULL &#x3D;&#x3D; pHead)	&#x2F;&#x2F;判断内存是否为空</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;内存分配失败,程序终止!\n&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line">	PNODE pTail &#x3D; pHead;&#x2F;&#x2F;定义一个指向头结点的指针</span><br><span class="line">	pTail-&gt;next &#x3D; NULL;&#x2F;&#x2F;清空指针域</span><br><span class="line">	printf(&quot;请输入个数:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;len);</span><br><span class="line">	for(int i&#x3D;0; i&lt;len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;请输入第%d个:\n&quot;, i+1);</span><br><span class="line">		cin&gt;&gt;stu.data;</span><br><span class="line"></span><br><span class="line">		PNODE pNew &#x3D; (PNODE)malloc(sizeof(NODE));	&#x2F;&#x2F;为新节点分配内存</span><br><span class="line">		if(NULL &#x3D;&#x3D; pNew)	&#x2F;&#x2F;判断内存是否为空</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;内存分配失败,程序终止!\n&quot;);</span><br><span class="line">			exit(-1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pNew-&gt;data &#x3D; stu.data;&#x2F;&#x2F;初始化结点的数据域	</span><br><span class="line">		pTail-&gt;next &#x3D; pNew;&#x2F;&#x2F;将新结点挂到老结点后</span><br><span class="line">		pNew-&gt;next &#x3D; NULL;&#x2F;&#x2F;清空新结点的指针域</span><br><span class="line">		pTail &#x3D; pNew;&#x2F;&#x2F;将pTail移到新结点上</span><br><span class="line">	&#125;</span><br><span class="line">	return pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OutputStudent(PNODE pHead)&#x2F;&#x2F;输出学生信息</span><br><span class="line">&#123;</span><br><span class="line">	PNODE p &#x3D; pHead-&gt;next;&#x2F;&#x2F;定义一个指针用于遍历学生信息</span><br><span class="line">	printf(&quot;\n数据如下:\n&quot;);	</span><br><span class="line">	while(NULL !&#x3D; p)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d &quot;, p-&gt;data);</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MergerList(PNODE &amp;LA,PNODE &amp;LB,PNODE &amp;LC)&#123;</span><br><span class="line">	OutputStudent(LA);</span><br><span class="line">	OutputStudent(LB);</span><br><span class="line">	</span><br><span class="line">	NODE *pa,*pb,*pc;		&#x2F;&#x2F; pa指向LA,pb指向LB,pc指向LC;</span><br><span class="line">	pa&#x3D;LA-&gt;next;</span><br><span class="line">	pb&#x3D;LB-&gt;next;</span><br><span class="line">	LC&#x3D;LA;</span><br><span class="line">	pc&#x3D;LC;						&#x2F;&#x2F;pc指向LC头指针 </span><br><span class="line">	while(pa&amp;&amp;pb)&#123;</span><br><span class="line">		if(pa-&gt;data&lt;&#x3D;pb-&gt;data)&#123;</span><br><span class="line">			pc-&gt;next&#x3D;pa;</span><br><span class="line">			pc&#x3D;pa;				&#x2F;&#x2F;更新pc的指向 </span><br><span class="line">			pa&#x3D;pa-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			pc-&gt;next&#x3D;pb;</span><br><span class="line">			pc&#x3D;pb;</span><br><span class="line">			pb&#x3D;pb-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pc-&gt;next&#x3D;pa?pa:pb;</span><br><span class="line">	delete LB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PNODE GuiblingList(PNODE A,PNODE B)&#123;</span><br><span class="line">	OutputStudent(A);</span><br><span class="line">	OutputStudent(B);</span><br><span class="line">	</span><br><span class="line">	NODE *p,*q,*r;		&#x2F;&#x2F; p指向A,q指向B;</span><br><span class="line">	q&#x3D;A;</span><br><span class="line">	p&#x3D;B-&gt;next;</span><br><span class="line">		</span><br><span class="line">	while(p)&#123;		</span><br><span class="line">		while((q-&gt;next)&amp;&amp;(q-&gt;next-&gt;data&lt;p-&gt;data))&#123;</span><br><span class="line">			q&#x3D;q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		r&#x3D;p;</span><br><span class="line">		p&#x3D;p-&gt;next;</span><br><span class="line">		r-&gt;next&#x3D;q-&gt;next;</span><br><span class="line">		q-&gt;next&#x3D;r;		</span><br><span class="line">	&#125;</span><br><span class="line">	return A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	PNODE LA&#x3D; InputStudent();</span><br><span class="line">	PNODE LB&#x3D; InputStudent();</span><br><span class="line">	PNODE LC;</span><br><span class="line">	</span><br><span class="line">	LC&#x3D;GuiblingList(LA,LB);</span><br><span class="line">	OutputStudent(LC);</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;	MergerList(LA,LB,LC);</span><br><span class="line">&#x2F;&#x2F;	OutputStudent(LC);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>有序链表的合并</tag>
      </tags>
  </entry>
  <entry>
    <title>B-树</title>
    <url>/2019/07/26/B-%E6%A0%91/</url>
    <content><![CDATA[<body>
<div id="top"></div>
</body>


<h1 id="B-树的定义"><a href="#B-树的定义" class="headerlink" title="B-树的定义"></a>B-树的定义</h1><p>一颗m阶B树，或为空树，或为满足下列特性的m叉树： </p>
<ol>
<li>树中每个结点最多含有m棵子树; </li>
<li>若根结点不是叶子结点，则至少有两颗子树;  </li>
<li>除根之外的所有非终端结点至少有 ⌈m/2⌉ 棵子树 ; </li>
<li>所有的叶子结点都出现在同一层次上，并且不带信息，通常称为失败结点。失败结点不存在，指向这些结点的指针为空。引入失败结点是为了便于分析B-树的查找性能。</li>
<li>结点的结构如下：<pre><code> （n，P~0~，K~1~，P~1~，K~2~，P~2~，…，K~n~，P~n~)</code></pre>
 其中<br> ①K<del>i</del>（1≤i≤n）为关键字，且关键字按升序排序。<br> ②指针P<del>i</del>（0≤i≤n）指向子树的根结点。P<del>i-1</del>相当于指向K<del>i</del>的“左子树”，P<del>i</del>相当                于指向K<del>i</del>的“右子树”。<br> ③关键字的个数n必须满足：⌈m/2⌉-1≤n≤m-1 </li>
<li>从上述定义可以看出，B-树具有平衡、有序、多路的特点。</li>
</ol>
<h1 id="B-树的存储结构"><a href="#B-树的存储结构" class="headerlink" title="B-树的存储结构"></a>B-树的存储结构</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct node&#123;                &#x2F;&#x2F;B树存储结构 </span><br><span class="line">    int keynum;                     &#x2F;&#x2F;结点关键字个数</span><br><span class="line">    KeyType key[m+1];               &#x2F;&#x2F;关键字数组，key[0]未使用 </span><br><span class="line">    struct node *parent;            &#x2F;&#x2F;双亲结点指针</span><br><span class="line">    struct node *ptr[m+1];         	&#x2F;&#x2F;孩子结点指针数组 </span><br><span class="line">&#125;BTNode,*BTree;</span><br></pre></td></tr></table></figure>
<h1 id="B-树的查找"><a href="#B-树的查找" class="headerlink" title="B-树的查找"></a>B-树的查找</h1><p>在B-树上的查找，是一个顺指针查找结点（与二叉树的查找一样），然后在结点查找关键字的过程。</p>
<ul>
<li><p><strong>查找结果类型定义：</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;                   </span><br><span class="line">    BTNode *pt;                     &#x2F;&#x2F;指向找到的结点</span><br><span class="line">    int i;                          &#x2F;&#x2F;在结点中的关键字位置; </span><br><span class="line">    int tag;                        &#x2F;&#x2F;查找成功与否标志</span><br><span class="line">&#125;Result;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>查找</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">	在树t上查找关键字k,返回结果(pt,i,tag)。</span><br><span class="line">	若查找成功,则特征值tag&#x3D;1,关键字k是指针pt所指结点中第i个关键字</span><br><span class="line">	否则特征值tag&#x3D;0,关键字k的插入在pt所指结点的第i个和第i+1个关键字之间</span><br><span class="line">*&#x2F;</span><br><span class="line">Result SearchBTree(BTree t,KeyType k)&#123;</span><br><span class="line"></span><br><span class="line">    BTNode *p&#x3D;t,*q&#x3D;NULL;                            &#x2F;&#x2F;初始化结点p和结点q,p指向待查结点,q指向p的双亲</span><br><span class="line">    int found&#x3D;FALSE;                                &#x2F;&#x2F;设定查找成功与否标志 </span><br><span class="line">    int i&#x3D;0;                 </span><br><span class="line">    Result r;                                       &#x2F;&#x2F;设定返回的查找结果 </span><br><span class="line"></span><br><span class="line">    while(p&amp;&amp;!found)&#123;</span><br><span class="line">        i&#x3D;SearchBTNode(p,k);                        &#x2F;&#x2F;在结点p中查找关键字k,使得p-&gt;key[i]&lt;&#x3D;k&lt;p-&gt;key[i+1]</span><br><span class="line">        if(i&gt;0&amp;&amp;p-&gt;key[i]&#x3D;&#x3D;k)                       &#x2F;&#x2F;找到待查关键字</span><br><span class="line">            found&#x3D;OK;                            &#x2F;&#x2F;查找成功 </span><br><span class="line">        else&#123;                                       &#x2F;&#x2F;查找失败 </span><br><span class="line">            q&#x3D;p;                            </span><br><span class="line">            p&#x3D;p-&gt;ptr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(found)&#123;                               &#x2F;&#x2F;查找成功</span><br><span class="line">        r.pt&#x3D;p;</span><br><span class="line">        r.i&#x3D;i;</span><br><span class="line">        r.tag&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;                                           &#x2F;&#x2F;查找失败</span><br><span class="line">        r.pt&#x3D;q;</span><br><span class="line">        r.i&#x3D;i;</span><br><span class="line">        r.tag&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;                                       &#x2F;&#x2F;返回关键字k的位置(或插入位置)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">返回顶部</a></p>
</li>
</ul>
<h1 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B-树的插入"></a>B-树的插入</h1><p>插入26时，d结点引起分裂。<br>插入85时，g结点引起分裂，继而引起e结点分裂。<br>最后插入7时，先引起c结点分裂，继而引起b结点分裂，又引起a结点分裂。树的深度加一。</p>
<p><img src="https://img-blog.csdnimg.cn/20190726101419830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">	在树t上结点q的key[i]与key[i+1]之间插入关键字k。</span><br><span class="line">	若引起结点过大,则沿双亲链进行必要的结点分裂调整</span><br><span class="line">	使t仍是B树</span><br><span class="line">*&#x2F;</span><br><span class="line">void InsertBTree(BTree &amp;t,int i,KeyType k,BTree p)&#123;</span><br><span class="line">    BTNode *q;</span><br><span class="line">    int finished,newroot_tag,s;                   &#x2F;&#x2F;设定需要新结点标志和插入完成标志 </span><br><span class="line">    KeyType x;</span><br><span class="line">    if(p&#x3D;&#x3D;NULL)                                     &#x2F;&#x2F;t是空树</span><br><span class="line">        NewRoot(t,k,NULL,NULL);                     &#x2F;&#x2F;生成仅含关键字k的根结点t</span><br><span class="line">    else&#123;</span><br><span class="line">        x&#x3D;k;</span><br><span class="line">        q&#x3D;NULL;</span><br><span class="line">        finished&#x3D;FALSE;       </span><br><span class="line">        newroot_tag&#x3D;FALSE;</span><br><span class="line">        while(!finished&amp;&amp;!newroot_tag)&#123;</span><br><span class="line">            InsertBTNode(p,i,x,q);                  &#x2F;&#x2F;将关键字x和结点q分别插入到p-&gt;key[i+1]和p-&gt;ptr[i+1]</span><br><span class="line">            if (p-&gt;keynum&lt;&#x3D;Max) </span><br><span class="line">                finished&#x3D;OK;                       &#x2F;&#x2F;插入完成</span><br><span class="line">            else&#123;         </span><br><span class="line">                s&#x3D;(m+1)&#x2F;2;</span><br><span class="line">                SplitBTNode(p,q);                   &#x2F;&#x2F;分裂结点 </span><br><span class="line">                x&#x3D;p-&gt;key[s];</span><br><span class="line">                if(p-&gt;parent)&#123;                      &#x2F;&#x2F;查找x的插入位置</span><br><span class="line">                    p&#x3D;p-&gt;parent;</span><br><span class="line">                    i&#x3D;SearchBTNode(p, x);</span><br><span class="line">                &#125;</span><br><span class="line">                else                                &#x2F;&#x2F;没找到x，需要新结点 </span><br><span class="line">                    newroot_tag&#x3D;OK;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(newroot_tag&#x3D;&#x3D;OK)                          &#x2F;&#x2F;根结点已分裂为结点p和q </span><br><span class="line">            NewRoot(t,x,p,q);                       &#x2F;&#x2F;生成新根结点t,p和q为子树指针</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="#top">返回顶部</a></p>
<h1 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B-树的删除"></a>B-树的删除</h1><p>B-树的删除有点复杂，主要就是涉及到删除元素后，要调整树使得还是B-树。关键就是使得：关键字的个数n必须满足：⌈m/2⌉-1≤n≤m-1<br>第一种，删除12，只需删除关键字和相应指针，树的其它部分不变。<br><img src="https://img-blog.csdnimg.cn/20190726104421673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第二种，删除上图中的50，因为它的有兄弟结点中的关键字个数大于 ⌈m/2⌉-1，可以拿走一个，需要做如下调整：<br><img src="https://img-blog.csdnimg.cn/20190726104857531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第三种，删除上图中的53，因为它的有兄弟结点中的关键字个数不大于 ⌈m/2⌉-1，不能再拿了，只能合并了，需要做如下调整：<br><img src="https://img-blog.csdnimg.cn/20190726105334183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int BTNodeDelete(BTree p,KeyType k)&#123;</span><br><span class="line">&#x2F;&#x2F;在结点p中查找并删除关键字k</span><br><span class="line">    int i;</span><br><span class="line">    int found;                                  &#x2F;&#x2F;查找标志 </span><br><span class="line">    if(p&#x3D;&#x3D;NULL)                                     </span><br><span class="line">        return 0;</span><br><span class="line">    else&#123;</span><br><span class="line">        found&#x3D;FindBTNode(p,k,i);                &#x2F;&#x2F;返回查找结果 </span><br><span class="line">        if(found)&#123;                           &#x2F;&#x2F;查找成功 </span><br><span class="line">            if(p-&gt;ptr[i-1]!&#x3D;NULL)&#123;                  &#x2F;&#x2F;删除的是非叶子结点</span><br><span class="line">                Substitution(p,i);                  &#x2F;&#x2F;寻找相邻关键字(右子树中最小的关键字) </span><br><span class="line">                BTNodeDelete(p-&gt;ptr[i],p-&gt;key[i]);  &#x2F;&#x2F;执行删除操作 </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                Remove(p,i);                        &#x2F;&#x2F;从结点p中位置i处删除关键字</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            found&#x3D;BTNodeDelete(p-&gt;ptr[i],k);    &#x2F;&#x2F;沿孩子结点递归查找并删除关键字k</span><br><span class="line">        if(p-&gt;ptr[i]!&#x3D;NULL)</span><br><span class="line">            if(p-&gt;ptr[i]-&gt;keynum&lt;Min)               &#x2F;&#x2F;删除后关键字个数小于MIN</span><br><span class="line">                AdjustBTree(p,i);                   &#x2F;&#x2F;调整B树 </span><br><span class="line">        return found;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="#top">返回顶部</a></p>
<h1 id="总的代码："><a href="#总的代码：" class="headerlink" title="总的代码："></a>总的代码：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt; </span><br><span class="line"></span><br><span class="line">#define OK 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define MAXM 10                     &#x2F;&#x2F;定义B树的最大的阶数</span><br><span class="line"></span><br><span class="line">const int m&#x3D;3;                      &#x2F;&#x2F;设定B树的阶数 </span><br><span class="line">const int Max&#x3D;m-1;                  &#x2F;&#x2F;结点的最大关键字数量 </span><br><span class="line">const int Min&#x3D;(m-1)&#x2F;2;              &#x2F;&#x2F;结点的最小关键字数量 </span><br><span class="line"></span><br><span class="line">typedef int KeyType;                &#x2F;&#x2F;KeyType为关键字类型</span><br><span class="line"></span><br><span class="line">typedef struct node&#123;                &#x2F;&#x2F;B树存储结构 </span><br><span class="line">    int keynum;                     &#x2F;&#x2F;结点关键字个数</span><br><span class="line">    KeyType key[m+1];               &#x2F;&#x2F;关键字数组，key[0]未使用 </span><br><span class="line">    struct node *parent;            &#x2F;&#x2F;双亲结点指针</span><br><span class="line">    struct node *ptr[m+1];         	&#x2F;&#x2F;孩子结点指针数组 </span><br><span class="line">&#125;BTNode,*BTree;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;                   </span><br><span class="line">    BTNode *pt;                     &#x2F;&#x2F;指向找到的结点</span><br><span class="line">    int i;                          &#x2F;&#x2F;在结点中的关键字位置; </span><br><span class="line">    int tag;                        &#x2F;&#x2F;查找成功与否标志</span><br><span class="line">&#125;Result;</span><br><span class="line"></span><br><span class="line">int InitBTree(BTree &amp;t)&#123;			&#x2F;&#x2F;初始化B树 </span><br><span class="line">    t&#x3D;NULL;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int SearchBTNode(BTree p,KeyType k)&#123;		&#x2F;&#x2F;在结点p中查找关键字k的插入位置i </span><br><span class="line">    int i&#x3D;0;</span><br><span class="line">    for(i&#x3D;0;i&lt;p-&gt;keynum&amp;&amp;p-&gt;key[i+1]&lt;&#x3D;k;i++);</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">	在树t上查找关键字k,返回结果(pt,i,tag)。</span><br><span class="line">	若查找成功,则特征值tag&#x3D;1,关键字k是指针pt所指结点中第i个关键字</span><br><span class="line">	否则特征值tag&#x3D;0,关键字k的插入位置为pt结点的第i个</span><br><span class="line">*&#x2F;</span><br><span class="line">Result SearchBTree(BTree t,KeyType k)&#123;</span><br><span class="line"></span><br><span class="line">    BTree p&#x3D;t,q&#x3D;NULL;                            &#x2F;&#x2F;初始化结点p和结点q,p指向待查结点,q指向p的双亲</span><br><span class="line">    int found&#x3D;FALSE;                                &#x2F;&#x2F;设定查找成功与否标志 </span><br><span class="line">    int i&#x3D;0;                 </span><br><span class="line">    Result r;                                       &#x2F;&#x2F;设定返回的查找结果 </span><br><span class="line"></span><br><span class="line">    while(p&amp;&amp;!found)&#123;</span><br><span class="line">        i&#x3D;SearchBTNode(p,k);                        &#x2F;&#x2F;在结点p中查找关键字k,使得p-&gt;key[i]&lt;&#x3D;k&lt;p-&gt;key[i+1]</span><br><span class="line">        if(i&gt;0&amp;&amp;p-&gt;key[i]&#x3D;&#x3D;k)                       &#x2F;&#x2F;找到待查关键字</span><br><span class="line">            found&#x3D;OK;                            &#x2F;&#x2F;查找成功 </span><br><span class="line">        else&#123;                                       &#x2F;&#x2F;查找失败 </span><br><span class="line">            q&#x3D;p;                            </span><br><span class="line">            p&#x3D;p-&gt;ptr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(found)&#123;                               &#x2F;&#x2F;查找成功</span><br><span class="line">        r.pt&#x3D;p;</span><br><span class="line">        r.i&#x3D;i;</span><br><span class="line">        r.tag&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;                                           &#x2F;&#x2F;查找失败</span><br><span class="line">        r.pt&#x3D;q;</span><br><span class="line">        r.i&#x3D;i;</span><br><span class="line">        r.tag&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;                                       &#x2F;&#x2F;返回关键字k的位置(或插入位置)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InsertBTNode(BTree &amp;p,int i,KeyType k,BTree q)&#123;</span><br><span class="line">&#x2F;&#x2F;将关键字k和结点q分别插入到p-&gt;key[i+1]和p-&gt;ptr[i+1]中</span><br><span class="line">    int j;</span><br><span class="line">    for(j&#x3D;p-&gt;keynum;j&gt;i;j--)&#123;                       &#x2F;&#x2F;整体后移空出一个位置</span><br><span class="line">        p-&gt;key[j+1]&#x3D;p-&gt;key[j];</span><br><span class="line">        p-&gt;ptr[j+1]&#x3D;p-&gt;ptr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;key[i+1]&#x3D;k;</span><br><span class="line">    p-&gt;ptr[i+1]&#x3D;q;</span><br><span class="line">    if(q!&#x3D;NULL) </span><br><span class="line">        q-&gt;parent&#x3D;p;</span><br><span class="line">    p-&gt;keynum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void SplitBTNode(BTree &amp;p,BTree &amp;q)&#123;</span><br><span class="line">&#x2F;&#x2F;将结点p分裂成两个结点,前一半保留,后一半移入结点q</span><br><span class="line">    int i;</span><br><span class="line">    int s&#x3D;(m+1)&#x2F;2;</span><br><span class="line">    q&#x3D;(BTNode *)malloc(sizeof(BTNode));             &#x2F;&#x2F;给结点q分配空间</span><br><span class="line"></span><br><span class="line">    q-&gt;ptr[0]&#x3D;p-&gt;ptr[s];                            &#x2F;&#x2F;后一半移入结点q</span><br><span class="line">    for(i&#x3D;s+1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        q-&gt;key[i-s]&#x3D;p-&gt;key[i];</span><br><span class="line">        q-&gt;ptr[i-s]&#x3D;p-&gt;ptr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;keynum&#x3D;p-&gt;keynum-s;                </span><br><span class="line">    q-&gt;parent&#x3D;p-&gt;parent;</span><br><span class="line">    for(i&#x3D;0;i&lt;&#x3D;p-&gt;keynum-s;i++)                     &#x2F;&#x2F;修改双亲指针 </span><br><span class="line">        if(q-&gt;ptr[i]!&#x3D;NULL) </span><br><span class="line">            q-&gt;ptr[i]-&gt;parent&#x3D;q;</span><br><span class="line">    p-&gt;keynum&#x3D;s-1;                                  &#x2F;&#x2F;结点p的前一半保留,修改结点p的keynum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void NewRoot(BTree &amp;t,KeyType k,BTree p,BTree q)&#123;</span><br><span class="line">&#x2F;&#x2F;生成新的根结点t,原p和q为子树指针</span><br><span class="line">    t&#x3D;(BTNode *)malloc(sizeof(BTNode));             &#x2F;&#x2F;分配空间 </span><br><span class="line">    t-&gt;keynum&#x3D;1;</span><br><span class="line">    t-&gt;ptr[0]&#x3D;p;</span><br><span class="line">    t-&gt;ptr[1]&#x3D;q;</span><br><span class="line">    t-&gt;key[1]&#x3D;k;</span><br><span class="line">    if(p!&#x3D;NULL)                                     &#x2F;&#x2F;调整结点p和结点q的双亲指针 </span><br><span class="line">        p-&gt;parent&#x3D;t;</span><br><span class="line">    if(q!&#x3D;NULL) </span><br><span class="line">        q-&gt;parent&#x3D;t;</span><br><span class="line">    t-&gt;parent&#x3D;NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">	在树t上结点q的key[i]与key[i+1]之间插入关键字k。</span><br><span class="line">	若引起结点过大,则沿双亲链进行必要的结点分裂调整</span><br><span class="line">	使t仍是B树</span><br><span class="line">*&#x2F;</span><br><span class="line">void InsertBTree(BTree &amp;t,int i,KeyType k,BTree p)&#123;</span><br><span class="line">    BTNode *q;</span><br><span class="line">    int finished,newroot_tag,s;                   &#x2F;&#x2F;设定需要新结点标志和插入完成标志 </span><br><span class="line">    KeyType x;</span><br><span class="line">    if(p&#x3D;&#x3D;NULL)                                     &#x2F;&#x2F;t是空树</span><br><span class="line">        NewRoot(t,k,NULL,NULL);                     &#x2F;&#x2F;生成仅含关键字k的根结点t</span><br><span class="line">    else&#123;</span><br><span class="line">        x&#x3D;k;</span><br><span class="line">        q&#x3D;NULL;</span><br><span class="line">        finished&#x3D;FALSE;       </span><br><span class="line">        newroot_tag&#x3D;FALSE;</span><br><span class="line">        while(!finished&amp;&amp;!newroot_tag)&#123;</span><br><span class="line">            InsertBTNode(p,i,x,q);                  &#x2F;&#x2F;将关键字x和结点q分别插入到p-&gt;key[i+1]和p-&gt;ptr[i+1]</span><br><span class="line">            if (p-&gt;keynum&lt;&#x3D;Max) </span><br><span class="line">                finished&#x3D;OK;                       &#x2F;&#x2F;插入完成</span><br><span class="line">            else&#123;         </span><br><span class="line">                s&#x3D;(m+1)&#x2F;2;</span><br><span class="line">                SplitBTNode(p,q);                   &#x2F;&#x2F;分裂结点 </span><br><span class="line">                x&#x3D;p-&gt;key[s];</span><br><span class="line">                if(p-&gt;parent)&#123;                      &#x2F;&#x2F;查找x的插入位置</span><br><span class="line">                    p&#x3D;p-&gt;parent;</span><br><span class="line">                    i&#x3D;SearchBTNode(p, x);</span><br><span class="line">                &#125;</span><br><span class="line">                else                                &#x2F;&#x2F;没找到x，需要新结点 </span><br><span class="line">                    newroot_tag&#x3D;OK;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(newroot_tag&#x3D;&#x3D;OK)                          &#x2F;&#x2F;根结点已分裂为结点p和q </span><br><span class="line">            NewRoot(t,x,p,q);                       &#x2F;&#x2F;生成新根结点t,p和q为子树指针</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Remove(BTree p,int i)&#123;		&#x2F;&#x2F;从p结点删除key[i]和它的孩子指针ptr[i]</span><br><span class="line"></span><br><span class="line">    int j;</span><br><span class="line">    for(j&#x3D;i+1;j&lt;&#x3D;p-&gt;keynum;j++)&#123;                    &#x2F;&#x2F;前移删除key[i]和ptr[i]</span><br><span class="line">        p-&gt;key[j-1]&#x3D;p-&gt;key[j];</span><br><span class="line">        p-&gt;ptr[j-1]&#x3D;p-&gt;ptr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;keynum--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Substitution(BTree p,int i)&#123;</span><br><span class="line">&#x2F;&#x2F;查找被删关键字p-&gt;key[i](在非叶子结点中)的替代叶子结点(右子树中值最小的关键字) </span><br><span class="line">    BTNode *q;</span><br><span class="line">    for(q&#x3D;p-&gt;ptr[i];q-&gt;ptr[0]!&#x3D;NULL;q&#x3D;q-&gt;ptr[0]);</span><br><span class="line">    p-&gt;key[i]&#x3D;q-&gt;key[1];                            &#x2F;&#x2F;复制关键字值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void MoveRight(BTree p,int i)&#123;</span><br><span class="line">&#x2F;*将双亲结点p中的最后一个关键字移入右结点q中</span><br><span class="line">将左结点aq中的最后一个关键字移入双亲结点p中*&#x2F; </span><br><span class="line">    int j;</span><br><span class="line">    BTNode *q&#x3D;p-&gt;ptr[i];</span><br><span class="line">    BTNode *aq&#x3D;p-&gt;ptr[i-1];</span><br><span class="line"></span><br><span class="line">    for(j&#x3D;q-&gt;keynum;j&gt;0;j--)&#123;                       &#x2F;&#x2F;将右兄弟q中所有关键字向后移动一位</span><br><span class="line">        q-&gt;key[j+1]&#x3D;q-&gt;key[j];</span><br><span class="line">        q-&gt;ptr[j+1]&#x3D;q-&gt;ptr[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q-&gt;ptr[1]&#x3D;q-&gt;ptr[0];                            &#x2F;&#x2F;从双亲结点p移动关键字到右兄弟q中</span><br><span class="line">    q-&gt;key[1]&#x3D;p-&gt;key[i];</span><br><span class="line">    q-&gt;keynum++;</span><br><span class="line"></span><br><span class="line">    p-&gt;key[i]&#x3D;aq-&gt;key[aq-&gt;keynum];                  &#x2F;&#x2F;将左兄弟aq中最后一个关键字移动到双亲结点p中</span><br><span class="line">    p-&gt;ptr[i]-&gt;ptr[0]&#x3D;aq-&gt;ptr[aq-&gt;keynum];</span><br><span class="line">    aq-&gt;keynum--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void MoveLeft(BTree p,int i)&#123;</span><br><span class="line">&#x2F;*将双亲结点p中的第一个关键字移入左结点aq中，</span><br><span class="line">将右结点q中的第一个关键字移入双亲结点p中*&#x2F; </span><br><span class="line">    int j;</span><br><span class="line">    BTNode *aq&#x3D;p-&gt;ptr[i-1];</span><br><span class="line">    BTNode *q&#x3D;p-&gt;ptr[i];</span><br><span class="line"></span><br><span class="line">    aq-&gt;keynum++;                                   &#x2F;&#x2F;把双亲结点p中的关键字移动到左兄弟aq中</span><br><span class="line">    aq-&gt;key[aq-&gt;keynum]&#x3D;p-&gt;key[i]; </span><br><span class="line">    aq-&gt;ptr[aq-&gt;keynum]&#x3D;p-&gt;ptr[i]-&gt;ptr[0];</span><br><span class="line"></span><br><span class="line">    p-&gt;key[i]&#x3D;q-&gt;key[1];                            &#x2F;&#x2F;把右兄弟q中的关键字移动到双亲节点p中</span><br><span class="line">    q-&gt;ptr[0]&#x3D;q-&gt;ptr[1];</span><br><span class="line">    q-&gt;keynum--;</span><br><span class="line"></span><br><span class="line">    for(j&#x3D;1;j&lt;&#x3D;aq-&gt;keynum;j++)&#123;                     &#x2F;&#x2F;将右兄弟q中所有关键字向前移动一位</span><br><span class="line">        aq-&gt;key[j]&#x3D;aq-&gt;key[j+1];</span><br><span class="line">        aq-&gt;ptr[j]&#x3D;aq-&gt;ptr[j+1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Combine(BTree p,int i)&#123;</span><br><span class="line">&#x2F;*将双亲结点p、右结点q合并入左结点aq，</span><br><span class="line">并调整双亲结点p中的剩余关键字的位置*&#x2F; </span><br><span class="line">    int j;</span><br><span class="line">    BTNode *q&#x3D;p-&gt;ptr[i];                            </span><br><span class="line">    BTNode *aq&#x3D;p-&gt;ptr[i-1];</span><br><span class="line"></span><br><span class="line">    aq-&gt;keynum++;                                  &#x2F;&#x2F;将双亲结点的关键字p-&gt;key[i]插入到左结点aq     </span><br><span class="line">    aq-&gt;key[aq-&gt;keynum]&#x3D;p-&gt;key[i];</span><br><span class="line">    aq-&gt;ptr[aq-&gt;keynum]&#x3D;q-&gt;ptr[0];</span><br><span class="line"></span><br><span class="line">    for(j&#x3D;1;j&lt;&#x3D;q-&gt;keynum;j++)&#123;                      &#x2F;&#x2F;将右结点q中的所有关键字插入到左结点aq </span><br><span class="line">        aq-&gt;keynum++;</span><br><span class="line">        aq-&gt;key[aq-&gt;keynum]&#x3D;q-&gt;key[j];</span><br><span class="line">        aq-&gt;ptr[aq-&gt;keynum]&#x3D;q-&gt;ptr[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(j&#x3D;i;j&lt;p-&gt;keynum;j++)&#123;                       &#x2F;&#x2F;将双亲结点p中的p-&gt;key[i]后的所有关键字向前移动一位 </span><br><span class="line">        p-&gt;key[j]&#x3D;p-&gt;key[j+1];</span><br><span class="line">        p-&gt;ptr[j]&#x3D;p-&gt;ptr[j+1];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;keynum--;                                    &#x2F;&#x2F;修改双亲结点p的keynum值 </span><br><span class="line">    free(q);                                        &#x2F;&#x2F;释放空右结点q的空间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void AdjustBTree(BTree p,int i)&#123;</span><br><span class="line">&#x2F;&#x2F;删除结点p中的第i个关键字后,调整B树</span><br><span class="line">    if(i&#x3D;&#x3D;0)                                        &#x2F;&#x2F;删除的是最左边关键字</span><br><span class="line">        if(p-&gt;ptr[1]-&gt;keynum&gt;Min)                   &#x2F;&#x2F;右结点可以借</span><br><span class="line">            MoveLeft(p,1);</span><br><span class="line">        else                                        &#x2F;&#x2F;右兄弟不够借 </span><br><span class="line">            Combine(p,1);</span><br><span class="line">    else if(i&#x3D;&#x3D;p-&gt;keynum)                           &#x2F;&#x2F;删除的是最右边关键字</span><br><span class="line">        if(p-&gt;ptr[i-1]-&gt;keynum&gt;Min)                 &#x2F;&#x2F;左结点可以借 </span><br><span class="line">            MoveRight(p,i);</span><br><span class="line">        else                                        &#x2F;&#x2F;左结点不够借 </span><br><span class="line">            Combine(p,i);</span><br><span class="line">    else if(p-&gt;ptr[i-1]-&gt;keynum&gt;Min)                &#x2F;&#x2F;删除关键字在中部且左结点够借 </span><br><span class="line">        MoveRight(p,i);</span><br><span class="line">    else if(p-&gt;ptr[i+1]-&gt;keynum&gt;Min)                &#x2F;&#x2F;删除关键字在中部且右结点够借 </span><br><span class="line">        MoveLeft(p,i+1);</span><br><span class="line">    else                                            &#x2F;&#x2F;删除关键字在中部且左右结点都不够借</span><br><span class="line">        Combine(p,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int FindBTNode(BTree p,KeyType k,int &amp;i)&#123;</span><br><span class="line">&#x2F;&#x2F;反映是否在结点p中是否查找到关键字k </span><br><span class="line">    if(k&lt;p-&gt;key[1])&#123;                                &#x2F;&#x2F;结点p中查找关键字k失败 </span><br><span class="line">        i&#x3D;0;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;                                           &#x2F;&#x2F;在p结点中查找</span><br><span class="line">        i&#x3D;p-&gt;keynum;</span><br><span class="line">        while(k&lt;p-&gt;key[i]&amp;&amp;i&gt;1)</span><br><span class="line">            i--;</span><br><span class="line">        if(k&#x3D;&#x3D;p-&gt;key[i])                            &#x2F;&#x2F;结点p中查找关键字k成功 </span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int BTNodeDelete(BTree p,KeyType k)&#123;</span><br><span class="line">&#x2F;&#x2F;在结点p中查找并删除关键字k</span><br><span class="line">    int i;</span><br><span class="line">    int found_tag;                                  &#x2F;&#x2F;查找标志 </span><br><span class="line">    if(p&#x3D;&#x3D;NULL)                                     </span><br><span class="line">        return 0;</span><br><span class="line">    else&#123;</span><br><span class="line">        found_tag&#x3D;FindBTNode(p,k,i);                &#x2F;&#x2F;返回查找结果 </span><br><span class="line">        if(found_tag&#x3D;&#x3D;1)&#123;                           &#x2F;&#x2F;查找成功 </span><br><span class="line">            if(p-&gt;ptr[i-1]!&#x3D;NULL)&#123;                  &#x2F;&#x2F;删除的是非叶子结点</span><br><span class="line">                Substitution(p,i);                  &#x2F;&#x2F;寻找相邻关键字(右子树中最小的关键字) </span><br><span class="line">                BTNodeDelete(p-&gt;ptr[i],p-&gt;key[i]);  &#x2F;&#x2F;执行删除操作 </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                Remove(p,i);                        &#x2F;&#x2F;从结点p中位置i处删除关键字</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            found_tag&#x3D;BTNodeDelete(p-&gt;ptr[i],k);    &#x2F;&#x2F;沿孩子结点递归查找并删除关键字k</span><br><span class="line">        if(p-&gt;ptr[i]!&#x3D;NULL)</span><br><span class="line">            if(p-&gt;ptr[i]-&gt;keynum&lt;Min)               &#x2F;&#x2F;删除后关键字个数小于MIN</span><br><span class="line">                AdjustBTree(p,i);                   &#x2F;&#x2F;调整B树 </span><br><span class="line">        return found_tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void BTreeDelete(BTree &amp;t,KeyType k)&#123;</span><br><span class="line">&#x2F;&#x2F;构建删除框架，执行删除操作  </span><br><span class="line">    BTNode *p;</span><br><span class="line">    int a&#x3D;BTNodeDelete(t,k);                        &#x2F;&#x2F;删除关键字k </span><br><span class="line">    if(a&#x3D;&#x3D;0)                                        &#x2F;&#x2F;查找失败 </span><br><span class="line">        printf(&quot;   关键字%d不在B树中\n&quot;,k);</span><br><span class="line">    else if(t-&gt;keynum&#x3D;&#x3D;0)&#123;                          &#x2F;&#x2F;调整 </span><br><span class="line">        p&#x3D;t;</span><br><span class="line">        t&#x3D;t-&gt;ptr[0];</span><br><span class="line">        free(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void DestroyBTree(BTree &amp;t)&#123;</span><br><span class="line">&#x2F;&#x2F;递归释放B树 </span><br><span class="line">    int i;  </span><br><span class="line">    BTNode* p&#x3D;t;  </span><br><span class="line">    if(p!&#x3D;NULL)&#123;                                    &#x2F;&#x2F;B树不为空  </span><br><span class="line">        for(i&#x3D;0;i&lt;&#x3D;p-&gt;keynum;i++)&#123;                  &#x2F;&#x2F;递归释放每一个结点 </span><br><span class="line">            DestroyBTree(*&amp;p-&gt;ptr[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        free(p);  </span><br><span class="line">    &#125;  </span><br><span class="line">    t&#x3D;NULL;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">int print(BTree p)</span><br><span class="line">&#123;</span><br><span class="line">	if(p&#x3D;&#x3D;NULL)</span><br><span class="line">		return 0; </span><br><span class="line">	BTree q;</span><br><span class="line">	printf(&quot;[&quot;);</span><br><span class="line">	for(int i &#x3D; 1;i &lt;&#x3D; p-&gt;keynum;i++)</span><br><span class="line">	&#123;		</span><br><span class="line">		printf(&quot;%d &quot;,p-&gt;key[i]);	</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;]&quot;);</span><br><span class="line">	for(int i &#x3D; 0;i &lt; p-&gt;keynum+1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(p-&gt;ptr[i]!&#x3D;NULL)</span><br><span class="line">	  	&#123;	</span><br><span class="line">			q &#x3D; p-&gt;ptr[i];</span><br><span class="line">			print(q);</span><br><span class="line">	 	&#125;		</span><br><span class="line">	&#125; 	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test()&#123; </span><br><span class="line">    BTree T&#x3D;NULL;</span><br><span class="line">    Result s;                                       &#x2F;&#x2F;设定查找结果 </span><br><span class="line">    </span><br><span class="line">    KeyType a[]&#x3D;&#123;45,24,70,7,30,53,90,3,12,26,37,50,61,85,100&#125;;                           </span><br><span class="line">    printf(&quot;创建一棵%d阶B树:\n&quot;,m);</span><br><span class="line">    for(int j&#x3D;0;j&lt;15;j++)&#123;                               &#x2F;&#x2F;逐一插入元素 </span><br><span class="line">        s&#x3D;SearchBTree(T,a[j]);</span><br><span class="line">        if(s.tag&#x3D;&#x3D;0)</span><br><span class="line">            InsertBTree(T,s.i,a[j],s.pt);</span><br><span class="line">        printf(&quot;   \n第%d步,插入元素%d:\n &quot;,j+1,a[j]);</span><br><span class="line">        print(T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    printf(&quot;删除操作:\n&quot;); </span><br><span class="line">	KeyType k;                         &#x2F;&#x2F;删除操作 </span><br><span class="line">    k&#x3D;7;                                                        </span><br><span class="line">    BTreeDelete(T,k);</span><br><span class="line">    printf(&quot;  删除%d:\n &quot;,k);</span><br><span class="line">    printf(&quot;  删除后的B树: \n&quot;);</span><br><span class="line">    print(T);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    k&#x3D;100;</span><br><span class="line">    BTreeDelete(T,k);</span><br><span class="line">    printf(&quot;  删除%d:\n &quot;,k);</span><br><span class="line">    printf(&quot;  删除后的B树: \n&quot;);</span><br><span class="line">    print(T);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;  递归释放B树\n&quot;);                       &#x2F;&#x2F;递归释放B树</span><br><span class="line">    DestroyBTree(T);                                 </span><br><span class="line">    print(T);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Test();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;                                     </span><br></pre></td></tr></table></figure>

<h1 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h1><p><img src="https://img-blog.csdnimg.cn/20190726102540375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#top">返回顶部</a><br>*[⌈m/2⌉]:向上取整符号。</p>
]]></content>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树</title>
    <url>/2019/07/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<body>
<div id="top"></div>
</body>


<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><p>有关二叉排序树的概念与操作，移步<a href="https://blog.csdn.net/songsongL/article/details/96422357">Hear</a>。</p>
<h1 id="平衡二叉树概念"><a href="#平衡二叉树概念" class="headerlink" title="平衡二叉树概念"></a>平衡二叉树概念</h1><ul>
<li>特殊类型的二叉排序树。二叉排序树的查找性能取决于二叉树的结构。树的高度越小，查找速度越快。</li>
</ul>
<p><strong><em>注意：如果连二叉排序树都不是，那肯定不是平衡二叉树。</em></strong></p>
<ul>
<li>如果非空，左子树与右子树深度之差的绝对值不超过1.</li>
<li>左子树与右子树也是平衡二叉树。</li>
</ul>
<h1 id="结点定义"><a href="#结点定义" class="headerlink" title="结点定义"></a>结点定义</h1><p>它基本和二叉排序树差不多，就是多了个记录结点高度（用来计算平衡因子）的字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int KeyType;</span><br><span class="line">typedef int OtherInfo;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;----------二叉排序树存储表示-----------</span><br><span class="line">typedef struct&#123;						</span><br><span class="line">	KeyType key;										&#x2F;&#x2F;关键字项 </span><br><span class="line">	OtherInfo info;										&#x2F;&#x2F;其他数据信息 </span><br><span class="line">													</span><br><span class="line">&#125;ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct BSTNode &#123;</span><br><span class="line">	ElemType data;						&#x2F;&#x2F;每个结点的数据域包括关键字项和其他信息 </span><br><span class="line">	struct BSTNode *lchild;</span><br><span class="line">	struct BSTNode *rchild;							    </span><br><span class="line">	int nHeight;   						&#x2F;*树的高度，可以计算平衡因子*&#x2F;                                                                                                                                                                                                                                                       </span><br><span class="line">&#125; BSTNode,*BSTree;</span><br></pre></td></tr></table></figure>

<h1 id="平衡二叉树的操作"><a href="#平衡二叉树的操作" class="headerlink" title="平衡二叉树的操作"></a>平衡二叉树的操作</h1><ul>
<li><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2></li>
<li><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2></li>
<li><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2></li>
<li><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2>  以上操作和二叉排序树一样，主要区别在于插入过程中如果发现插入破坏了平衡需要调整。下面重点说一说怎么调整（旋转）。</li>
</ul>
<h1 id="平衡二叉树的平衡调整方法"><a href="#平衡二叉树的平衡调整方法" class="headerlink" title="平衡二叉树的平衡调整方法"></a>平衡二叉树的平衡调整方法</h1><ul>
<li><h2 id="LL型"><a href="#LL型" class="headerlink" title="LL型"></a>LL型</h2><p>  指插入以A为根的左子树的左子树上破坏了平衡。<br>  <img src="https://img-blog.csdnimg.cn/20190721140026885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  插入7或10之后53的平衡因子变为2，高了，怎么降低？那就是把高的转下来（顺时针）。主要就是 <strong><em>根和图中三角形那</em></strong> 发生了变化。三角形那可以为空。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static BSTree SingleRotateWithLeft(BSTree pNode)	&#x2F;&#x2F;LL型 </span><br><span class="line">&#123;</span><br><span class="line">    BSTNode *pNode1;</span><br><span class="line"></span><br><span class="line">    pNode1 &#x3D; pNode-&gt;lchild;				&#x2F;&#x2F;图中9</span><br><span class="line">    pNode-&gt;lchild &#x3D; pNode1-&gt;rchild;</span><br><span class="line">    pNode1-&gt;rchild &#x3D; pNode;</span><br><span class="line"></span><br><span class="line">    &#x2F;*结点的位置变了, 要更新结点的高度值*&#x2F;</span><br><span class="line">    pNode-&gt;nHeight &#x3D; Max(Height(pNode-&gt;lchild), Height(pNode-&gt;rchild)) + 1;</span><br><span class="line">    pNode1-&gt;nHeight &#x3D; Max(Height(pNode1-&gt;lchild), pNode-&gt;nHeight) + 1;</span><br><span class="line"></span><br><span class="line">    return pNode1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h2 id="RR型"><a href="#RR型" class="headerlink" title="RR型"></a>RR型</h2><p>指插入以A为根的右子树的右子树上破坏了平衡。<br><img src="https://img-blog.csdnimg.cn/20190721135727349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>插入58或70之后17的平衡因子变为-2，高了，怎么降低？那就是把高的转下来（逆时针）。主要就是 <strong><em>根和图中三角形那</em></strong> 发生了变化。三角形那可以为空。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static BSTree SingleRotateWithRight(BSTree pNode)			&#x2F;&#x2F;RR型</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode *pNode1;</span><br><span class="line"></span><br><span class="line">    pNode1 &#x3D; pNode-&gt;rchild;		&#x2F;&#x2F;图中53</span><br><span class="line">    pNode-&gt;rchild &#x3D; pNode1-&gt;lchild;</span><br><span class="line">    pNode1-&gt;lchild &#x3D; pNode;</span><br><span class="line"></span><br><span class="line">    &#x2F;*结点的位置变了, 要更新结点的高度值*&#x2F;</span><br><span class="line">    pNode-&gt;nHeight &#x3D; Max(Height(pNode-&gt;lchild), Height(pNode-&gt;rchild)) + 1;</span><br><span class="line">    pNode1-&gt;nHeight &#x3D; Max(Height(pNode1-&gt;rchild), pNode-&gt;nHeight) + 1;</span><br><span class="line"></span><br><span class="line">    return pNode1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">返回顶部</a></p>
</li>
<li><h2 id="LR型"><a href="#LR型" class="headerlink" title="LR型"></a>LR型</h2><p>指插入以A为根的左子树的右子树上破坏了平衡。<br><img src="https://img-blog.csdnimg.cn/20190721140336426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>插入25或35之后53的平衡因子为2，需要旋转，一步不能解决，那就转两次。<br>先把53的左子树进行RR型旋转，得到中间图，再把中间图进行LL型旋转即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static BSTree DoubleRotateWithLeft(BSTree pNode)		&#x2F;&#x2F;LR型</span><br><span class="line">&#123;</span><br><span class="line">    pNode-&gt;lchild &#x3D; SingleRotateWithRight(pNode-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    return SingleRotateWithLeft(pNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="RL型"><a href="#RL型" class="headerlink" title="RL型"></a>RL型</h2><p>指插入以A为根的右子树的左子树中破坏了平衡。<br><img src="https://img-blog.csdnimg.cn/20190721141502576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>插入55或59之后53的平衡因子为-2，需要旋转，一步不能解决，那就转两次。<br>先把53的右子树进行LL型旋转，得到中间图，再把中间图进行RR型旋转即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static BSTree DoubleRotateWithRight(BSTree pNode)</span><br><span class="line">&#123;</span><br><span class="line">    pNode-&gt;rchild &#x3D; SingleRotateWithLeft(pNode-&gt;rchild);	&#x2F;&#x2F;RL型</span><br><span class="line"></span><br><span class="line">    return SingleRotateWithRight(pNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">返回顶部</a></p>
<h1 id="总的代码："><a href="#总的代码：" class="headerlink" title="总的代码："></a>总的代码：</h1></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define Max(a,b) ((a)&gt;(b)?(a):(b))</span><br><span class="line"></span><br><span class="line">typedef int KeyType;</span><br><span class="line">typedef int OtherInfo;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;----------二叉排序树存储表示-----------</span><br><span class="line">typedef struct&#123;						</span><br><span class="line">	KeyType key;										&#x2F;&#x2F;关键字项 </span><br><span class="line">	OtherInfo info;										&#x2F;&#x2F;其他数据信息 </span><br><span class="line">													</span><br><span class="line">&#125;ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct BSTNode &#123;</span><br><span class="line">	ElemType data;						&#x2F;&#x2F;每个结点的数据域包括关键字项和其他信息 </span><br><span class="line">	struct BSTNode *lchild;</span><br><span class="line">	struct BSTNode *rchild;							    </span><br><span class="line">	int nHeight;   						&#x2F;*树的高度，可以计算平衡因子*&#x2F;                                                                                                                                                                                                                                                       </span><br><span class="line">&#125; BSTNode,*BSTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void InsertBST(BSTree &amp;T,ElemType e);	&#x2F;*插入操作*&#x2F;</span><br><span class="line">BSTree SearchBST(BSTree T,KeyType key);	&#x2F;*查找操作*&#x2F;</span><br><span class="line">bool delete_BSTree(BSTree &amp;T,int key);	&#x2F;*删除操作*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*打印操作*&#x2F;</span><br><span class="line">void PreOrder(BSTree T);				&#x2F;&#x2F;递归先序遍历 </span><br><span class="line">void InOrder(BSTree T);					&#x2F;&#x2F;递归中序遍历 </span><br><span class="line"></span><br><span class="line">static int Height(BSTree pNode);</span><br><span class="line"></span><br><span class="line">&#x2F;*旋转操作*&#x2F;</span><br><span class="line">static BSTree SingleRotateWithLeft(BSTree pNode);</span><br><span class="line">static BSTree SingleRotateWithRight(BSTree pNode);</span><br><span class="line">static BSTree DoubleRotateWithLeft(BSTree pNode);</span><br><span class="line">static BSTree DoubleRotateWithRight(BSTree pNode);</span><br><span class="line"></span><br><span class="line">void PreOrder(BSTree T)&#123;&#x2F;&#x2F;递归先序遍历 </span><br><span class="line">	if(T!&#x3D;NULL)&#123;</span><br><span class="line">		cout&lt;&lt;T-&gt;data.key&lt;&lt;&quot; &quot;;</span><br><span class="line">		PreOrder(T-&gt;lchild);</span><br><span class="line">		PreOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InOrder(BSTree T)&#123;&#x2F;&#x2F;递归中序遍历 </span><br><span class="line">	if(T!&#x3D;NULL)&#123;</span><br><span class="line">		InOrder(T-&gt;lchild);</span><br><span class="line">		cout&lt;&lt;T-&gt;data.key&lt;&lt;&quot; &quot;;</span><br><span class="line">		InOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BSTree SearchBST(BSTree T,KeyType key) &#123;</span><br><span class="line"> 	if ((!T) || key &#x3D;&#x3D; T-&gt;data.key)</span><br><span class="line">        return T;</span><br><span class="line">    else if (key &lt; T-&gt;data.key)</span><br><span class="line">        return SearchBST(T-&gt;lchild, key);</span><br><span class="line">    else return SearchBST(T-&gt;rchild, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*得到节点的高度以计算平衡因子*&#x2F;</span><br><span class="line">static int Height(BSTree pNode)</span><br><span class="line">&#123;</span><br><span class="line">    if (NULL &#x3D;&#x3D; pNode)</span><br><span class="line">        return 0;</span><br><span class="line">    return pNode-&gt;nHeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InsertBST(BSTree &amp;T,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">	if(!T)&#123;										&#x2F;&#x2F;找到插入位置 </span><br><span class="line">		BSTree S&#x3D;new BSTNode;					&#x2F;&#x2F;新节点保存数据 </span><br><span class="line">		S-&gt;data&#x3D;e;</span><br><span class="line">		S-&gt;nHeight &#x3D; 0;</span><br><span class="line">		S-&gt;lchild&#x3D;S-&gt;rchild&#x3D;NULL;</span><br><span class="line">		T&#x3D;S;									&#x2F;&#x2F;把新结点放到已找到的插入位置 </span><br><span class="line">	&#125;</span><br><span class="line">    else if(e.key &lt; T-&gt;data.key)&#123;</span><br><span class="line">    	InsertBST(T-&gt;lchild,e); </span><br><span class="line"> </span><br><span class="line">    	if (Height(T-&gt;lchild) - Height(T-&gt;rchild) &#x3D;&#x3D; 2)    &#x2F;*AVL树不平衡*&#x2F;</span><br><span class="line">        &#123;</span><br><span class="line">        	cout&lt;&lt;&quot;因为&quot;&lt;&lt;T-&gt;data.key&lt;&lt;&quot;左孩子高度&quot;&lt;&lt;Height(T-&gt;lchild);</span><br><span class="line">	        cout&lt;&lt;&quot;大于右孩子高度&quot;&lt;&lt;Height(T-&gt;rchild)&lt;&lt;endl;</span><br><span class="line">            if (e.key &lt; T-&gt;lchild-&gt;data.key)         </span><br><span class="line">            &#123;  	             &#x2F;*插入到了左子树左边, 做单旋转*&#x2F;  </span><br><span class="line">	            cout&lt;&lt;&quot;发生LL型旋转&quot;&lt;&lt;endl;</span><br><span class="line">                T &#x3D; SingleRotateWithLeft(T);</span><br><span class="line">            &#125;</span><br><span class="line">            else           </span><br><span class="line">            &#123;   			&#x2F;*插入到了左子树右边, 做双旋转*&#x2F;</span><br><span class="line">            	cout&lt;&lt;&quot;发生LR型旋转&quot;&lt;&lt;endl;</span><br><span class="line">                T &#x3D; DoubleRotateWithLeft(T);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;		</span><br><span class="line">  	else if(e.key &gt; T-&gt;data.key) &#123;</span><br><span class="line">  		</span><br><span class="line">  		InsertBST(T-&gt;rchild,e); </span><br><span class="line">        if (Height(T-&gt;rchild) - Height(T-&gt;lchild) &#x3D;&#x3D; 2)    &#x2F;*AVL树不平衡*&#x2F;</span><br><span class="line">        &#123;</span><br><span class="line">        	cout&lt;&lt;&quot;因为&quot;&lt;&lt;T-&gt;data.key&lt;&lt;&quot;左孩子高度&quot;&lt;&lt;Height(T-&gt;lchild);</span><br><span class="line">	        cout&lt;&lt;&quot;小于右孩子高度&quot;&lt;&lt;Height(T-&gt;rchild)&lt;&lt;endl;</span><br><span class="line">            if (e.key &gt; T-&gt;rchild-&gt;data.key)</span><br><span class="line">            &#123;	&#x2F;*插入到了右子树右边, 做单旋转*&#x2F;</span><br><span class="line">            	cout&lt;&lt;&quot;发生RL旋转&quot;&lt;&lt;endl;</span><br><span class="line">                T &#x3D; SingleRotateWithRight(T);</span><br><span class="line">            &#125;</span><br><span class="line">            else </span><br><span class="line">            &#123;	&#x2F;*插入到了右子树左边, 做双旋转*&#x2F;</span><br><span class="line">            	cout&lt;&lt;&quot;发生RR旋转&quot;&lt;&lt;endl;</span><br><span class="line">                T &#x3D; DoubleRotateWithRight(T);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125; 		</span><br><span class="line">  	else&#123;</span><br><span class="line">  		cout&lt;&lt;&quot;已有此值~&quot;&lt;&lt;endl;</span><br><span class="line">  		return;</span><br><span class="line">	&#125;</span><br><span class="line">	T-&gt;nHeight &#x3D; Max(Height(T-&gt;lchild), Height(T-&gt;rchild)) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void delete_Node1(BSTree &amp;p)	</span><br><span class="line">&#123; </span><br><span class="line">	BSTree q,s;</span><br><span class="line">	if(!p-&gt;lchild)	&#x2F;&#x2F;由于这个if在前面，所以左右子树均为空的情况会在这里处理 </span><br><span class="line">	&#123;	&#x2F;&#x2F;如果左子树为空，则只需重接其右子树</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		p &#x3D; p-&gt;rchild ;</span><br><span class="line">		free(q);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(!p-&gt;rchild)</span><br><span class="line">	&#123;	&#x2F;&#x2F;如果右子树为空，则只需重接其左子树</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		p &#x3D; p-&gt;lchild;</span><br><span class="line">		free(q);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;	&#x2F;&#x2F;如果左右子树都不为空，这里采取修改左子树的方法，也可以修改右子树，方法类似</span><br><span class="line">		s &#x3D; p-&gt;lchild;		&#x2F;&#x2F;取待删节点的左孩子结点</span><br><span class="line"> </span><br><span class="line">		while(s-&gt;rchild)	&#x2F;&#x2F;找到中序遍历时会得到的直接前驱 </span><br><span class="line">			s &#x3D; s-&gt;rchild;</span><br><span class="line">		s-&gt;rchild &#x3D; p-&gt;rchild;	&#x2F;&#x2F;将p的右子树接为s的右子树</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		p &#x3D; p-&gt;lchild;		&#x2F;&#x2F;将p的左子树直接接到其父节点的左子树上</span><br><span class="line">		free(q);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void delete_Node2(BSTree &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	BSTree q,s;		</span><br><span class="line">	if(!p-&gt;lchild)		&#x2F;&#x2F;由于这个if在前面，所以左右子树均为空的情况会在这里处理 </span><br><span class="line">	&#123;	&#x2F;&#x2F;如果左子树为空，则只需重接其右子树</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		p &#x3D; p-&gt;rchild ;</span><br><span class="line">		free(q);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(!p-&gt;rchild)</span><br><span class="line">	&#123;	&#x2F;&#x2F;如果右子树为空，则只需重接其左子树</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		p &#x3D; p-&gt;lchild;</span><br><span class="line">		free(q);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;	&#x2F;&#x2F;如果左右子树都不为空，采取修改左子树的方法，也可以修改右子树，方法类似</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		s &#x3D; p-&gt;lchild;		&#x2F;&#x2F;取待删节点的左节点</span><br><span class="line">		while(s-&gt;rchild)		</span><br><span class="line">		&#123;		&#x2F;&#x2F;找到中序遍历时会得到的直接前驱 </span><br><span class="line">			q &#x3D; s;</span><br><span class="line">			s &#x3D; s-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;用s来替换待删节点p</span><br><span class="line">		p-&gt;data &#x3D; s-&gt;data;  </span><br><span class="line">		&#x2F;&#x2F;根据情况，将s的左子树重接到q上</span><br><span class="line">		if(p !&#x3D; q)</span><br><span class="line">			q-&gt;rchild &#x3D; s-&gt;lchild;</span><br><span class="line">		else</span><br><span class="line">			q-&gt;lchild &#x3D;s-&gt;lchild;</span><br><span class="line">		free(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool delete_BSTree(BSTree &amp;T,int key)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;不存在关键字为key的节点</span><br><span class="line">	if(!T)</span><br><span class="line">		return false;</span><br><span class="line">	else</span><br><span class="line">	&#123;	</span><br><span class="line">		if(SearchBST(T,key))      &#x2F;&#x2F;查找到关键字为key的节点</span><br><span class="line">		&#123;</span><br><span class="line">			&#x2F;&#x2F;delete_Node1(T);</span><br><span class="line">			delete_Node2(T);</span><br><span class="line">			return true;			</span><br><span class="line">		&#125;</span><br><span class="line">		else  </span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;&quot;查无此值~&quot;&lt;&lt;endl; </span><br><span class="line">			return false;			</span><br><span class="line">		&#125;                 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreateBST(BSTree &amp;T) &#123;					</span><br><span class="line">			</span><br><span class="line">	T&#x3D;NULL;</span><br><span class="line">	ElemType e; </span><br><span class="line">	cout &lt;&lt; &quot;请输入值：0结束&quot;&lt;&lt;endl;			</span><br><span class="line">	cin &gt;&gt; e.key;</span><br><span class="line">	</span><br><span class="line">	while (e.key!&#x3D;0) &#123;</span><br><span class="line">		InsertBST(T,e);	</span><br><span class="line">		cout &lt;&lt; &quot;请继续输入&quot;&lt;&lt;endl;		</span><br><span class="line">		cin&gt;&gt;e.key;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void destroy_BSTree(BSTree pTree)	&#x2F;&#x2F;递归销毁二叉排序树</span><br><span class="line">&#123;</span><br><span class="line">	if(pTree)</span><br><span class="line">	&#123;</span><br><span class="line">		if(pTree-&gt;lchild)</span><br><span class="line">			destroy_BSTree(pTree-&gt;lchild);</span><br><span class="line">		if(pTree-&gt;rchild)</span><br><span class="line">			destroy_BSTree(pTree-&gt;rchild);</span><br><span class="line">		free(pTree);</span><br><span class="line">		pTree &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static BSTree SingleRotateWithLeft(BSTree pNode)	&#x2F;&#x2F;LL型 </span><br><span class="line">&#123;</span><br><span class="line">    BSTNode *pNode1;</span><br><span class="line"></span><br><span class="line">    pNode1 &#x3D; pNode-&gt;lchild;</span><br><span class="line">    pNode-&gt;lchild &#x3D; pNode1-&gt;rchild;</span><br><span class="line">    pNode1-&gt;rchild &#x3D; pNode;</span><br><span class="line"></span><br><span class="line">    &#x2F;*结点的位置变了, 要更新结点的高度值*&#x2F;</span><br><span class="line">    pNode-&gt;nHeight &#x3D; Max(Height(pNode-&gt;lchild), Height(pNode-&gt;rchild)) + 1;</span><br><span class="line">    pNode1-&gt;nHeight &#x3D; Max(Height(pNode1-&gt;lchild), pNode-&gt;nHeight) + 1;</span><br><span class="line"></span><br><span class="line">    return pNode1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static BSTree SingleRotateWithRight(BSTree pNode)			&#x2F;&#x2F;RR型</span><br><span class="line">&#123;</span><br><span class="line">    BSTNode *pNode1;</span><br><span class="line"></span><br><span class="line">    pNode1 &#x3D; pNode-&gt;rchild;</span><br><span class="line">    pNode-&gt;rchild &#x3D; pNode1-&gt;lchild;</span><br><span class="line">    pNode1-&gt;lchild &#x3D; pNode;</span><br><span class="line"></span><br><span class="line">    &#x2F;*结点的位置变了, 要更新结点的高度值*&#x2F;</span><br><span class="line">    pNode-&gt;nHeight &#x3D; Max(Height(pNode-&gt;lchild), Height(pNode-&gt;rchild)) + 1;</span><br><span class="line">    pNode1-&gt;nHeight &#x3D; Max(Height(pNode1-&gt;rchild), pNode-&gt;nHeight) + 1;</span><br><span class="line"></span><br><span class="line">    return pNode1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static BSTree DoubleRotateWithLeft(BSTree pNode)		&#x2F;&#x2F;LR型</span><br><span class="line">&#123;</span><br><span class="line">    pNode-&gt;lchild &#x3D; SingleRotateWithRight(pNode-&gt;lchild);</span><br><span class="line"></span><br><span class="line">    return SingleRotateWithLeft(pNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static BSTree DoubleRotateWithRight(BSTree pNode)</span><br><span class="line">&#123;</span><br><span class="line">    pNode-&gt;rchild &#x3D; SingleRotateWithLeft(pNode-&gt;rchild);	&#x2F;&#x2F;RL型</span><br><span class="line"></span><br><span class="line">    return SingleRotateWithRight(pNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;int main()&#123;</span><br><span class="line">&#x2F;&#x2F;	BSTree T;</span><br><span class="line">&#x2F;&#x2F;	CreateBST(T);</span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;&quot;删除前&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;&quot;先序遍历:&quot;;</span><br><span class="line">&#x2F;&#x2F;	PreOrder(T); </span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;endl&lt;&lt;&quot;中序遍历:&quot;;</span><br><span class="line">&#x2F;&#x2F;	InOrder(T);</span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;&quot;请输入删除的关键字&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	int i;</span><br><span class="line">&#x2F;&#x2F;	cin&gt;&gt;i;				</span><br><span class="line">&#x2F;&#x2F;	while (i!&#x3D;0) &#123;</span><br><span class="line">&#x2F;&#x2F;		delete_BSTree(T,i);</span><br><span class="line">&#x2F;&#x2F;		InOrder(T);</span><br><span class="line">&#x2F;&#x2F;		cout &lt;&lt; &quot;请继续输入&quot;&lt;&lt;endl;		</span><br><span class="line">&#x2F;&#x2F;		cin&gt;&gt;i;	</span><br><span class="line">&#x2F;&#x2F;	&#125;</span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;&quot;删除后&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	InOrder(T);</span><br><span class="line">&#x2F;&#x2F;	return 0;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    ElemType e;</span><br><span class="line">    BSTree T &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    srand((unsigned int)time(NULL));</span><br><span class="line">    </span><br><span class="line">    for (i &#x3D; 0; i &lt; 10; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        e.key &#x3D; rand()%100+1;</span><br><span class="line">        printf(&quot;%d\n&quot;, e.key);</span><br><span class="line">        InsertBST(T,e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;先序遍历:&quot;;</span><br><span class="line">	PreOrder(T); </span><br><span class="line">	cout&lt;&lt;endl&lt;&lt;&quot;中序遍历:&quot;;</span><br><span class="line">	InOrder(T);</span><br><span class="line"></span><br><span class="line">    destroy_BSTree(T);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h1><p>随机产生10个数字构建平衡二叉树，重复的产生值当然是插不进去的。<br><img src="https://img-blog.csdnimg.cn/2019072110140880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由运行结果的先序遍历和中序遍历可推导出这颗二叉树为：<br><img src="https://img-blog.csdnimg.cn/20190721142235634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可知构建的二叉树是平衡二叉树。</p>
<p><a href="#top">返回顶部</a></p>
]]></content>
      <tags>
        <tag>平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉排序树</title>
    <url>/2019/07/19/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    <content><![CDATA[<body>
<div id="top"></div>
</body>


<h1 id="二叉排序树的定义"><a href="#二叉排序树的定义" class="headerlink" title="二叉排序树的定义"></a>二叉排序树的定义</h1><p>二叉排序树，又叫二叉查找树，如果非空，则具有以下性质：</p>
<ol>
<li>若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>它的左右子树也分别为二叉排序树。</li>
</ol>
<p>由定义可得出 <strong><em>二叉排序树的一个重要性质：</em></strong> 中序遍历该二叉树可以得到一个结点值递增的有序序列。</p>
<h1 id="结点定义"><a href="#结点定义" class="headerlink" title="结点定义"></a>结点定义</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;----------二叉排序树存储表示-----------</span><br><span class="line">typedef struct&#123;						</span><br><span class="line">	KeyType key;										&#x2F;&#x2F;关键字项 </span><br><span class="line">	OtherInfo info;										&#x2F;&#x2F;其他数据信息 </span><br><span class="line">													</span><br><span class="line">&#125;ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct BSTNode &#123;</span><br><span class="line">	ElemType data;									&#x2F;&#x2F;每个结点的数据域包括关键字项和其他信息 </span><br><span class="line">	struct BSTNode *lchild;</span><br><span class="line">	struct BSTNode *rchild;							    </span><br><span class="line">	                                                                                                                                                                                                                                                                </span><br><span class="line">&#125; BSTNode,*BSTree;</span><br></pre></td></tr></table></figure>

<h1 id="二叉排序树的操作"><a href="#二叉排序树的操作" class="headerlink" title="二叉排序树的操作"></a>二叉排序树的操作</h1><ul>
<li><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li>若key == T-&gt;data.key，则查找成功，返回根节点地址。</li>
<li>若key &lt; T-&gt;data.key，则进一步查找左子树。</li>
<li>若key &gt; T-&gt;data.key，则进一步查找右子树。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BSTree SearchBST(BSTree T,KeyType key) &#123;</span><br><span class="line"> 	if ((!T)|| key &#x3D;&#x3D; T-&gt;data.key)</span><br><span class="line">        return T;</span><br><span class="line">    else if (key &lt; T-&gt;data.key)</span><br><span class="line">        return SearchBST(T-&gt;lchild, key);</span><br><span class="line">    else return SearchBST(T-&gt;rchild, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20190718090741742.png" alt="在这里插入图片描述"><br>要找100，与45比较，大于，然后与53比较，大于，与100比较，找到。<br>在二叉排序树上查找关键字等于给定的值的结点过程，恰是走了一条从根结点到该结点路径的过程。因此和折半查找类似，与给定值比较的关键字个数不超过树的深度。</li>
</ul>
</li>
<li><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>  二叉排序树的插入操作是以查找为基础的。当树中不存在关键字等于key的结点时才插入。新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void InsertBST(BSTree &amp;T,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">	if(!T)&#123;										&#x2F;&#x2F;找到插入位置 </span><br><span class="line">		BSTree S&#x3D;new BSTNode;					&#x2F;&#x2F;新节点保存数据 </span><br><span class="line">		S-&gt;data&#x3D;e;</span><br><span class="line">		S-&gt;lchild&#x3D;S-&gt;rchild&#x3D;NULL;</span><br><span class="line">		T&#x3D;S;									&#x2F;&#x2F;把新结点放到已找到的插入位置 </span><br><span class="line">	&#125;</span><br><span class="line">    else if(e.key &lt; T-&gt;data.key) </span><br><span class="line">		InsertBST(T-&gt;lchild,e); </span><br><span class="line">  	else if(e.key &gt; T-&gt;data.key) </span><br><span class="line">  		InsertBST(T-&gt;rchild,e); </span><br><span class="line">  	else&#123;</span><br><span class="line">  		cout&lt;&lt;&quot;已有此值~&quot;&lt;&lt;endl;</span><br><span class="line">  		return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2>  从空开始，每输入一个结点，经过查找，插入到二叉排序树的合适位置。<br>一个无序序列可以通过构造一棵二叉排序树而变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CreateBST(BSTree &amp;T) &#123;					</span><br><span class="line">			</span><br><span class="line">	T&#x3D;NULL;</span><br><span class="line">	ElemType e; </span><br><span class="line">	cout &lt;&lt; &quot;请输入值：0结束&quot;&lt;&lt;endl;			</span><br><span class="line">	cin &gt;&gt; e.key;</span><br><span class="line">	</span><br><span class="line">	while (e.key!&#x3D;0) &#123;</span><br><span class="line">		InsertBST(T,e);	</span><br><span class="line">		cout &lt;&lt; &quot;请继续输入&quot;&lt;&lt;endl;		</span><br><span class="line">		cin&gt;&gt;e.key;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><a href="#top">返回顶部</a></p>
<ul>
<li><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>  删除节点的情况相对复杂，主要分为以下三种情形：</p>
<pre><code>  1. 被删除的结点是叶子
  2. 被删除的结点只有左子树或者只有右子树
  3. 被删除的结点既有左子树，也有右子树</code></pre>
<p>  第1、2种比较简单，主要说一下第3种。<br>  删除结点有两种策略：以删除78为例,<strong><em>下面用到的s都是中序遍历时待删除结点的直接前驱。</em></strong>    二叉树的操作移步<a href="https://blog.csdn.net/songsongL/article/details/94827401">hear</a>。</p>
<p>  第一种：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s-&gt;rchild &#x3D; p-&gt;rchild;</span><br><span class="line">p &#x3D; p-&gt;lchild;	</span><br></pre></td></tr></table></figure>
<p>  <img src="https://img-blog.csdnimg.cn/20190719205456284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  <img src="https://img-blog.csdnimg.cn/20190719211430567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<p><strong><em>从图可以看出这种方法会增加树的深度。</em></strong><br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void delete_Node1(BSTree &amp;p)	</span><br><span class="line">&#123; </span><br><span class="line">	BSTree q,s;</span><br><span class="line">	if(!p-&gt;lchild)	&#x2F;&#x2F;由于这个if在前面，所以左右子树均为空的情况会在这里处理 </span><br><span class="line">	&#123;	&#x2F;&#x2F;如果左子树为空，则只需重接其右子树</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		p &#x3D; p-&gt;rchild ;</span><br><span class="line">		free(q);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(!p-&gt;rchild)</span><br><span class="line">	&#123;	&#x2F;&#x2F;如果右子树为空，则只需重接其左子树</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		p &#x3D; p-&gt;lchild;</span><br><span class="line">		free(q);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;	&#x2F;&#x2F;如果左右子树都不为空，这里采取修改左子树的方法，也可以修改右子树，方法类似</span><br><span class="line">		s &#x3D; p-&gt;lchild;		&#x2F;&#x2F;取待删节点的左孩子结点</span><br><span class="line"> </span><br><span class="line">		while(s-&gt;rchild)	&#x2F;&#x2F;找到中序遍历时会得到的直接前驱 </span><br><span class="line">			s &#x3D; s-&gt;rchild;</span><br><span class="line">		s-&gt;rchild &#x3D; p-&gt;rchild;	&#x2F;&#x2F;将p的右子树接为s的右子树</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		p &#x3D; p-&gt;lchild;		&#x2F;&#x2F;将p的左子树直接接到其父节点的左子树上</span><br><span class="line">		free(q);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    第二种：用s替代待删除结点。<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p-&gt;data &#x3D; s-&gt;data;</span><br></pre></td></tr></table></figure><br>    <img src="https://img-blog.csdnimg.cn/20190719212435391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void delete_Node2(BSTree &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	BSTree q,s;		</span><br><span class="line">	if(!p-&gt;lchild)		&#x2F;&#x2F;由于这个if在前面，所以左右子树均为空的情况会在这里处理 </span><br><span class="line">	&#123;	&#x2F;&#x2F;如果左子树为空，则只需重接其右子树</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		p &#x3D; p-&gt;rchild ;</span><br><span class="line">		free(q);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(!p-&gt;rchild)</span><br><span class="line">	&#123;	&#x2F;&#x2F;如果右子树为空，则只需重接其左子树</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		p &#x3D; p-&gt;lchild;</span><br><span class="line">		free(q);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;	&#x2F;&#x2F;如果左右子树都不为空，采取修改左子树的方法，也可以修改右子树，方法类似</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		s &#x3D; p-&gt;lchild;		&#x2F;&#x2F;取待删节点的左节点</span><br><span class="line">		while(s-&gt;rchild)		</span><br><span class="line">		&#123;		&#x2F;&#x2F;找到中序遍历时会得到的直接前驱 </span><br><span class="line">			q &#x3D; s;</span><br><span class="line">			s &#x3D; s-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;用s来替换待删节点p</span><br><span class="line">		p-&gt;data &#x3D; s-&gt;data;  </span><br><span class="line">		&#x2F;&#x2F;根据情况，将s的左子树重接到q上</span><br><span class="line">		if(p !&#x3D; q)</span><br><span class="line">			q-&gt;rchild &#x3D; s-&gt;lchild;</span><br><span class="line">		else</span><br><span class="line">			q-&gt;lchild &#x3D;s-&gt;lchild;</span><br><span class="line">		free(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a href="#top">返回顶部</a></p>
<h1 id="总的代码："><a href="#总的代码：" class="headerlink" title="总的代码："></a>总的代码：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef int KeyType;</span><br><span class="line">typedef int OtherInfo;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;----------二叉排序树存储表示-----------</span><br><span class="line">typedef struct&#123;						</span><br><span class="line">	KeyType key;										&#x2F;&#x2F;关键字项 </span><br><span class="line">	OtherInfo info;										&#x2F;&#x2F;其他数据信息 </span><br><span class="line">													</span><br><span class="line">&#125;ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct BSTNode &#123;</span><br><span class="line">	ElemType data;									&#x2F;&#x2F;每个结点的数据域包括关键字项和其他信息 </span><br><span class="line">	struct BSTNode *lchild;</span><br><span class="line">	struct BSTNode *rchild;							    </span><br><span class="line">	                                                                                                                                                                                                                                                                </span><br><span class="line">&#125; BSTNode,*BSTree;</span><br><span class="line"></span><br><span class="line">void PreOrder(BSTree T)&#123;&#x2F;&#x2F;递归先序遍历 </span><br><span class="line">	if(T!&#x3D;NULL)&#123;</span><br><span class="line">		cout&lt;&lt;T-&gt;data.key&lt;&lt;&quot; &quot;;</span><br><span class="line">		PreOrder(T-&gt;lchild);</span><br><span class="line">		PreOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InOrder(BSTree T)&#123;&#x2F;&#x2F;递归中序遍历 </span><br><span class="line">	if(T!&#x3D;NULL)&#123;</span><br><span class="line">		InOrder(T-&gt;lchild);</span><br><span class="line">		cout&lt;&lt;T-&gt;data.key&lt;&lt;&quot; &quot;;</span><br><span class="line">		InOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BSTree SearchBST(BSTree T,KeyType key) &#123;</span><br><span class="line"> 	if ((!T) || key &#x3D;&#x3D; T-&gt;data.key)</span><br><span class="line">        return T;</span><br><span class="line">    else if (key &lt; T-&gt;data.key)</span><br><span class="line">        return SearchBST(T-&gt;lchild, key);</span><br><span class="line">    else return SearchBST(T-&gt;rchild, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InsertBST(BSTree &amp;T,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">	if(!T)&#123;										&#x2F;&#x2F;找到插入位置 </span><br><span class="line">		BSTree S&#x3D;new BSTNode;					&#x2F;&#x2F;新节点保存数据 </span><br><span class="line">		S-&gt;data&#x3D;e;</span><br><span class="line">		S-&gt;lchild&#x3D;S-&gt;rchild&#x3D;NULL;</span><br><span class="line">		T&#x3D;S;									&#x2F;&#x2F;把新结点放到已找到的插入位置 </span><br><span class="line">	&#125;</span><br><span class="line">    else if(e.key &lt; T-&gt;data.key) </span><br><span class="line">		InsertBST(T-&gt;lchild,e); </span><br><span class="line">  	else if(e.key &gt; T-&gt;data.key) </span><br><span class="line">  		InsertBST(T-&gt;rchild,e); </span><br><span class="line">  	else&#123;</span><br><span class="line">  		cout&lt;&lt;&quot;已有此值~&quot;&lt;&lt;endl;</span><br><span class="line">  		return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void delete_Node1(BSTree &amp;p)	</span><br><span class="line">&#123; </span><br><span class="line">	BSTree q,s;</span><br><span class="line">	if(!p-&gt;lchild)	&#x2F;&#x2F;由于这个if在前面，所以左右子树均为空的情况会在这里处理 </span><br><span class="line">	&#123;	&#x2F;&#x2F;如果左子树为空，则只需重接其右子树</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		p &#x3D; p-&gt;rchild ;</span><br><span class="line">		free(q);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(!p-&gt;rchild)</span><br><span class="line">	&#123;	&#x2F;&#x2F;如果右子树为空，则只需重接其左子树</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		p &#x3D; p-&gt;lchild;</span><br><span class="line">		free(q);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;	&#x2F;&#x2F;如果左右子树都不为空，这里采取修改左子树的方法，也可以修改右子树，方法类似</span><br><span class="line">		s &#x3D; p-&gt;lchild;		&#x2F;&#x2F;取待删节点的左孩子结点</span><br><span class="line"> </span><br><span class="line">		while(s-&gt;rchild)	&#x2F;&#x2F;找到中序遍历时会得到的直接前驱 </span><br><span class="line">			s &#x3D; s-&gt;rchild;</span><br><span class="line">		s-&gt;rchild &#x3D; p-&gt;rchild;	&#x2F;&#x2F;将p的右子树接为s的右子树</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		p &#x3D; p-&gt;lchild;		&#x2F;&#x2F;将p的左子树直接接到其父节点的左子树上</span><br><span class="line">		free(q);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void delete_Node2(BSTree &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	BSTree q,s;		</span><br><span class="line">	if(!p-&gt;lchild)		&#x2F;&#x2F;由于这个if在前面，所以左右子树均为空的情况会在这里处理 </span><br><span class="line">	&#123;	&#x2F;&#x2F;如果左子树为空，则只需重接其右子树</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		p &#x3D; p-&gt;rchild ;</span><br><span class="line">		free(q);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(!p-&gt;rchild)</span><br><span class="line">	&#123;	&#x2F;&#x2F;如果右子树为空，则只需重接其左子树</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		p &#x3D; p-&gt;lchild;</span><br><span class="line">		free(q);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;	&#x2F;&#x2F;如果左右子树都不为空，采取修改左子树的方法，也可以修改右子树，方法类似</span><br><span class="line">		q &#x3D; p;</span><br><span class="line">		s &#x3D; p-&gt;lchild;		&#x2F;&#x2F;取待删节点的左节点</span><br><span class="line">		while(s-&gt;rchild)		</span><br><span class="line">		&#123;		&#x2F;&#x2F;找到中序遍历时会得到的直接前驱 </span><br><span class="line">			q &#x3D; s;</span><br><span class="line">			s &#x3D; s-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;用s来替换待删节点p</span><br><span class="line">		p-&gt;data &#x3D; s-&gt;data;  </span><br><span class="line">		&#x2F;&#x2F;根据情况，将s的左子树重接到q上</span><br><span class="line">		if(p !&#x3D; q)</span><br><span class="line">			q-&gt;rchild &#x3D; s-&gt;lchild;</span><br><span class="line">		else</span><br><span class="line">			q-&gt;lchild &#x3D;s-&gt;lchild;</span><br><span class="line">		free(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool delete_BSTree(BSTree &amp;T,int key)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;不存在关键字为key的节点</span><br><span class="line">	if(!T)</span><br><span class="line">		return false;</span><br><span class="line">	else</span><br><span class="line">	&#123;	</span><br><span class="line">		if(SearchBST(T,key))      &#x2F;&#x2F;查找到关键字为key的节点</span><br><span class="line">		&#123;</span><br><span class="line">			&#x2F;&#x2F;delete_Node1(T);</span><br><span class="line">			delete_Node2(T);</span><br><span class="line">			return true;			</span><br><span class="line">		&#125;</span><br><span class="line">		else  </span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;&quot;查无此值~&quot;&lt;&lt;endl; </span><br><span class="line">			return false;			</span><br><span class="line">		&#125;                 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreateBST(BSTree &amp;T) &#123;					</span><br><span class="line">			</span><br><span class="line">	T&#x3D;NULL;</span><br><span class="line">	ElemType e; </span><br><span class="line">	cout &lt;&lt; &quot;请输入值：0结束&quot;&lt;&lt;endl;			</span><br><span class="line">	cin &gt;&gt; e.key;</span><br><span class="line">	</span><br><span class="line">	while (e.key!&#x3D;0) &#123;</span><br><span class="line">		InsertBST(T,e);	</span><br><span class="line">		cout &lt;&lt; &quot;请继续输入&quot;&lt;&lt;endl;		</span><br><span class="line">		cin&gt;&gt;e.key;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void destroy_BSTree(BSTree pTree)	&#x2F;&#x2F;递归销毁二叉排序树</span><br><span class="line">&#123;</span><br><span class="line">	if(pTree)</span><br><span class="line">	&#123;</span><br><span class="line">		if(pTree-&gt;lchild)</span><br><span class="line">			destroy_BSTree(pTree-&gt;lchild);</span><br><span class="line">		if(pTree-&gt;rchild)</span><br><span class="line">			destroy_BSTree(pTree-&gt;rchild);</span><br><span class="line">		free(pTree);</span><br><span class="line">		pTree &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	BSTree T;</span><br><span class="line">	CreateBST(T);</span><br><span class="line">	cout&lt;&lt;&quot;删除前&quot;&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;先序遍历:&quot;;</span><br><span class="line">	PreOrder(T); </span><br><span class="line">	cout&lt;&lt;endl&lt;&lt;&quot;中序遍历:&quot;;</span><br><span class="line">	InOrder(T);</span><br><span class="line">	cout&lt;&lt;&quot;请输入删除的关键字&quot;&lt;&lt;endl;</span><br><span class="line">	int i;</span><br><span class="line">	cin&gt;&gt;i;				</span><br><span class="line">	while (i!&#x3D;0) &#123;</span><br><span class="line">		delete_BSTree(T,i);</span><br><span class="line">		InOrder(T);</span><br><span class="line">		cout &lt;&lt; &quot;请继续输入&quot;&lt;&lt;endl;		</span><br><span class="line">		cin&gt;&gt;i;	</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;删除后&quot;&lt;&lt;endl;</span><br><span class="line">	InOrder(T);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h1><p><img src="https://img-blog.csdnimg.cn/20190719213033600.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190719213108427.png" alt="在这里插入图片描述"><br><a href="#top">返回顶部</a></p>
]]></content>
      <tags>
        <tag>二叉排序树</tag>
      </tags>
  </entry>
  <entry>
    <title>图的应用--拓扑排序</title>
    <url>/2019/07/16/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8--%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<body>
<div id="top"></div>
</body>


<h1 id="什么是拓扑排序"><a href="#什么是拓扑排序" class="headerlink" title="什么是拓扑排序"></a>什么是拓扑排序</h1><p>拓扑排序经常用于完成有依赖关系的任务的排序。<br>举个例子：<br>一个软件工程专业的学生必须学习系列的基本课程，其中有些课程是基础课，独立于其他课程，而另一些课程必须先学完先修课程才可以开始后序课程。这个关系可以用有向图表示。<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190716130910951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190716130910951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =600x)<br>学生必须按照拓扑有序的顺序来安排学习计划，这样才能保证学习任何一门课程时其先修课程已经学过。</p>
<h1 id="拓扑排序的过程"><a href="#拓扑排序的过程" class="headerlink" title="拓扑排序的过程"></a>拓扑排序的过程</h1><ul>
<li><p>在有向图中找一个无前驱的顶点且输出。</p>
</li>
<li><p>删除该顶点指向另外顶点的弧。</p>
</li>
<li><p>重复以上两步，直至不存在没有前驱的点</p>
</li>
<li><p>若输出的顶点数小于有向图中的顶点数，则说明图中存在环。否则输出的序列即为拓扑排序。<br><img src="https://img-blog.csdnimg.cn/20190716132954666.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="拓扑排序的实现"><a href="#拓扑排序的实现" class="headerlink" title="拓扑排序的实现"></a>拓扑排序的实现</h1><p>需要一个辅助数组indegree[i]来存储各个顶点的入度。</p>
</li>
<li><h2 id="采用邻接矩阵实现"><a href="#采用邻接矩阵实现" class="headerlink" title="采用邻接矩阵实现"></a>采用邻接矩阵实现</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MVNum 10&#x2F;&#x2F;最大顶点数 </span><br><span class="line">#define MAXINT 32768&#x2F;&#x2F;表示极大值 </span><br><span class="line"></span><br><span class="line">typedef int arcType;</span><br><span class="line">typedef char vertexType;</span><br><span class="line"></span><br><span class="line">typedef struct MNode&#123;</span><br><span class="line">	vertexType vertex[MVNum];	&#x2F;&#x2F;存储顶点 </span><br><span class="line">	arcType Arc[MVNum][MVNum];	&#x2F;&#x2F;邻接矩阵，存储边 </span><br><span class="line">	int vexnum,arcnum;</span><br><span class="line">&#125;GraphNode,*Graph;</span><br><span class="line"></span><br><span class="line">int indegree[MVNum]&#x3D;&#123;0&#125;;		&#x2F;&#x2F;记录各个顶点的入度 </span><br><span class="line"></span><br><span class="line">int Init(Graph &amp;G)&#123;</span><br><span class="line">	G&#x3D;(GraphNode *)malloc(sizeof(GraphNode));</span><br><span class="line">	G-&gt;vexnum&#x3D;0;</span><br><span class="line">	G-&gt;arcnum&#x3D;0;</span><br><span class="line">	if(G) return 1;</span><br><span class="line">	else cout&lt;&lt;&quot;初始化出错！&quot;&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void FindPos(Graph G,char a,char b,int &amp;pos1,int &amp;pos2)&#123;&#x2F;&#x2F;查找位置 </span><br><span class="line">	int i&#x3D;0;</span><br><span class="line">	pos1&#x3D;-1;pos2&#x3D;-1;</span><br><span class="line">	for(int i&#x3D;0;i&lt;G-&gt;vexnum;i++)&#123;</span><br><span class="line">		if(G-&gt;vertex[i]&#x3D;&#x3D;a)&#123;</span><br><span class="line">			pos1&#x3D;i;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(G-&gt;vertex[i]&#x3D;&#x3D;b)&#123;</span><br><span class="line">			pos2&#x3D;i;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreateDG(Graph G)			&#x2F;&#x2F;创建有向图 </span><br><span class="line">&#123;</span><br><span class="line">	int num&#x3D;0,					&#x2F;&#x2F;控制输入顶点数 </span><br><span class="line">		pos1,pos2,				&#x2F;&#x2F;确认顶点位置 </span><br><span class="line">		i,j;</span><br><span class="line">	char a,</span><br><span class="line">		 b,</span><br><span class="line">		 ch;					&#x2F;&#x2F;顶点 </span><br><span class="line">	for(int i&#x3D;0;i&lt;MVNum;i++)&#123;				&#x2F;&#x2F;初始化 </span><br><span class="line">		for(int j&#x3D;0;j&lt;MVNum;j++)&#123;</span><br><span class="line">			G-&gt;Arc[i][j]&#x3D;0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;&quot;请输入顶点，以#结束&quot;&lt;&lt;endl;</span><br><span class="line">	cin&gt;&gt;ch;</span><br><span class="line">	while(ch!&#x3D;&#39;#&#39;&amp;&amp;num&lt;10)&#123;</span><br><span class="line">		G-&gt;vertex[num]&#x3D;ch;</span><br><span class="line">		cin&gt;&gt;ch;</span><br><span class="line">		num++;</span><br><span class="line">	&#125; </span><br><span class="line">	G-&gt;vexnum&#x3D;num;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;&quot;请输入对应的弧（ab与ba是方向相反的边），以##结束&quot;&lt;&lt;endl;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	while(a!&#x3D;&#39;#&#39;&amp;&amp;b!&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">		FindPos(G,a,b,pos1,pos2);</span><br><span class="line">		cout&lt;&lt;&quot;位置a：&quot;&lt;&lt;pos1&lt;&lt;&quot;位置b：&quot;&lt;&lt;pos2&lt;&lt;endl;</span><br><span class="line">		if(pos1!&#x3D;-1&amp;&amp;pos2!&#x3D;-1)&#123;</span><br><span class="line">			G-&gt;Arc[pos1][pos2]&#x3D;1;</span><br><span class="line">			G-&gt;arcnum++;</span><br><span class="line">			indegree[pos2]++; </span><br><span class="line">		&#125;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void topo(Graph G)</span><br><span class="line">&#123;</span><br><span class="line">	stack&lt;int&gt;s;</span><br><span class="line">	queue&lt;int&gt;q;</span><br><span class="line">    int i,temp;</span><br><span class="line">    for(i&#x3D;0;i&lt;G-&gt;vexnum;i++)&#123;</span><br><span class="line">        if(!indegree[i]) s.push(i);       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(!s.empty())&#123;</span><br><span class="line">    	temp&#x3D;s.top();</span><br><span class="line">    	q.push(temp);</span><br><span class="line">     	s.pop();</span><br><span class="line">        for(i&#x3D;0;i&lt;G-&gt;vexnum;i++)&#123;	</span><br><span class="line">            if(G-&gt;Arc[temp][i])&#123;</span><br><span class="line">            	indegree[i]--;			</span><br><span class="line">            	if(indegree[i]&#x3D;&#x3D;0) s.push(i);</span><br><span class="line">			&#125; </span><br><span class="line">        &#125;    </span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	if(q.size()&lt;G-&gt;vexnum) printf(&quot;该有向图有回路&quot;); </span><br><span class="line">  	else&#123;</span><br><span class="line">  		while(!q.empty())&#123;</span><br><span class="line">  			printf(&quot;%c &quot;,G-&gt;vertex[q.front()]);</span><br><span class="line">  			q.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show(Graph G)&#123;</span><br><span class="line">	for(int i&#x3D;0;i&lt;G-&gt;vexnum;i++)&#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;G-&gt;vexnum;j++)&#123;</span><br><span class="line">			cout&lt;&lt;G-&gt;Arc[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Graph G &#x3D; NULL;</span><br><span class="line">    Init(G);</span><br><span class="line">    CreateDG(G);</span><br><span class="line">	topo(G);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p><img src="https://img-blog.csdnimg.cn/20190716132436473.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#top">返回顶部</a></p>
</li>
<li><h2 id="采用邻接表实现"><a href="#采用邻接表实现" class="headerlink" title="采用邻接表实现"></a>采用邻接表实现</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MVNum 10									    &#x2F;&#x2F;最大顶点信息</span><br><span class="line">int indegree[MVNum]&#x3D;&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">typedef char VerTexType;</span><br><span class="line">typedef int OtherInfo;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;----------图的邻接表存储表示-----------</span><br><span class="line">typedef struct ArcNode &#123;								&#x2F;&#x2F;边结点</span><br><span class="line">	int adjvex;											&#x2F;&#x2F;该边所指向顶点的位置</span><br><span class="line">	struct ArcNode *nextarc;							&#x2F;&#x2F;指向下一条边的指针</span><br><span class="line">	OtherInfo info;										&#x2F;&#x2F;和边相关的信息</span><br><span class="line">													</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line">typedef struct VNode &#123;</span><br><span class="line">	VerTexType data;									&#x2F;&#x2F;顶点信息</span><br><span class="line">	ArcNode *fristarrc;							    	&#x2F;&#x2F;指向第一条依附该顶点的边 </span><br><span class="line">	                                                                                                                                                                                                                                                                </span><br><span class="line">&#125; VNode,AdjList[MVNum];</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">	AdjList vertices;									&#x2F;&#x2F; 邻接表</span><br><span class="line">	int vexnum;                                         &#x2F;&#x2F;图的当前顶点数</span><br><span class="line">	int arcnum;											&#x2F;&#x2F;图的当前边数	</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line">int LocateVex(ALGraph G,VerTexType v) &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; G.vexnum; i++) </span><br><span class="line">		if (G.vertices[i].data &#x3D;&#x3D; v)</span><br><span class="line">			return i;	      </span><br><span class="line">		return -1;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreateDG(ALGraph &amp;G) &#123;								&#x2F;&#x2F;采用邻接表表示法，创建有向图G</span><br><span class="line">			</span><br><span class="line">	int i, k;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; &quot;请输入总顶点数和总边数：&quot;  ;				&#x2F;&#x2F;输出总顶点数，总边数</span><br><span class="line">	cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; &quot;请输入顶点：&quot; &lt;&lt; endl;</span><br><span class="line">	for (i &#x3D; 0 ; i &lt; G.vexnum; i++) &#123;					&#x2F;&#x2F;输入各点，构建表头结点</span><br><span class="line">		cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i + 1) &lt;&lt; &quot;个顶点的名称：&quot;;</span><br><span class="line">		cin &gt;&gt; G.vertices[i].data;</span><br><span class="line">		G.vertices[i].fristarrc &#x3D; NULL;                 &#x2F;&#x2F;初始化表头结点的指针域为NULL</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;请输入一条边依附的顶点:&quot; &lt;&lt;endl;</span><br><span class="line">	for (k &#x3D; 0; k &lt; G.arcnum; k++) &#123;</span><br><span class="line">		VerTexType v1, v2;</span><br><span class="line">		int i, j;</span><br><span class="line">		cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k+1) &lt;&lt; &quot;条边依附的顶点&quot;;</span><br><span class="line">		cin &gt;&gt; v1 &gt;&gt; v2;								&#x2F;&#x2F;输入一条边依附的两个顶点</span><br><span class="line">		i &#x3D; LocateVex(G, v1);							&#x2F;&#x2F;确定v1和v2在G中的位置，</span><br><span class="line">		j &#x3D; LocateVex(G, v2);							&#x2F;&#x2F;即顶点在G.vertices(邻接表)中的序号</span><br><span class="line">		indegree[j]++;										</span><br><span class="line">		ArcNode *p1 &#x3D; new ArcNode;						&#x2F;&#x2F;生成一个新的边结点*p1</span><br><span class="line">		p1-&gt;adjvex &#x3D; j;									&#x2F;&#x2F;邻接点序号为j</span><br><span class="line">		p1-&gt;nextarc &#x3D; G.vertices[i].fristarrc;	</span><br><span class="line">		G.vertices[i].fristarrc &#x3D; p1;					&#x2F;&#x2F;将新节点*p1插入vi的边表</span><br><span class="line">		  </span><br><span class="line">&#x2F;&#x2F;		ArcNode *p2 &#x3D; new ArcNode;						&#x2F;&#x2F;生成另一个对称的新的边结点*p2</span><br><span class="line">&#x2F;&#x2F;        p2-&gt;adjvex &#x3D; i;									&#x2F;&#x2F;邻接点序号为i</span><br><span class="line">&#x2F;&#x2F;		p2-&gt;nextarc &#x3D; G.vertices[j].fristarrc;	</span><br><span class="line">&#x2F;&#x2F;		G.vertices[j].fristarrc &#x3D; p2;					&#x2F;&#x2F;将新结点*p2插入顶点Vj的边表</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void topo(ALGraph G)</span><br><span class="line">&#123;</span><br><span class="line">	stack&lt;int&gt;s;</span><br><span class="line">	queue&lt;int&gt;q;</span><br><span class="line"></span><br><span class="line">	ArcNode *p&#x3D;NULL;</span><br><span class="line">    int i,k,temp;   </span><br><span class="line">    for(i&#x3D;0;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        if(!indegree[i]) s.push(i);       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(!s.empty())&#123;</span><br><span class="line">    	temp&#x3D;s.top();</span><br><span class="line">    	q.push(temp);</span><br><span class="line">     	s.pop();</span><br><span class="line">     	p&#x3D;G.vertices[temp].fristarrc;</span><br><span class="line">        while(p!&#x3D;NULL)&#123;</span><br><span class="line">			k&#x3D;p-&gt;adjvex;</span><br><span class="line">			indegree[k]--;					</span><br><span class="line">            if(indegree[k]&#x3D;&#x3D;0) s.push(k);</span><br><span class="line">            p&#x3D;p-&gt;nextarc;</span><br><span class="line">        &#125;    </span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	if(q.size()&lt;G.vexnum) printf(&quot;该有向图有回路&quot;); </span><br><span class="line">  	else&#123;</span><br><span class="line">  		while(!q.empty())&#123;</span><br><span class="line">  			printf(&quot;%c &quot;,G.vertices[q.front()].data);</span><br><span class="line">  			q.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	ALGraph G;</span><br><span class="line">	CreateDG(G);</span><br><span class="line">	</span><br><span class="line">	int i;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for (i &#x3D; 0; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">		VNode temp &#x3D; G.vertices[i];					 &#x2F;&#x2F;将G的顶点信息付给temp</span><br><span class="line">		ArcNode *p &#x3D; temp.fristarrc;				 &#x2F;&#x2F;将顶点信息temp中的边信息给p</span><br><span class="line">		if ( p &#x3D;&#x3D;  NULL)&#123;</span><br><span class="line">			cout &lt;&lt; G.vertices[i].data;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; temp.data;</span><br><span class="line">			while (p)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; &quot;-&gt;&quot;;</span><br><span class="line">				cout &lt;&lt; p-&gt;adjvex;</span><br><span class="line">				p &#x3D; p-&gt;nextarc;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">&#x2F;&#x2F;			if(!p)&#123;</span><br><span class="line">&#x2F;&#x2F;				cout&lt;&lt;&quot;-&gt;^&quot;;</span><br><span class="line">&#x2F;&#x2F;			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	topo(G);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><h2 id="运行结果：-1"><a href="#运行结果：-1" class="headerlink" title="运行结果："></a>运行结果：</h2><img src="https://img-blog.csdnimg.cn/20190716132504552.JPG" alt="在这里插入图片描述"><br>从上面可以看出拓扑排序序列不一定相同，只要满足先序在后序前面即可。<br><a href="#top">返回顶部</a></li>
</ul>
]]></content>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构复习整理目录</title>
    <url>/2019/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<body>
<div id="top"></div>
</body>

<ul>
<li><h1 id="数据结构概述"><a href="#数据结构概述" class="headerlink" title="数据结构概述"></a><a href="https://blog.csdn.net/songsongL/article/details/94379367">数据结构概述</a></h1></li>
<li><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><pre><code> - ## [顺序表](https://blog.csdn.net/songsongL/article/details/94396569)
 - ## [链表](https://blog.csdn.net/songsongL/article/details/94431116)</code></pre>
</li>
<li><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><pre><code> - ## [栈](https://blog.csdn.net/songsongL/article/details/94553726)
     -  ### [顺序栈](https://blog.csdn.net/songsongL/article/details/94553726#1__18)
     -  ### [链栈](https://blog.csdn.net/songsongL/article/details/94553726#2_279)
 - ## [队列](https://blog.csdn.net/songsongL/article/details/94714607)
  -  ### [顺序队](https://blog.csdn.net/songsongL/article/details/94714607#1_17)
     -  ### [链队](https://blog.csdn.net/songsongL/article/details/94714607#2_205)</code></pre>
</li>
<li><h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a><a href="https://blog.csdn.net/songsongL/article/details/94827401">树和二叉树</a></h1></li>
<li><h1 id="图"><a href="#图" class="headerlink" title="图"></a><a href="https://blog.csdn.net/songsongL/article/details/95166558">图</a></h1></li>
<li><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><pre><code> - ## 栈的应用
     -  ### [数值转换](https://blog.csdn.net/songsongL/article/details/94605661#1_5)
     -  ### [表达式求值](https://blog.csdn.net/songsongL/article/details/94605661#2_127)
 - ## 二叉树的应用
  -  ### [哈弗曼编码与译码](https://blog.csdn.net/songsongL/article/details/95042688)
 - ## 图的应用
  -  ### [最小生成树](https://blog.csdn.net/songsongL/article/details/95859328)
      -  #### [普利姆（Prim）算法](https://blog.csdn.net/songsongL/article/details/95859328#Prim_10)
      -  #### [克鲁斯卡尔（Kruskal）算法](https://blog.csdn.net/songsongL/article/details/95859328#Kruskal_243)
  -  ### [最短路径](https://blog.csdn.net/songsongL/article/details/95873009)
      - #### [迪杰斯特拉（Dijkstra）算法](https://blog.csdn.net/songsongL/article/details/95873009#Dijkstra_6)
      - #### [弗洛伊德（Floyed）算法](https://blog.csdn.net/songsongL/article/details/95873009#Floyed_70)
  - ### [拓扑排序](https://blog.csdn.net/songsongL/article/details/96126183)</code></pre>
</li>
</ul>
<p><a href="#top">回到顶部</a></p>
]]></content>
      <tags>
        <tag>数据结构复习</tag>
      </tags>
  </entry>
  <entry>
    <title>图的应用--最短路径</title>
    <url>/2019/07/15/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8--%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<body>
<div id="top"></div>
</body>


<h1 id="1-从某个源点到其余各点的最短距离"><a href="#1-从某个源点到其余各点的最短距离" class="headerlink" title="1. 从某个源点到其余各点的最短距离"></a>1. 从某个源点到其余各点的最短距离</h1><ul>
<li><h2 id="迪杰斯特拉（Dijkstra）算法"><a href="#迪杰斯特拉（Dijkstra）算法" class="headerlink" title="迪杰斯特拉（Dijkstra）算法"></a>迪杰斯特拉（Dijkstra）算法</h2><ul>
<li><p>将顶点集V分为两堆—-S 和 V-S，初始时S只有源点。</p>
</li>
<li><p>辅助数组</p>
<ul>
<li>S[i]==true/1，表示顶点加入了S集中。</li>
<li>Path[i]，其值记录着当前路径上vi的直接前驱顶点序号。</li>
<li>D[i]，从源点v0到终点vi的的当前最短路径长度。这与最小生成树 <strong><em>普利姆（prim）</em></strong> 算法中的辅助数组相似。只不过这里是路径，比较的是中转和非中转路线的权值，而最小生成树中，比较的是集合中（可能v0，v1）的点到其余各个顶点（可能v2，v3）的权值谁小（v0v2与v1v2、v0v3与v1v3比）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ShortestPath_DIJ(int v0) 		&#x2F;&#x2F; 迪杰斯特拉算法最短路径</span><br><span class="line">&#123;	</span><br><span class="line">	int v,w,i;	</span><br><span class="line">	int S[NUM]&#x3D;&#123;0&#125;;	</span><br><span class="line">	int min;	</span><br><span class="line">	for(v&#x3D;1;v&lt;G.vexnum;v++)&#123;		&#x2F;&#x2F;初始化 </span><br><span class="line">		S[v]&#x3D;0;						&#x2F;&#x2F;初始化为空集 </span><br><span class="line">		D[v]&#x3D;G.arcs[v0][v].adj;		&#x2F;&#x2F;将v0到各个终点的长度初始化为权值	</span><br><span class="line">		if(D[v]&lt;Max)&#123;				&#x2F;&#x2F;如果v0和V之间有边，将V的前驱置为v0 </span><br><span class="line">			path[v]&#x3D;v0;		</span><br><span class="line">		&#125;</span><br><span class="line">		else path[v]&#x3D;-1;	 		&#x2F;&#x2F;如果没有边，即没路 </span><br><span class="line">	&#125;</span><br><span class="line">	D[v0]&#x3D;0;						&#x2F;&#x2F;源点到原点的距离为0 </span><br><span class="line">	S[v0]&#x3D;1;						&#x2F;&#x2F;将v0加入S</span><br><span class="line">	</span><br><span class="line">	&#x2F;* 初始化结束，开始主循环，每次求得v0到某个顶点v的最短路径，将v加入S中*&#x2F; </span><br><span class="line">	</span><br><span class="line">	for(i&#x3D;2;i&lt;G.vexnum;++i)&#123;		&#x2F;&#x2F;对其余n-1个顶点依次进行计算 </span><br><span class="line">		min&#x3D;Max;	</span><br><span class="line">		for(w&#x3D;1;w&lt;G.vexnum;++w)				</span><br><span class="line">			if(!S[w]&amp;&amp;D[w]&lt;min)&#123;	&#x2F;&#x2F;选择一条当前的最短路径</span><br><span class="line">				v&#x3D;w;			</span><br><span class="line">				min&#x3D;D[w];		</span><br><span class="line">			&#125;	    </span><br><span class="line">		S[v]&#x3D;1;						&#x2F;&#x2F;将v加入S </span><br><span class="line">		</span><br><span class="line">		for(w&#x3D;1;w&lt;G.vexnum;++w)		&#x2F;&#x2F;更新v0到集合V-S上所有顶点的最短路径长度 </span><br><span class="line">		if(!S[w]&amp;&amp;((D[v]+G.arcs[v][w].adj)&lt;D[w]))&#123;		&#x2F;&#x2F;中转路径更小 </span><br><span class="line">			D[w]&#x3D;D[v]+G.arcs[v][w].adj;		</span><br><span class="line">			path[w]&#x3D;v;		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><h2 id="输出路径"><a href="#输出路径" class="headerlink" title="输出路径"></a>输出路径</h2><p>从终点回溯到起点，path[i]的值是vi的前驱，只要前驱不等于起点，就一直回溯即可得到最短路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(sight1!&#x3D;sight2)&#123;</span><br><span class="line">	printf(&quot;\n\t从%s到%s的最短路径是&quot;,G.vex[sight1].sight,G.vex[sight2].sight);	</span><br><span class="line">	printf(&quot;\t(最短距离为 %dm.)\n\n\t&quot;,D[sight2]);	</span><br><span class="line">    printf(&quot;%s&lt;--&quot;,G.vex[sight2].sight);</span><br><span class="line">	while(path[end]!&#x3D;sight1)&#123;</span><br><span class="line">		end&#x3D;path[end];</span><br><span class="line">		printf(&quot;%s&lt;--&quot;,G.vex[end].sight);	</span><br><span class="line">		q&#x3D;q+1;		</span><br><span class="line">		if(q%8&#x3D;&#x3D;0) printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%s&quot;,G.vex[sight1].sight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">回到顶部</a></p>
<h1 id="2-每一对顶点之间的最短距离"><a href="#2-每一对顶点之间的最短距离" class="headerlink" title="2. 每一对顶点之间的最短距离"></a>2. 每一对顶点之间的最短距离</h1><p>很显然，调用n次迪杰斯特拉（Dijkstra）算法即可得到任意两地间的最短距离。还有一种方法就是下面的弗洛伊德（Floyed）算法。</p>
</li>
</ul>
</li>
<li><h2 id="弗洛伊德（Floyed）算法"><a href="#弗洛伊德（Floyed）算法" class="headerlink" title="弗洛伊德（Floyed）算法"></a>弗洛伊德（Floyed）算法</h2><ul>
<li>理解的不是很透彻，只能从宏观把握一下。两点间距离最小，要么有中转要么没有中转，所以肯定要比较加入中间点的路径长度。两个for循环，那只能输出二维数组的值（即两地间的距离），所以还需要一个for循环来插入中转点，然后比较找最短路径距离。</li>
<li>辅助数组<br>  path[i][j]，其值记录了i，j确定的顶点的前驱。<br>  D[i][j]，记录了vi到vj的最短路径长度。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ShortestPath_Floyed()&#123;			&#x2F;&#x2F;求各对顶点之间的最短路径</span><br><span class="line">	int P[NUM][NUM];				&#x2F;&#x2F;记录路径</span><br><span class="line">	int Dis[NUM][NUM];				&#x2F;&#x2F;记录最短路径  </span><br><span class="line">	int i,j,k,q&#x3D;0;	</span><br><span class="line">	int end;</span><br><span class="line">	for(i&#x3D;1;i&lt;G.vexnum;i++)&#123;		&#x2F;&#x2F;初始化 </span><br><span class="line">		for(j&#x3D;1;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">			if(i&#x3D;&#x3D;j) Dis[i][j]&#x3D;0;</span><br><span class="line">			else Dis[i][j]&#x3D;G.arcs[i][j].adj;</span><br><span class="line">			if(Dis[i][j]&lt;Max) P[i][j]&#x3D;i;	&#x2F;&#x2F;如果i和j之间有边，将j的前驱置为i</span><br><span class="line">			else P[i][j]&#x3D;-1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(k&#x3D;1;k&lt;G.vexnum;k++)</span><br><span class="line">		for(i&#x3D;1;i&lt;G.vexnum;i++)</span><br><span class="line">			for(j&#x3D;1;j&lt;G.vexnum;j++)	</span><br><span class="line">				if(Dis[i][k]+Dis[k][j]&lt;Dis[i][j])&#123;	</span><br><span class="line">					Dis[i][j]&#x3D;Dis[i][k]+Dis[k][j];		</span><br><span class="line">					P[i][j]&#x3D;P[k][j];	</span><br><span class="line">				&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="输出路径-1"><a href="#输出路径-1" class="headerlink" title="输出路径"></a>输出路径</h2>从终点回溯到起点，path[i][j]的值是vj的前驱，只要前驱不等于起点vi，就一直回溯即可得到最短路径。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(i&#x3D;1;i&lt;G.vexnum;i++)&#123;	</span><br><span class="line">		for(j&#x3D;1;j&lt;G.vexnum;j++)&#123;	</span><br><span class="line">			end&#x3D;j;		</span><br><span class="line">			printf(&quot;\n从%s到%s的最短路径是&quot;,G.vex[i].sight,G.vex[j].sight);	</span><br><span class="line">			printf(&quot;\t(最短距离为 %dm.)\n\t&quot;,Dis[i][j]);	</span><br><span class="line">		    printf(&quot;\n%s&lt;--&quot;,G.vex[j].sight);</span><br><span class="line">			while(P[i][end]!&#x3D;i)&#123;</span><br><span class="line">				end&#x3D;P[i][end];</span><br><span class="line">				printf(&quot;%s&lt;--&quot;,G.vex[end].sight);	</span><br><span class="line">				q&#x3D;q+1;		</span><br><span class="line">				if(q%8&#x3D;&#x3D;0) printf(&quot;\n&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;%s\n&quot;,G.vex[i].sight);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<a href="#top">回到顶部</a><h1 id="总的代码："><a href="#总的代码：" class="headerlink" title="总的代码："></a>总的代码：</h1></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#define Max 32767</span><br><span class="line">#define NUM 13</span><br><span class="line"></span><br><span class="line">typedef char ArcType; </span><br><span class="line">typedef char VerType; </span><br><span class="line"></span><br><span class="line">typedef struct ArcCell&#123;</span><br><span class="line">	int adj;				&#x2F;&#x2F;记录权值 </span><br><span class="line">	ArcType *info;			&#x2F;&#x2F;其他信息 </span><br><span class="line">&#125;ArcCell;</span><br><span class="line"></span><br><span class="line">typedef struct VertexType&#123;</span><br><span class="line">	int number;     		&#x2F;&#x2F;顶点编号</span><br><span class="line">	VerType *sight;			&#x2F;&#x2F;其他信息，在此记录顶点名 即地名 </span><br><span class="line">&#125;VertexType;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	VertexType vex[NUM];	&#x2F;&#x2F;顶点表 </span><br><span class="line">	ArcCell arcs[NUM][NUM];	&#x2F;&#x2F;邻接矩阵 </span><br><span class="line">	int vexnum,arcnum;    	&#x2F;&#x2F;点数和边数 </span><br><span class="line">&#125;MGraph;</span><br><span class="line"></span><br><span class="line">MGraph G;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int D[NUM];									&#x2F;&#x2F;记录最短路径 </span><br><span class="line">int path[NUM];								&#x2F;&#x2F;记录路径 </span><br><span class="line">void CreateUDN(int v,int a);				&#x2F;&#x2F;创建图	</span><br><span class="line">void ShortestPath_DIJ(int num);				&#x2F;&#x2F;求最短路径	</span><br><span class="line">void ShortestPath_Floyed();					&#x2F;&#x2F;求各对顶点之间的最短路径 </span><br><span class="line">void printpath(int sight1,int sight2);		&#x2F;&#x2F;输出任意两点间的最短路径 </span><br><span class="line">void lookAllArc();							&#x2F;&#x2F;浏览任意两地边的信息 </span><br><span class="line">void lookSingleArc();						&#x2F;&#x2F;浏览单一边的信息</span><br><span class="line">void modify(); 								&#x2F;&#x2F;修改两个位置之间的距离 </span><br><span class="line">void welcome();</span><br><span class="line">char Menu();</span><br><span class="line"></span><br><span class="line">void CreateUDN(int v,int a) &#x2F;&#x2F; 创建图的函数</span><br><span class="line">&#123;</span><br><span class="line">	int i,j;</span><br><span class="line">	G.vexnum&#x3D;v;</span><br><span class="line">	G.arcnum&#x3D;a;</span><br><span class="line">	for(i&#x3D;1;i&lt;G.vexnum;++i) G.vex[i].number&#x3D;i;</span><br><span class="line">	G.vex[0].sight&#x3D;&quot;初始化&quot;;</span><br><span class="line">	G.vex[1].sight&#x3D;&quot;西苑门口&quot;;</span><br><span class="line">	G.vex[2].sight&#x3D;&quot;男生宿舍17A公寓&quot;;</span><br><span class="line">	G.vex[3].sight&#x3D;&quot;第三食堂&quot;;</span><br><span class="line">	G.vex[4].sight&#x3D;&quot;大学生活动中心&quot;;</span><br><span class="line">	G.vex[5].sight&#x3D;&quot;西苑图书馆&quot;;</span><br><span class="line">	G.vex[6].sight&#x3D;&quot;篮球场&quot;;</span><br><span class="line">	G.vex[7].sight&#x3D;&quot;教学楼区&quot;;</span><br><span class="line">	G.vex[8].sight&#x3D;&quot;计算机学院办公楼&quot;;</span><br><span class="line">	G.vex[9].sight&#x3D;&quot;中苑门口&quot;;</span><br><span class="line">	G.vex[10].sight&#x3D;&quot;医务室&quot;;</span><br><span class="line">	G.vex[11].sight&#x3D;&quot;中苑图书馆&quot;;</span><br><span class="line">	G.vex[12].sight&#x3D;&quot;体育馆&quot;;</span><br><span class="line">	</span><br><span class="line">	for(i&#x3D;1;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">		for(j&#x3D;1;j&lt;G.vexnum;++j)&#123;	</span><br><span class="line">			G.arcs[i][j].adj&#x3D;Max;		&#x2F;&#x2F;初始化权值为最大，即不通路	</span><br><span class="line">			G.arcs[i][j].info&#x3D;NULL;	</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	G.arcs[1][4].adj&#x3D;G.arcs[4][1].adj&#x3D;500;	</span><br><span class="line">	G.arcs[1][3].adj&#x3D;G.arcs[3][1].adj&#x3D;500;	</span><br><span class="line">	G.arcs[3][5].adj&#x3D;G.arcs[5][3].adj&#x3D;100;	</span><br><span class="line">	G.arcs[9][10].adj&#x3D;G.arcs[10][9].adj&#x3D;400;	</span><br><span class="line">	G.arcs[4][6].adj&#x3D;G.arcs[6][4].adj&#x3D;100;	</span><br><span class="line">	G.arcs[2][5].adj&#x3D;G.arcs[5][2].adj&#x3D;400;	</span><br><span class="line">	G.arcs[2][4].adj&#x3D;G.arcs[4][2].adj&#x3D;300;	</span><br><span class="line">	G.arcs[5][7].adj&#x3D;G.arcs[7][5].adj&#x3D;100;	</span><br><span class="line">	G.arcs[4][6].adj&#x3D;G.arcs[6][4].adj&#x3D;100;	</span><br><span class="line">	G.arcs[4][7].adj&#x3D;G.arcs[7][4].adj&#x3D;200;	</span><br><span class="line">	G.arcs[6][8].adj&#x3D;G.arcs[8][6].adj&#x3D;300;</span><br><span class="line">	G.arcs[7][8].adj&#x3D;G.arcs[8][7].adj&#x3D;200;	</span><br><span class="line">	G.arcs[1][9].adj&#x3D;G.arcs[9][1].adj&#x3D;10;</span><br><span class="line">	G.arcs[10][11].adj&#x3D;G.arcs[11][10].adj&#x3D;400;</span><br><span class="line">	G.arcs[11][12].adj&#x3D;G.arcs[12][11].adj&#x3D;300;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void modify()&#123;</span><br><span class="line">	int sight1,sight2,length;</span><br><span class="line">	printf(&quot;\n\t\t请输入要修改的两地：\n&quot;);	</span><br><span class="line">	scanf(&quot;%d %d&quot;,&amp;sight1,&amp;sight2);</span><br><span class="line">	if(sight1&lt;1||sight1&gt;12||sight2&lt;1||sight2&gt;12)&#123;</span><br><span class="line">		printf(&quot;\n\t\t请输入正确的地名序号~\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(sight2!&#x3D;sight1)&#123;</span><br><span class="line">		if(G.arcs[sight1][sight2].adj&lt;Max)&#123;</span><br><span class="line">			printf(&quot;\n\t请输入从%s到%s的最新路径长度&quot;,G.vex[sight1].sight,G.vex[sight2].sight);	</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;length);</span><br><span class="line">			if(length&lt;Max)&#123;</span><br><span class="line">				G.arcs[sight1][sight2].adj&#x3D;length;</span><br><span class="line">				G.arcs[sight2][sight1].adj&#x3D;	G.arcs[sight1][sight2].adj;</span><br><span class="line">				printf(&quot;\t修改成功！\n&quot;);</span><br><span class="line">			&#125; </span><br><span class="line">			else	printf(&quot;\t请输入有效的路径长度\n&quot;);	</span><br><span class="line">		&#125;</span><br><span class="line">		else printf(&quot;这两地之间没有通路，不能修改！\n&quot;);		</span><br><span class="line">	&#125;</span><br><span class="line">	else printf(&quot;请输入有意义的两地！\n&quot;); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void lookAllArc()&#123;	</span><br><span class="line">	int i,j,n&#x3D;0; </span><br><span class="line">	printf(&quot;\n所有边的信息如下：\n&quot;);	</span><br><span class="line">	for(i&#x3D;1;i&lt;NUM;++i)&#123;</span><br><span class="line">		for(j&#x3D;1;j&lt;NUM;++j)&#123;</span><br><span class="line">			if(G.arcs[i][j].adj&lt;Max)&#123;</span><br><span class="line">				n++;</span><br><span class="line">				printf(&quot;从%s到%s的路径长度是%d\n&quot;,G.vex[i].sight,G.vex[j].sight,G.arcs[i][j].adj); </span><br><span class="line">			&#125;	</span><br><span class="line">			else &#123;</span><br><span class="line">				n++;</span><br><span class="line">				printf(&quot;从%s到%s没有直接的路~\n&quot;,G.vex[i].sight,G.vex[j].sight); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n\n累计%d条记录\n\n&quot;,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void lookSingleArc()&#123;</span><br><span class="line">	int i,j,n&#x3D;0; </span><br><span class="line">	int v0,v1; </span><br><span class="line">	printf(&quot;\n\n\t\t请选择一端的序号（1～12）：&quot;);		</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;v0);		</span><br><span class="line">	printf(&quot;\t\t请选择另一端的序号（1～12）：&quot;);		</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;v1);</span><br><span class="line">	if(v0&lt;1||v0&gt;12||v1&lt;1||v1&gt;12)&#123;</span><br><span class="line">		printf(&quot;\n\t\t请输入正确的地名序号~\n&quot;);</span><br><span class="line">	&#125;			</span><br><span class="line">	else if(G.arcs[v0][v1].adj&lt;Max)&#123;</span><br><span class="line">		printf(&quot;\n\t\t从%s到%s的路径长度是%dm\n&quot;,G.vex[v0].sight,G.vex[v1].sight,G.arcs[v0][v1].adj); </span><br><span class="line">	&#125;	</span><br><span class="line">	else &#123;</span><br><span class="line">		printf(&quot;\n\t\t从%s到%s没有直接的路~\n&quot;,G.vex[v0].sight,G.vex[v1].sight); </span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void ShortestPath_DIJ(int v0) 		&#x2F;&#x2F; 迪杰斯特拉算法最短路径</span><br><span class="line">&#123;	</span><br><span class="line">	int v,w,i;	</span><br><span class="line">	int S[NUM]&#x3D;&#123;0&#125;;	</span><br><span class="line">	int min;	</span><br><span class="line">	for(v&#x3D;1;v&lt;G.vexnum;v++)&#123;		&#x2F;&#x2F;初始化 </span><br><span class="line">		S[v]&#x3D;0;						&#x2F;&#x2F;初始化为空集 </span><br><span class="line">		D[v]&#x3D;G.arcs[v0][v].adj;		&#x2F;&#x2F;将v0到各个终点的长度初始化为权值	</span><br><span class="line">		if(D[v]&lt;Max)&#123;				&#x2F;&#x2F;如果v0和V之间有边，将V的前驱置为v0 </span><br><span class="line">			path[v]&#x3D;v0;		</span><br><span class="line">		&#125;</span><br><span class="line">		else path[v]&#x3D;-1;	 		&#x2F;&#x2F;如果没有边，即没路 </span><br><span class="line">	&#125;</span><br><span class="line">	D[v0]&#x3D;0;						&#x2F;&#x2F;源点到原点的距离为0 </span><br><span class="line">	S[v0]&#x3D;1;						&#x2F;&#x2F;将v0加入S</span><br><span class="line">	</span><br><span class="line">	&#x2F;* 初始化结束，开始主循环，每次求得v0到某个顶点v的最短路径，将v加入S中*&#x2F; </span><br><span class="line">	</span><br><span class="line">	for(i&#x3D;2;i&lt;G.vexnum;++i)&#123;		&#x2F;&#x2F;对其余n-1个顶点依次进行计算 </span><br><span class="line">		min&#x3D;Max;	</span><br><span class="line">		for(w&#x3D;1;w&lt;G.vexnum;++w)				</span><br><span class="line">			if(!S[w]&amp;&amp;D[w]&lt;min)&#123;	&#x2F;&#x2F;选择一条当前的最短路径</span><br><span class="line">				v&#x3D;w;			</span><br><span class="line">				min&#x3D;D[w];		</span><br><span class="line">			&#125;	    </span><br><span class="line">		S[v]&#x3D;1;						&#x2F;&#x2F;将v加入S </span><br><span class="line">		</span><br><span class="line">		for(w&#x3D;1;w&lt;G.vexnum;++w)		&#x2F;&#x2F;更新v0到集合V-S上所有顶点的最短路径长度 </span><br><span class="line">			if(!S[w]&amp;&amp;((D[v]+G.arcs[v][w].adj)&lt;D[w]))&#123;	&#x2F;&#x2F;中转路径更小 </span><br><span class="line">				D[w]&#x3D;D[v]+G.arcs[v][w].adj;		</span><br><span class="line">				path[w]&#x3D;v;		</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ShortestPath_Floyed()&#123;			&#x2F;&#x2F;求各对顶点之间的最短路径</span><br><span class="line">	int P[NUM][NUM];				&#x2F;&#x2F;记录路径</span><br><span class="line">	int Dis[NUM][NUM];				&#x2F;&#x2F;记录最短路径  </span><br><span class="line">	int i,j,k,q&#x3D;0;	</span><br><span class="line">	int end;</span><br><span class="line">	for(i&#x3D;1;i&lt;G.vexnum;i++)&#123;		&#x2F;&#x2F;初始化 </span><br><span class="line">		for(j&#x3D;1;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">			if(i&#x3D;&#x3D;j) Dis[i][j]&#x3D;0;</span><br><span class="line">			else Dis[i][j]&#x3D;G.arcs[i][j].adj;</span><br><span class="line">			if(Dis[i][j]&lt;Max) P[i][j]&#x3D;i;	&#x2F;&#x2F;如果i和j之间有边，将j的前驱置为i</span><br><span class="line">			else P[i][j]&#x3D;-1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(k&#x3D;1;k&lt;G.vexnum;k++)</span><br><span class="line">		for(i&#x3D;1;i&lt;G.vexnum;i++)</span><br><span class="line">			for(j&#x3D;1;j&lt;G.vexnum;j++)	</span><br><span class="line">				if(Dis[i][k]+Dis[k][j]&lt;Dis[i][j])&#123;	</span><br><span class="line">					Dis[i][j]&#x3D;Dis[i][k]+Dis[k][j];		</span><br><span class="line">					P[i][j]&#x3D;P[k][j];	</span><br><span class="line">				&#125;</span><br><span class="line">	</span><br><span class="line">	for(i&#x3D;1;i&lt;G.vexnum;i++)&#123;	</span><br><span class="line">		for(j&#x3D;1;j&lt;G.vexnum;j++)&#123;	</span><br><span class="line">			end&#x3D;j;		</span><br><span class="line">			printf(&quot;\n从%s到%s的最短路径是&quot;,G.vex[i].sight,G.vex[j].sight);	</span><br><span class="line">			printf(&quot;\t(最短距离为 %dm.)\n\t&quot;,Dis[i][j]);	</span><br><span class="line">		    printf(&quot;\n%s&lt;--&quot;,G.vex[j].sight);</span><br><span class="line">			while(P[i][end]!&#x3D;i)&#123;</span><br><span class="line">				end&#x3D;P[i][end];</span><br><span class="line">				printf(&quot;%s&lt;--&quot;,G.vex[end].sight);	</span><br><span class="line">				q&#x3D;q+1;		</span><br><span class="line">				if(q%8&#x3D;&#x3D;0) printf(&quot;\n&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;%s\n&quot;,G.vex[i].sight);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printpath(int sight1,int sight2) &#x2F;&#x2F; 输出函数</span><br><span class="line">&#123;	</span><br><span class="line">	int q&#x3D;0;	</span><br><span class="line">	int end&#x3D;sight2;	</span><br><span class="line">	if(sight1&lt;1||sight1&gt;12||sight2&lt;1||sight2&gt;12)&#123;</span><br><span class="line">		printf(&quot;\n\t\t请输入正确的地名序号~\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(sight1!&#x3D;sight2)&#123;</span><br><span class="line">		printf(&quot;\n\t从%s到%s的最短路径是&quot;,G.vex[sight1].sight,G.vex[sight2].sight);	</span><br><span class="line">		printf(&quot;\t(最短距离为 %dm.)\n\n\t&quot;,D[sight2]);	</span><br><span class="line">	    printf(&quot;%s&lt;--&quot;,G.vex[sight2].sight);</span><br><span class="line">		while(path[end]!&#x3D;sight1)&#123;</span><br><span class="line">			end&#x3D;path[end];</span><br><span class="line">			printf(&quot;%s&lt;--&quot;,G.vex[end].sight);	</span><br><span class="line">			q&#x3D;q+1;		</span><br><span class="line">			if(q%8&#x3D;&#x3D;0) printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%s&quot;,G.vex[sight1].sight);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		printf(&quot;\n\t\t\t从%s到%s的距离为0m\n&quot;,G.vex[sight1].sight,G.vex[sight2].sight);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void welcome() &#x2F;&#x2F;登录图标</span><br><span class="line">&#123;</span><br><span class="line">	int i&#x3D;0; </span><br><span class="line">	printf(&quot;\t\t■■■■■■■■■■■■■■■■■■■■■■■\n&quot;);</span><br><span class="line">	printf(&quot;\t\t■                                          ■\n&quot;);</span><br><span class="line">	printf(&quot;\t\t■  ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■  ■\n&quot;);	</span><br><span class="line">	printf(&quot;\t\t■                                          ■\n&quot;);</span><br><span class="line">	printf(&quot;\t\t■  ■ 欢迎来到X X X X 大学校园导航系统 ■  ■\n&quot;);	</span><br><span class="line">	printf(&quot;\t\t■                                          ■\n&quot;);</span><br><span class="line">	printf(&quot;\t\t■  ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■  ■\n&quot;);</span><br><span class="line">	printf(&quot;\t\t■                                          ■\n&quot;);</span><br><span class="line">	printf(&quot;\t\t■■■■■■■■■■■■■■■■■■■■■■■\n\n&quot;);</span><br><span class="line">	for(i&#x3D;1;i&lt;NUM;i++)&#123;</span><br><span class="line">		printf(&quot;\t\t\t\t(%2d)%-20s\t\t\t\n&quot;,i,G.vex[i].sight);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show()&#123;</span><br><span class="line">	int i,j&#x3D;0;</span><br><span class="line">	for(i&#x3D;0;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">		for(j&#x3D;0;j&lt;G.vexnum;j++)&#123;</span><br><span class="line">			printf(&quot;%8d&quot;,G.arcs[i][j].adj);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main() &#x2F;&#x2F; 主函数</span><br><span class="line">&#123; </span><br><span class="line"> </span><br><span class="line">	int v0,v1;</span><br><span class="line">	char ck;</span><br><span class="line">	CreateUDN(NUM,15);</span><br><span class="line">	&#x2F;&#x2F;show();</span><br><span class="line">	do&#123;</span><br><span class="line">		ck&#x3D;Menu();</span><br><span class="line">		switch(ck)&#123;			</span><br><span class="line">			case &#39;1&#39;:		</span><br><span class="line">				welcome();		</span><br><span class="line">				printf(&quot;\n\n\t\t\t请选择出发地序号（1～12）：&quot;);		</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;v0);		</span><br><span class="line">				printf(&quot;\t\t\t请选择目的地序号（1～12）：&quot;);		</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;v1);		</span><br><span class="line">				ShortestPath_DIJ(v0);		</span><br><span class="line">				printpath(v0,v1);		</span><br><span class="line">				printf(&quot;\n\n\t\t请按回车键继续...\n&quot;);			</span><br><span class="line">				getchar();		</span><br><span class="line">				getchar();		</span><br><span class="line">				break;</span><br><span class="line">			case&#39;2&#39;:	</span><br><span class="line">				lookAllArc();				</span><br><span class="line">				getchar();</span><br><span class="line">				getchar();	</span><br><span class="line">			 	break;</span><br><span class="line">			case&#39;3&#39;:				</span><br><span class="line">				modify();		</span><br><span class="line">				getchar();</span><br><span class="line">				getchar();	</span><br><span class="line">			 	break;</span><br><span class="line">			case&#39;4&#39;:				</span><br><span class="line">				ShortestPath_Floyed();		</span><br><span class="line">				getchar();</span><br><span class="line">				getchar();	</span><br><span class="line">			 	break;	 </span><br><span class="line">			case&#39;5&#39;:				</span><br><span class="line">				lookSingleArc();		</span><br><span class="line">				getchar();</span><br><span class="line">				getchar();	</span><br><span class="line">			 	break;	 	 	</span><br><span class="line">			case&#39;6&#39;:				</span><br><span class="line">				printf(&quot;\n\n有待实现更多功能\n\n&quot;);		</span><br><span class="line">				getchar();</span><br><span class="line">				getchar();	</span><br><span class="line">			 	break;	</span><br><span class="line">		&#125;;	</span><br><span class="line">	&#125;while(ck!&#x3D;&#39;e&#39;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char Menu() &#x2F;&#x2F; 主菜单</span><br><span class="line">&#123;</span><br><span class="line">	char c;</span><br><span class="line">	int flag;</span><br><span class="line">	do&#123;</span><br><span class="line">		welcome();</span><br><span class="line">		flag&#x3D;1;			</span><br><span class="line">		printf(&quot;\t 操作： \n&quot;);</span><br><span class="line">		printf(&quot;\t┏----------------------------┓\n&quot;);</span><br><span class="line">		printf(&quot;\t│ 1.导航                     │\n&quot;);	</span><br><span class="line">		printf(&quot;\t│ 2.查看所有边的路径长度     │\n&quot;);	</span><br><span class="line">		printf(&quot;\t│ 3.修改路径长度             │\n&quot;);	</span><br><span class="line">		printf(&quot;\t│ 4.查看各地间的最短路径长度 │\n&quot;);	</span><br><span class="line">		printf(&quot;\t│ 5.查看单一边的路径长度     │\n&quot;);</span><br><span class="line">		printf(&quot;\t│ e.退出                     │\n&quot;);		</span><br><span class="line">		printf(&quot;\t┗----------------------------┛\n&quot;);</span><br><span class="line">		printf(&quot;\t\t请输入您的选择：&quot;);	</span><br><span class="line">		scanf(&quot;%c&quot;,&amp;c);	</span><br><span class="line">		if(c&#x3D;&#x3D;&#39;1&#39;||c&#x3D;&#x3D;&#39;2&#39;||c&#x3D;&#x3D;&#39;3&#39;||c&#x3D;&#x3D;&#39;4&#39;||c&#x3D;&#x3D;&#39;5&#39;||c&#x3D;&#x3D;&#39;e&#39;)	</span><br><span class="line">			flag&#x3D;0;		</span><br><span class="line">	&#125;while(flag);	</span><br><span class="line">	return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">回到顶部</a></p>
<h1 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h1><p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190715100310587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190715100310587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =600x)<br>迪杰斯特拉（Dijkstra）算法求起点到终点最短路径：<br><img src="https://img-blog.csdnimg.cn/20190715100416296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>弗洛伊德（Floyed）算法求任意两地间的最短距离：<br><img src="https://img-blog.csdnimg.cn/20190715100515686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#top">回到顶部</a></p>
]]></content>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>图的应用--最小生成树</title>
    <url>/2019/07/14/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8--%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<body>
<div id="top"></div>
</body>


<ul>
<li><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>  在一个连通网的所有生成树中，各边的代价之和最小的那颗生成树称为该连通网的最小代价生成树，简称为最小生成树。</p>
<p>  最小生成树主要有两种算法，<strong>普利姆（Prim）算法</strong> &amp;&amp; <strong>克鲁斯卡尔（Kruskal）算法</strong></p>
</li>
<li><h1 id="普利姆（Prim）算法"><a href="#普利姆（Prim）算法" class="headerlink" title="普利姆（Prim）算法"></a>普利姆（Prim）算法</h1><p>  普里姆算法在找最小生成树时，将顶点分为两个集合，一类是在查找的过程中已经包含在树中的顶点集U，另一类V（总-U）顶点集。<br>  从U与V中找一条权值最小的边，同时将V中的顶点并入U中。<br>  可以看出，普利姆（Prim）算法逐步增加U中的顶点，可称为<strong>加点法。</strong></p>
<ul>
<li><h2 id="辅助数组"><a href="#辅助数组" class="headerlink" title="辅助数组"></a>辅助数组</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">	vertexType adjvex;			&#x2F;&#x2F;最小边在U中的顶点 </span><br><span class="line">	arcType lowcost;			&#x2F;&#x2F;最小边的权值 </span><br><span class="line">&#125;ClosEdge;</span><br><span class="line"></span><br><span class="line">ClosEdge closedge[MVNum];</span><br></pre></td></tr></table></figure>
<p>该辅助数组记录着集合U中到集合V中的最小权值边。</p>
</li>
<li><h2 id="普利姆（Prim）算法-1"><a href="#普利姆（Prim）算法-1" class="headerlink" title="普利姆（Prim）算法"></a>普利姆（Prim）算法</h2><p>  <strong><em>需要注意的是：</em></strong> V中的点并入了U中时，需要更新U到V的权值。更新后辅助数组中可能存着U中不同的顶点到V的距离。然后选择最小的作为最小生成树的。</p>
<p>  有点抽象，举个例子说明，结合着代码看：</p>
<pre><code>            ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190714103442723.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70 =300x)</code></pre>
<p>该图以这样的邻接矩阵存着：**<em>Z是一个足够大的值**</em><br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190714104302530.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190714104302530.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =300x)<br>一开始：以V0为起点。closedge[ ]数组如下所示：<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190714110541372.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190714110541372.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =500x200)<br>0是在集合U中的标志，找到最小权值1，对应的V集合中的顶点是下标2位置确定的顶点V3。当然V3与V1连接。<br>此时应该更新V3并入之后，closedge[ ]数组的变化。<br>两段划线的相比，取其小的更新closedge[ ]数组：![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/2019071411095464.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/2019071411095464.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =400x)<br>得到更新后的closedge[ ]数组：<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190714110611867.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190714110611867.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =500x200)<br>找到最小权值4，对应的V集合中的顶点是下标5位置确定的顶点V6。当然V6与V3连接。<br>然后将V6并入U集合中，这样以此类推。。。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Prim(Graph g, vertexType u) &#123;			&#x2F;&#x2F;分成两堆。U集合与V集合(总-U) </span><br><span class="line">	int weight&#x3D;0;							&#x2F;&#x2F;累计最小生成树的权值 </span><br><span class="line">	int i,j,k;</span><br><span class="line">	</span><br><span class="line">	k&#x3D;FindPos(g,u);  						&#x2F;&#x2F;以u为起点，确定u的位置 </span><br><span class="line"></span><br><span class="line">    for (i &#x3D; 0; i &lt; g-&gt;vexnum; i++) &#123;</span><br><span class="line">        if(i!&#x3D;k)&#123;</span><br><span class="line">        	closedge[i]&#x3D;&#123;u,g-&gt;Arc[k][i]&#125;; 	&#x2F;&#x2F;u顶点到，i位置确定的顶点，的权值，初始化为邻接表中对应的值 </span><br><span class="line">		&#125;</span><br><span class="line">    &#125;   </span><br><span class="line">   </span><br><span class="line">	closedge[k].lowcost&#x3D;0;   				&#x2F;&#x2F; 初始时U集合只有u点，在U集合里，就记为0 </span><br><span class="line"></span><br><span class="line">	for (j &#x3D; 1; j &lt; g-&gt;vexnum; j++) &#123;</span><br><span class="line">		</span><br><span class="line">		k&#x3D;Min(g,closedge);					&#x2F;&#x2F;找到最小权值。当然也就知道顶点 </span><br><span class="line">		</span><br><span class="line">		vertexType u0 &#x3D; closedge[k].adjvex; &#x2F;&#x2F;最小边在U中的顶点 </span><br><span class="line">		vertexType v0 &#x3D; g-&gt;vertex[k];		&#x2F;&#x2F;最小边在V中的顶点 </span><br><span class="line">		printf(&quot;%c,%c\n&quot;,u0,v0);</span><br><span class="line">		</span><br><span class="line">		weight&#x3D;weight+g-&gt;Arc[FindPos(g,u0)][k];				&#x2F;&#x2F;最小生成树的权值 </span><br><span class="line">		</span><br><span class="line">		closedge[k].lowcost&#x3D;0;								&#x2F;&#x2F;将k确定的顶点放入集合U中 </span><br><span class="line">		</span><br><span class="line">		for (i &#x3D; 0; i &lt; g-&gt;vexnum; i++) &#123;   				&#x2F;&#x2F;由于k顶点加入U中，检查k到其他顶点的权值是否比k加入之前小  </span><br><span class="line">			if (g-&gt;Arc[k][i] &lt; closedge[i].lowcost) &#123;</span><br><span class="line">			    closedge[i] &#x3D;&#123;g-&gt;vertex[k],g-&gt;Arc[k][i]&#125;;	&#x2F;&#x2F; 更新</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;   </span><br><span class="line">	return weight;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">回到顶部</a></p>
</li>
<li><h2 id="具体代码："><a href="#具体代码：" class="headerlink" title="具体代码："></a>具体代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MVNum 10				&#x2F;&#x2F;最大顶点数 </span><br><span class="line">#define MAXINT 32768			&#x2F;&#x2F;表示极大值</span><br><span class="line"> </span><br><span class="line">typedef int arcType;</span><br><span class="line">typedef char vertexType;</span><br><span class="line"></span><br><span class="line">typedef struct MNode&#123;</span><br><span class="line">	vertexType vertex[MVNum];	&#x2F;&#x2F;存储顶点 </span><br><span class="line">	arcType Arc[MVNum][MVNum];	&#x2F;&#x2F;邻接矩阵，存储边 </span><br><span class="line">	int vexnum,arcnum;</span><br><span class="line">&#125;GraphNode,*Graph;</span><br><span class="line"></span><br><span class="line">int Init(Graph &amp;G)&#123;</span><br><span class="line">	G&#x3D;(GraphNode *)malloc(sizeof(GraphNode));</span><br><span class="line">	G-&gt;vexnum&#x3D;0;</span><br><span class="line">	G-&gt;arcnum&#x3D;0;</span><br><span class="line">	if(G) return 1;</span><br><span class="line">	else cout&lt;&lt;&quot;初始化出错！&quot;&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FindPos(Graph G,char a)&#123;&#x2F;&#x2F;查找位置 </span><br><span class="line">	int pos&#x3D;-1;</span><br><span class="line">	for(int i&#x3D;0;i&lt;G-&gt;vexnum;i++)&#123;</span><br><span class="line">		if(G-&gt;vertex[i]&#x3D;&#x3D;a)&#123;</span><br><span class="line">			pos&#x3D;i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreateUDN(Graph G)			&#x2F;&#x2F;创建无向网</span><br><span class="line">&#123;</span><br><span class="line">	int num&#x3D;0,					&#x2F;&#x2F;控制输入顶点数 </span><br><span class="line">		pos1,pos2,				&#x2F;&#x2F;确认顶点位置 </span><br><span class="line">		i,j,</span><br><span class="line">		weight;					&#x2F;&#x2F;权值 </span><br><span class="line">	char a,</span><br><span class="line">		 b,</span><br><span class="line">		 ch;					&#x2F;&#x2F;顶点 </span><br><span class="line">		 </span><br><span class="line">	for(i &#x3D; 0;i&lt;MVNum; i++)&#123; 	&#x2F;&#x2F;初始化弧</span><br><span class="line">        for(j &#x3D; 0;j&lt;MVNum; j++)&#123;</span><br><span class="line">            G-&gt;Arc[i][j] &#x3D; MAXINT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入顶点(不超过10个，以#结束):\n&quot;);</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    while(ch!&#x3D;&#39;#&#39; &amp;&amp; num &lt;10)&#123;</span><br><span class="line">        G-&gt;vertex[num] &#x3D; ch;</span><br><span class="line">        cin&gt;&gt;ch;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;vexnum &#x3D; num;  &#x2F;&#x2F;顶点个数</span><br><span class="line">    cout&lt;&lt;&quot;请输入对应的弧（ab与ba是一样的边）和权值，以###结束&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;weight;</span><br><span class="line">    while(a!&#x3D;&#39;#&#39; &amp;&amp; b!&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&quot;-&quot;&lt;&lt;b&lt;&lt;&quot;:&quot;&lt;&lt;weight&lt;&lt;endl;</span><br><span class="line">        pos1&#x3D;FindPos(G,a);</span><br><span class="line">        pos2&#x3D;FindPos(G,b);</span><br><span class="line">        printf(&quot;位置a:%d,位置b:%d\n&quot;,pos1,pos2);</span><br><span class="line">        if(pos1!&#x3D; -1 &amp;&amp; pos2!&#x3D; -1)&#123;  &#x2F;&#x2F;忽略不存在的顶点</span><br><span class="line">            G-&gt;Arc[pos1][pos2] &#x3D; weight;</span><br><span class="line">            G-&gt;Arc[pos2][pos1] &#x3D; weight;</span><br><span class="line">            G-&gt;arcnum++;</span><br><span class="line">        &#125;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PrintGraph(Graph g) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;图的顶点为:&quot; &lt;&lt; endl;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; g-&gt;vexnum; i++) &#123;</span><br><span class="line">        cout &lt;&lt; g-&gt;vertex[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;图的邻接矩阵为:&quot; &lt;&lt; endl;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; g-&gt;vexnum; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; g-&gt;vexnum; j++) &#123;</span><br><span class="line">            printf(&quot;%10d &quot;,g-&gt;Arc[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	vertexType adjvex;			&#x2F;&#x2F;最小边在U中的顶点 </span><br><span class="line">	arcType lowcost;			&#x2F;&#x2F;最小边的权值 </span><br><span class="line">&#125;ClosEdge;</span><br><span class="line"></span><br><span class="line">ClosEdge closedge[MVNum];</span><br><span class="line"></span><br><span class="line">int Min(Graph g,ClosEdge a[])&#123;</span><br><span class="line">	int j&#x3D;0;</span><br><span class="line">	int min&#x3D;MAXINT;</span><br><span class="line">	for(int i&#x3D;0;i&lt;g-&gt;vexnum;i++)&#123;</span><br><span class="line">		if(a[i].lowcost!&#x3D;0 &amp;&amp; a[i].lowcost&lt;min)&#123;</span><br><span class="line">			min&#x3D;a[i].lowcost;</span><br><span class="line">			j&#x3D;i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Prim(Graph g, vertexType u) &#123;			&#x2F;&#x2F;分成两堆。U集合与V集合(总-U) </span><br><span class="line">	int weight&#x3D;0;							&#x2F;&#x2F;累计最小生成树的权值 </span><br><span class="line">	int i,j,k;</span><br><span class="line">	</span><br><span class="line">	k&#x3D;FindPos(g,u);  						&#x2F;&#x2F;以u为起点，确定u的位置 </span><br><span class="line"></span><br><span class="line">    for (i &#x3D; 0; i &lt; g-&gt;vexnum; i++) &#123;</span><br><span class="line">        if(i!&#x3D;k)&#123;</span><br><span class="line">        	closedge[i]&#x3D;&#123;u,g-&gt;Arc[k][i]&#125;; 	&#x2F;&#x2F;u顶点到，i位置确定的顶点，的权值，初始化为邻接表中对应的值 </span><br><span class="line">		&#125;</span><br><span class="line">    &#125;   </span><br><span class="line">   </span><br><span class="line">	closedge[k].lowcost&#x3D;0;   				&#x2F;&#x2F; 初始时U集合只有u点，在U集合里，就记为0 </span><br><span class="line"></span><br><span class="line">	for (j &#x3D; 1; j &lt; g-&gt;vexnum; j++) &#123;</span><br><span class="line">		</span><br><span class="line">		k&#x3D;Min(g,closedge);					&#x2F;&#x2F;找到最小权值。当然也就知道顶点 </span><br><span class="line">		</span><br><span class="line">		vertexType u0 &#x3D; closedge[k].adjvex; &#x2F;&#x2F;最小边在U中的顶点 </span><br><span class="line">		vertexType v0 &#x3D; g-&gt;vertex[k];		&#x2F;&#x2F;最小边在V中的顶点 </span><br><span class="line">		printf(&quot;%c,%c\n&quot;,u0,v0);</span><br><span class="line">		</span><br><span class="line">		weight&#x3D;weight+g-&gt;Arc[FindPos(g,u0)][k];				&#x2F;&#x2F;最小生成树的权值 </span><br><span class="line">		</span><br><span class="line">		closedge[k].lowcost&#x3D;0;								&#x2F;&#x2F;将k确定的顶点放入集合U中 </span><br><span class="line">		</span><br><span class="line">		for (i &#x3D; 0; i &lt; g-&gt;vexnum; i++) &#123;   				&#x2F;&#x2F;由于k顶点加入U中，检查k到其他顶点的权值是否比k加入之前小  </span><br><span class="line">			if (g-&gt;Arc[k][i] &lt; closedge[i].lowcost) &#123;</span><br><span class="line">			    closedge[i] &#x3D;&#123;g-&gt;vertex[k],g-&gt;Arc[k][i]&#125;;	&#x2F;&#x2F; 更新</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;   </span><br><span class="line">	return weight;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Graph G &#x3D; NULL;</span><br><span class="line">    Init(G);</span><br><span class="line">    CreateUDN(G);</span><br><span class="line">	PrintGraph(G);</span><br><span class="line">	cout&lt;&lt;&quot;权值&quot;&lt;&lt;Prim(G,&#39;1&#39;)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">回到顶部</a></p>
</li>
<li><h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p><img src="https://img-blog.csdnimg.cn/20190714112634256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190714112805124.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#top">回到顶部</a></p>
</li>
</ul>
</li>
<li><h1 id="克鲁斯卡尔（Kruskal）算法"><a href="#克鲁斯卡尔（Kruskal）算法" class="headerlink" title="克鲁斯卡尔（Kruskal）算法"></a>克鲁斯卡尔（Kruskal）算法</h1><p>  克鲁斯卡尔（Kruskal）算法在找最小生成树时，先将边按权值大小排好序，在直接去拿最小的权值边，只需保证拿来的边不能产生回路即可。当拿了（n-1）条边且没有回路，就能构成最小生成树。<br>  可以看出，克鲁斯卡尔（Kruskal）算法逐步增加生成树的边，可称为<strong>加边法。</strong></p>
<p>  而保证拿来的边不能产生回路，需要一个辅助数组，初始时，数组里存着每个顶点不同的标记，即n个连通分量。当拿来一条边，看看这条边依附的两个顶点的标记相不相等，如果等，则说明在一个连通分量里，即会产生回路。不相等，则能构成最小生成树的边。</p>
<ul>
<li><h2 id="克鲁斯卡尔（Kruskal）算法-1"><a href="#克鲁斯卡尔（Kruskal）算法-1" class="headerlink" title="克鲁斯卡尔（Kruskal）算法"></a>克鲁斯卡尔（Kruskal）算法</h2><p>  当确定了一条边时，需要将v2顶点及其与v2标记一样的顶点的标记改为v1的标记，因为他们在一个连通分量里。<br>  还是上面那个网，当克鲁斯卡尔（Kruskal）算法选到这一步时，即将选择顶点3和6，不仅6要改为3的标记，4也要改为3的标记。所以需要用循环判断去改变标记。<br>  <img src="https://img-blog.csdnimg.cn/20190714115023103.png" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Kruskal(Graph G)    &#x2F;&#x2F;最小生成树，克鲁斯卡尔算法</span><br><span class="line">&#123;</span><br><span class="line">	int i,j;</span><br><span class="line">	int V1,V2; </span><br><span class="line">	int vs1,vs2; </span><br><span class="line">	int weight&#x3D;0;     &#x2F;&#x2F;累计最小生成树权值 </span><br><span class="line">	Sort(G,G-&gt;edges);</span><br><span class="line">	for (i &#x3D; 0; i &lt; G-&gt;vexnum; i++)&#123;</span><br><span class="line">		Vexset[i] &#x3D; i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; G-&gt;arcnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		V1 &#x3D; FindPos(G, G-&gt;edges[i].initial);</span><br><span class="line">		V2 &#x3D; FindPos(G, G-&gt;edges[i].end);</span><br><span class="line">		</span><br><span class="line">		vs1&#x3D;Vexset[V1];</span><br><span class="line">		vs2&#x3D;Vexset[V2];</span><br><span class="line">		</span><br><span class="line">		if (vs1 !&#x3D; vs2)			&#x2F;&#x2F;若相等，说明有环</span><br><span class="line">		&#123;</span><br><span class="line">			weight&#x3D; weight+ G-&gt;edges[i].weight;  &#x2F;&#x2F;累计最小生成树权值 </span><br><span class="line">			printf(&quot;(%c,%c):%d\n&quot;, G-&gt;edges[i].initial, G-&gt;edges[i].end, G-&gt;edges[i].weight);&#x2F;&#x2F;打印边和权值</span><br><span class="line">			for(j&#x3D;0;j&lt;G-&gt;vexnum;j++)&#123;	&#x2F;&#x2F;之所以要循环，就是因为有时(边变多时)，要改变标记的点不止一个。 </span><br><span class="line">				if(Vexset[j]&#x3D;&#x3D;vs2)&#123;</span><br><span class="line">					Vexset[j]&#x3D;vs1;</span><br><span class="line">				&#125;					</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return weight; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="#top">回到顶部</a></p>
</li>
<li><h2 id="具体代码：-1"><a href="#具体代码：-1" class="headerlink" title="具体代码："></a>具体代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MVNum 10			&#x2F;&#x2F;最大顶点数 </span><br><span class="line"> </span><br><span class="line">typedef int arcType;</span><br><span class="line">typedef char vertexType;</span><br><span class="line"></span><br><span class="line">typedef struct edge&#123;</span><br><span class="line">    vertexType initial;		&#x2F;&#x2F;类似邻接矩阵横坐标 </span><br><span class="line">    vertexType end;			&#x2F;&#x2F;类似邻接矩阵纵坐标 </span><br><span class="line">    arcType weight;			&#x2F;&#x2F;权值</span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line">typedef struct MNode&#123;</span><br><span class="line">	vertexType vertex[MVNum];	&#x2F;&#x2F;存储顶点 </span><br><span class="line">	Edge edges[MVNum]; 			&#x2F;&#x2F;类似邻接矩阵</span><br><span class="line">	int vexnum,arcnum;</span><br><span class="line">&#125;GraphNode,*Graph;</span><br><span class="line"></span><br><span class="line">int Vexset[MVNum];</span><br><span class="line"></span><br><span class="line">int Init(Graph &amp;G)&#123;</span><br><span class="line">	G&#x3D;(GraphNode *)malloc(sizeof(GraphNode));</span><br><span class="line">	G-&gt;vexnum&#x3D;0;</span><br><span class="line">	G-&gt;arcnum&#x3D;0;</span><br><span class="line">	if(G) return 1;</span><br><span class="line">	else cout&lt;&lt;&quot;初始化出错！&quot;&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FindPos(Graph G,char a)&#123;&#x2F;&#x2F;查找位置 </span><br><span class="line">	int pos&#x3D;-1;</span><br><span class="line">	for(int i&#x3D;0;i&lt;G-&gt;vexnum;i++)&#123;</span><br><span class="line">		if(G-&gt;vertex[i]&#x3D;&#x3D;a)&#123;</span><br><span class="line">			pos&#x3D;i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreateUDN(Graph G)			&#x2F;&#x2F;创建无向网</span><br><span class="line">&#123;</span><br><span class="line">	int num&#x3D;0,					&#x2F;&#x2F;控制输入顶点数 </span><br><span class="line">		pos1,pos2,				&#x2F;&#x2F;确认顶点位置 </span><br><span class="line">		weight;					&#x2F;&#x2F;权值 </span><br><span class="line">	char  ch;					&#x2F;&#x2F;顶点 </span><br><span class="line">	Edge e;						&#x2F;&#x2F;边 </span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入顶点(不超过10个，以#结束):\n&quot;);</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    while(ch!&#x3D;&#39;#&#39; &amp;&amp; num &lt;10)&#123;</span><br><span class="line">        G-&gt;vertex[num] &#x3D; ch;</span><br><span class="line">        cin&gt;&gt;ch;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;vexnum &#x3D; num;  &#x2F;&#x2F;顶点个数</span><br><span class="line">    cout&lt;&lt;&quot;请输入对应的弧（ab与ba是一样的边）和权值，以###结束&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;e.initial&gt;&gt;e.end&gt;&gt;e.weight;</span><br><span class="line">    int k&#x3D;0;</span><br><span class="line">    while(e.initial!&#x3D;&#39;#&#39; &amp;&amp; e.initial!&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">        cout&lt;&lt;e.initial&lt;&lt;&quot;-&quot;&lt;&lt;e.end&lt;&lt;&quot;:&quot;&lt;&lt;e.weight&lt;&lt;endl;</span><br><span class="line">        G-&gt;arcnum++;</span><br><span class="line">        G-&gt;edges[k] &#x3D; e;</span><br><span class="line">        cin&gt;&gt;e.initial&gt;&gt;e.end&gt;&gt;e.weight;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PrintGraph(Graph g) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;图的顶点为:&quot; &lt;&lt; endl;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; g-&gt;vexnum; i++) &#123;</span><br><span class="line">        cout &lt;&lt; g-&gt;vertex[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;图的边为:&quot; &lt;&lt; endl;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; g-&gt;arcnum; j++) &#123;</span><br><span class="line">        printf(&quot;起点%c，终点%c,权值%8d\n&quot;,g-&gt;edges[j].initial,g-&gt;edges[j].end,g-&gt;edges[j].weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Sort(Graph g,Edge a[])&#123;</span><br><span class="line">	Edge temp;		</span><br><span class="line">	for(int i&#x3D;1;i&lt;g-&gt;arcnum;i++)&#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;g-&gt;arcnum-i;j++)&#123;</span><br><span class="line">			if(a[j].weight&gt;a[j+1].weight)&#123;</span><br><span class="line">				temp&#x3D;a[j];</span><br><span class="line">				a[j]&#x3D;a[j+1];</span><br><span class="line">				a[j+1]&#x3D;temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Kruskal(Graph G)    &#x2F;&#x2F;最小生成树，克鲁斯卡尔算法</span><br><span class="line">&#123;</span><br><span class="line">	int i,j;</span><br><span class="line">	int V1,V2; </span><br><span class="line">	int vs1,vs2; </span><br><span class="line">	int weight&#x3D;0;     &#x2F;&#x2F;累计最小生成树权值 </span><br><span class="line">	Sort(G,G-&gt;edges);</span><br><span class="line">	for (i &#x3D; 0; i &lt; G-&gt;vexnum; i++)&#123;</span><br><span class="line">		Vexset[i] &#x3D; i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; G-&gt;arcnum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		V1 &#x3D; FindPos(G, G-&gt;edges[i].initial);</span><br><span class="line">		V2 &#x3D; FindPos(G, G-&gt;edges[i].end);</span><br><span class="line">		</span><br><span class="line">		vs1&#x3D;Vexset[V1];</span><br><span class="line">		vs2&#x3D;Vexset[V2];</span><br><span class="line">		</span><br><span class="line">		if (vs1 !&#x3D; vs2)			&#x2F;&#x2F;若相等，说明有环</span><br><span class="line">		&#123;</span><br><span class="line">			weight&#x3D; weight+ G-&gt;edges[i].weight;  &#x2F;&#x2F;累计最小生成树权值 </span><br><span class="line">			printf(&quot;(%c,%c):%d\n&quot;, G-&gt;edges[i].initial, G-&gt;edges[i].end, G-&gt;edges[i].weight);&#x2F;&#x2F;打印边和权值</span><br><span class="line">			for(j&#x3D;0;j&lt;G-&gt;vexnum;j++)&#123;	&#x2F;&#x2F;之所以要循环，就是因为有时(边变多时)，要改变标记的点不止一个。 </span><br><span class="line">				if(Vexset[j]&#x3D;&#x3D;vs2)&#123;</span><br><span class="line">					Vexset[j]&#x3D;vs1;</span><br><span class="line">				&#125;					</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return weight; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Graph G &#x3D; NULL;</span><br><span class="line">    Init(G);</span><br><span class="line">    CreateUDN(G);</span><br><span class="line">	PrintGraph(G);</span><br><span class="line">	cout&lt;&lt;&quot;最小生成树权值&quot;&lt;&lt;Kruskal(G);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">回到顶部</a></p>
</li>
<li><h2 id="运行结果：-1"><a href="#运行结果：-1" class="headerlink" title="运行结果："></a>运行结果：</h2><p>  <img src="https://img-blog.csdnimg.cn/2019071412134543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190714121410730.png" alt="在这里插入图片描述"><br><a href="#top">回到顶部</a></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2019/07/11/%E5%9B%BE/</url>
    <content><![CDATA[<body>
<div id="top"></div>
</body>


<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>简单对比一下<a href="https://blog.csdn.net/songsongL">线性表</a>、<a href="https://blog.csdn.net/songsongL/article/details/94827401">树</a> 、图：<br><img src="https://img-blog.csdnimg.cn/20190709095349341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上图可以看出图结构是很复杂的，研究图结构的一个专门理论工具便是图论。</p>
<h1 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h1><h2 id="图结构："><a href="#图结构：" class="headerlink" title="图结构："></a>图结构：</h2><ul>
<li>顶点（Vertex）：图中的数据元素。</li>
<li>边（Edge）：图中连接这些顶点的线。<br>一个完整的图结构由顶点集合和边集合组成。<br>G = (V，E)<br>其中，V表示图中所有顶点的集合，必须为非空。E表示图中所有边的集合，可以为空，此时表示没有边。<h2 id="有向图与无向图"><a href="#有向图与无向图" class="headerlink" title="有向图与无向图"></a>有向图与无向图</h2>有向图：在图结构中，边有方向性，这种图便称为有向图。*<strong>在表示边时，与顶点的顺序有关。***<br>无向图：在图结构中，边没有方向性，这种图便称为无向图。*</strong>在表示边时，与顶点的顺序无关。***<h2 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h2>假设有两个图G = (V，E)和G’ = (V’，E’)，如果V’∈V <strong><em>且</em></strong> E’∈E，则称G’为G的子图。</li>
</ul>
<p><strong><em>注意：只有顶点集合是子集，或者只有边集合是子集的，都不是子图。</em></strong></p>
<h2 id="无向完全图与有向完全图"><a href="#无向完全图与有向完全图" class="headerlink" title="无向完全图与有向完全图"></a>无向完全图与有向完全图</h2><p>无向完全图：如果在一个无向图中，每两个顶点之间都存在一条边（即<strong>n(n-1)/2</strong>条），这种图结构称为无向完全图。<br>有向完全图：如果在一个有向图中，每两个顶点之间都存在方向相反的两条边（即**n(n-1)**条），这种图结构称为有向完全图。</p>
<h2 id="权和网"><a href="#权和网" class="headerlink" title="权和网"></a>权和网</h2><p>在实际应用中，每条边可以标上带有具体含义的数值，该数值称为该边上的<strong>权</strong>。<br>这种带权的图就叫<strong>网</strong>。</p>
<h2 id="邻接顶点"><a href="#邻接顶点" class="headerlink" title="邻接顶点"></a>邻接顶点</h2><p>两个点确定一条边，这两点就是邻接顶点。<br>有向图稍微复杂一点，两个顶点分为起始顶点和结束顶点（因为有方向）。</p>
<p><a href="#top">返回目录<a></p>
<h2 id="顶点的度"><a href="#顶点的度" class="headerlink" title="顶点的度"></a>顶点的度</h2><p>连接顶点的边的数量称为顶点的度。<br>有向图稍微复杂一点，根据方向性可分为<strong>入度和出度</strong>。<br>入度：箭头指向自己的边的数量。ID(V)。<br>出度：箭头往外指的边的数量。OD(V)。<br>D(V)=ID(V)+OD(V)<br><em>一般地，所有顶点的度的和加起来除以2等于图的边数：</em><br>$$ e=\sum_{i=0}^n D(V<del>i</del>) $$</p>
<h2 id="路径和路径长度"><a href="#路径和路径长度" class="headerlink" title="路径和路径长度"></a>路径和路径长度</h2><p>路径指图结构中两个顶点之间要走的边，路径上边的数量称为路径长度。<br><img src="https://img-blog.csdnimg.cn/2019070911225779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如图所示，从V<del>5</del> 到 V<del>2</del> 其中一条路径为（V<del>5</del>，V<del>4</del>）、（V<del>4</del>，V<del>2</del>），路径长度为2。</p>
<h2 id="回路或环"><a href="#回路或环" class="headerlink" title="回路或环"></a>回路或环</h2><p>第一个顶点和最后一个顶点相同的路径称为回路或环。</p>
<h2 id="简单路径与简单回路"><a href="#简单路径与简单回路" class="headerlink" title="简单路径与简单回路"></a>简单路径与简单回路</h2><p>简单路径：在图结构中，如果一条路径上的顶点不重复出现，则称为简单路径。<br>简单回路：在图结构中，如果除了第一个顶点和最后一个顶点相同，其余各顶点都不重复的回路称为简单回路。</p>
<h2 id="连通、连通图和连通分量—-无向图"><a href="#连通、连通图和连通分量—-无向图" class="headerlink" title="连通、连通图和连通分量—-无向图"></a>连通、连通图和连通分量—-无向图</h2><p>连通：如果图结构中两个顶点之间有路径，则这两个顶点是连通的。<br>**<em>注意：连通的两个顶点未必是邻接顶点，只要有路径走得通即可。**</em></p>
<p>连通图：如果无向图中 <strong><em>任意</em></strong> 两个顶点都是连通的，那么这个图便称为连通图。<br>该图的连通分量。<br>对于一个连通图，其连通分量有且只有一个，那就是该连通图自身。</p>
<h2 id="强连通图和强连通分量—-有向图"><a href="#强连通图和强连通分量—-有向图" class="headerlink" title="强连通图和强连通分量—-有向图"></a>强连通图和强连通分量—-有向图</h2><p>强连通图：任意两个顶点V<del>i</del>，V<del>j</del>，从V<del>i</del> 到 V<del>j</del> 和从V<del>j</del> 到 V<del>i</del> 都存在路径，那么这个图便称为强连通图。<br>强连通分量：有向图的极大强连通子图称为该图的强连通分量。<br>对于一个强连通图，其强连通分量有且只有一个，那就是该强连通图自身。</p>
<p><a href="#top">返回目录<a></p>
<ul>
<li><h1 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h1><ul>
<li><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2>  采用二维数组的形式保存顶点之间的关系。该数组称为邻接矩阵。<br>  除了一个用于存储邻接矩阵的二维数组外，还需要用一个一维数组来存储顶点信息。<br>  <strong>无权值：</strong><br><img src="https://img-blog.csdnimg.cn/20190710091949460.png" alt="![A[i][j]=](https://img-blog.csdnimg.cn/20190710091911355.png"></li>
</ul>
<p>  <strong>有权值：</strong><br>  <img src="https://img-blog.csdnimg.cn/20190710092147716.png" alt="在这里插入图片描述"><br>  对于无向图，其邻接矩阵左下角和右上角是对称的。</p>
<ul>
<li><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2>   对图中每个顶点Vi建立一个单链表，把与Vi的邻接点放在这个链中。Vi存在头结点中，其余结点存放邻接点边的信息。<br>   这样邻接表便由两部分组成：**<em>表头结点表和边表。**</em><br>   表头结点表：由所有头结点顺序存储，以便可以随机访问任意顶点的边表。结点包括两个域，数据域，存放顶点名。指针域，指向第一个结点（第一个邻接点）。<br>   边表：结点包括三个域。邻接点域，存放该邻接点在图中的位置。数据域，存放权值。指针域，指向下一邻接点。<pre><code>                   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190710155806527.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70 =300x300)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190710155821686.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70 =600x300)</code></pre>
</li>
<li><h2 id="邻接矩阵与邻接表的比较"><a href="#邻接矩阵与邻接表的比较" class="headerlink" title="邻接矩阵与邻接表的比较"></a>邻接矩阵与邻接表的比较</h2><img src="https://img-blog.csdnimg.cn/20190710152633872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <a href="#top">返回目录<a></li>
</ul>
<h1 id="图的操作"><a href="#图的操作" class="headerlink" title="图的操作"></a>图的操作</h1></li>
<li><h2 id="采用邻接矩阵表示法"><a href="#采用邻接矩阵表示法" class="headerlink" title="采用邻接矩阵表示法"></a>采用邻接矩阵表示法</h2><p>  由上面图的基本概念可知，创建图与网的区别就是增加一个权值。<br>  创建有向无向的区别就是无向可以默认生成 <strong><em>对称信息</em></strong>，有向 <strong><em>来与回</em></strong> 不同步。</p>
<ul>
<li><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct MNode&#123;</span><br><span class="line">	vertexType vertex[MVNum];	&#x2F;&#x2F;存储顶点 </span><br><span class="line">	arcType Arc[MVNum][MVNum];	&#x2F;&#x2F;邻接矩阵，存储边 </span><br><span class="line">	int vexnum,arcnum;</span><br><span class="line">   	GraphKind kind;				&#x2F;&#x2F;图的种类，有向无向等 </span><br><span class="line">&#125;GraphNode,*Graph;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="创建无向图"><a href="#创建无向图" class="headerlink" title="创建无向图"></a>创建无向图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CreateUDG(Graph G)			&#x2F;&#x2F;创建无向图 </span><br><span class="line">&#123;</span><br><span class="line">	int num&#x3D;0,					&#x2F;&#x2F;控制输入顶点数 </span><br><span class="line">		pos1,pos2,				&#x2F;&#x2F;确认顶点位置 </span><br><span class="line">		i,j;</span><br><span class="line">	char a,</span><br><span class="line">		 b,</span><br><span class="line">		 ch;					&#x2F;&#x2F;顶点 </span><br><span class="line">    for(i &#x3D; 0;i&lt;MVNum;i++)&#123; 	&#x2F;&#x2F;初始化弧</span><br><span class="line">        for(j &#x3D; 0;j&lt;MVNum;j++)&#123;</span><br><span class="line">            G-&gt;Arc[i][j] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;kind &#x3D; UDG; 				&#x2F;&#x2F;图的类型为无向图 </span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入顶点(不超过10个，以#结束):\n&quot;);</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    while(ch!&#x3D;&#39;#&#39; &amp;&amp; num &lt;10)&#123;</span><br><span class="line">        G-&gt;vertex[num] &#x3D; ch;</span><br><span class="line">        cin&gt;&gt;ch;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;vexnum &#x3D; num;  			&#x2F;&#x2F;顶点个数</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;请输入对应的弧（ab与ba是一样的边），以##结束&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    while(a!&#x3D;&#39;#&#39; &amp;&amp; b!&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&quot;-&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">        FindPos(G,a,b,pos1,pos2);</span><br><span class="line">        printf(&quot;位置a:%d,位置b:%d\n&quot;,pos1,pos2);</span><br><span class="line">        if(pos1!&#x3D; -1 &amp;&amp; pos2!&#x3D; -1)&#123;  &#x2F;&#x2F;忽略不存在的顶点</span><br><span class="line">            G-&gt;Arc[pos1][pos2] &#x3D; 1;</span><br><span class="line">            G-&gt;Arc[pos2][pos1] &#x3D; 1;</span><br><span class="line">            G-&gt;arcnum++;</span><br><span class="line">        &#125;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="创建无向网"><a href="#创建无向网" class="headerlink" title="创建无向网"></a>创建无向网</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CreateUDN(Graph G)			&#x2F;&#x2F;创建无向网</span><br><span class="line">&#123;</span><br><span class="line">	int num&#x3D;0,					&#x2F;&#x2F;控制输入顶点数 </span><br><span class="line">		pos1,pos2,				&#x2F;&#x2F;确认顶点位置 </span><br><span class="line">		i,j,</span><br><span class="line">		weight;					&#x2F;&#x2F;权值 </span><br><span class="line">	char a,</span><br><span class="line">		 b,</span><br><span class="line">		 ch;					&#x2F;&#x2F;顶点 </span><br><span class="line">		 </span><br><span class="line">	for(i &#x3D; 0;i&lt;MVNum; i++)&#123; &#x2F;&#x2F;初始化弧</span><br><span class="line">        for(j &#x3D; 0;j&lt;MVNum; j++)&#123;</span><br><span class="line">            G-&gt;Arc[i][j] &#x3D; MAXINT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;kind &#x3D; UDN; &#x2F;&#x2F;设置图的类型</span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入顶点(不超过10个，以#结束):\n&quot;);</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    while(ch!&#x3D;&#39;#&#39; &amp;&amp; num &lt;10)&#123;</span><br><span class="line">        G-&gt;vertex[num] &#x3D; ch;</span><br><span class="line">        scanf(&quot;%c&quot;,&amp;ch);</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;vexnum &#x3D; num;  &#x2F;&#x2F;顶点个数</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;请输入对应的弧（ab与ba是一样的边）和权值，以###结束&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;weight;</span><br><span class="line">    while(a!&#x3D;&#39;#&#39; &amp;&amp; b!&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&quot;-&quot;&lt;&lt;b&lt;&lt;&quot;:&quot;&lt;&lt;weight&lt;&lt;endl;</span><br><span class="line">        FindPos(G,a,b,pos1,pos2);</span><br><span class="line">        printf(&quot;位置a:%d,位置b:%d\n&quot;,pos1,pos2);</span><br><span class="line">        if(pos1!&#x3D; -1 &amp;&amp; pos2!&#x3D; -1)&#123; 		 &#x2F;&#x2F;忽略不存在的顶点</span><br><span class="line">            G-&gt;Arc[pos1][pos2] &#x3D; weight;</span><br><span class="line">            G-&gt;Arc[pos2][pos1] &#x3D; weight;</span><br><span class="line">            G-&gt;arcnum++;</span><br><span class="line">        &#125;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="创建有向图"><a href="#创建有向图" class="headerlink" title="创建有向图"></a>创建有向图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CreateDG(Graph G)			&#x2F;&#x2F;创建有向图 </span><br><span class="line">&#123;</span><br><span class="line">	int num&#x3D;0,					&#x2F;&#x2F;控制输入顶点数 </span><br><span class="line">		pos1,pos2,				&#x2F;&#x2F;确认顶点位置 </span><br><span class="line">		i,j;</span><br><span class="line">	char a,</span><br><span class="line">		 b,</span><br><span class="line">		 ch;					&#x2F;&#x2F;顶点 </span><br><span class="line">	for(int i&#x3D;0;i&lt;MVNum;i++)&#123;				&#x2F;&#x2F;初始化 </span><br><span class="line">		for(int j&#x3D;0;j&lt;MVNum;j++)&#123;</span><br><span class="line">			G-&gt;Arc[i][j]&#x3D;0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	G-&gt;kind&#x3D;DG;								&#x2F;&#x2F;类型为有向图 </span><br><span class="line">	cout&lt;&lt;&quot;请输入顶点，以#结束&quot;&lt;&lt;endl;</span><br><span class="line">	cin&gt;&gt;ch;</span><br><span class="line">	while(ch!&#x3D;&#39;#&#39;&amp;&amp;num&lt;10)&#123;</span><br><span class="line">		G-&gt;vertex[num]&#x3D;ch;</span><br><span class="line">		cin&gt;&gt;ch;</span><br><span class="line">		num++;</span><br><span class="line">	&#125; </span><br><span class="line">	G-&gt;vexnum&#x3D;num;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;&quot;请输入对应的弧（ab与ba是方向相反的边），以##结束&quot;&lt;&lt;endl;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	while(a!&#x3D;&#39;#&#39;&amp;&amp;b!&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">		FindPos(G,a,b,pos1,pos2);</span><br><span class="line">		cout&lt;&lt;&quot;位置a：&quot;&lt;&lt;pos1&lt;&lt;&quot;位置b：&quot;&lt;&lt;pos2&lt;&lt;endl;</span><br><span class="line">		if(pos1!&#x3D;-1&amp;&amp;pos2!&#x3D;-1)&#123;</span><br><span class="line">			G-&gt;Arc[pos1][pos2]&#x3D;1;</span><br><span class="line">			G-&gt;arcnum++;</span><br><span class="line">		&#125;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="创建有向网"><a href="#创建有向网" class="headerlink" title="创建有向网"></a>创建有向网</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CreateDN(Graph G)			&#x2F;&#x2F;创建有向网 </span><br><span class="line">&#123;</span><br><span class="line">	int num&#x3D;0,					&#x2F;&#x2F;控制输入顶点数 </span><br><span class="line">		pos1,pos2,				&#x2F;&#x2F;确认顶点位置 </span><br><span class="line">		i,j,</span><br><span class="line">		weight;					&#x2F;&#x2F;权值 </span><br><span class="line">	char a,</span><br><span class="line">		 b,</span><br><span class="line">		 ch;					&#x2F;&#x2F;顶点 </span><br><span class="line">    for(i &#x3D; 0;i &lt; MVNum; i++)&#123; 	&#x2F;&#x2F;初始化弧</span><br><span class="line">        for(j &#x3D; 0;j&lt;MVNum; j++)&#123;</span><br><span class="line">            G-&gt;Arc[i][j] &#x3D; MAXINT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;kind &#x3D; DN; 				&#x2F;&#x2F;图的类型为有向网 </span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入顶点(不超过10个，以#结束):\n&quot;);</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    while(ch!&#x3D;&#39;#&#39; &amp;&amp; num &lt;10)&#123;</span><br><span class="line">        G-&gt;vertex[num] &#x3D; ch;</span><br><span class="line">        cin&gt;&gt;ch;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;vexnum &#x3D; num;  &#x2F;&#x2F;顶点个数</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;请输入对应的弧（ab与ba是方向相反的边）和权值，以###结束&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;weight;</span><br><span class="line">    while(a!&#x3D;&#39;#&#39; &amp;&amp; b!&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;&quot;:&quot;&lt;&lt;weight&lt;&lt;endl;</span><br><span class="line">        FindPos(G,a,b,pos1,pos2);</span><br><span class="line">        printf(&quot;位置a:%d,位置b:%d\n&quot;,pos1,pos2);</span><br><span class="line">        if(pos1!&#x3D; -1 &amp;&amp; pos2!&#x3D; -1)&#123;  &#x2F;&#x2F;忽略不存在的顶点</span><br><span class="line">            G-&gt;Arc[pos1][pos2] &#x3D; weight;</span><br><span class="line">            G-&gt;arcnum++;</span><br><span class="line">        &#125;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">返回目录<a></p>
</li>
</ul>
</li>
<li><h2 id="采用邻接表表示法"><a href="#采用邻接表表示法" class="headerlink" title="采用邻接表表示法"></a>采用邻接表表示法</h2><p>  由上面图的基本概念可知，创建图与网的区别就是增加一个权值。<br>  创建有向无向的区别就是无向可以默认生成 <strong><em>对称信息</em></strong>，有向 <strong><em>来与回</em></strong> 不同步。</p>
<ul>
<li><h3 id="创建无向图-1"><a href="#创建无向图-1" class="headerlink" title="创建无向图"></a>创建无向图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CreateUDG(ALGraph &amp;G) &#123;								&#x2F;&#x2F;采用邻接表表示法，创建无向图G</span><br><span class="line">			</span><br><span class="line">	int i, k;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; &quot;请输入总顶点数和总边数：&quot;  ;				&#x2F;&#x2F;输出总顶点数，总边数</span><br><span class="line">	cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; &quot;请输入顶点：&quot; &lt;&lt; endl;</span><br><span class="line">	for (i &#x3D; 0 ; i &lt; G.vexnum; i++) &#123;					&#x2F;&#x2F;输入各点，构建表头结点</span><br><span class="line">		cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i + 1) &lt;&lt; &quot;个顶点的名称：&quot;;</span><br><span class="line">		cin &gt;&gt; G.vertices[i].data;</span><br><span class="line">		G.vertices[i].fristarrc &#x3D; NULL;                 &#x2F;&#x2F;初始化表头结点的指针域为NULL</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;请输入一条边依附的顶点：&quot; &lt;&lt;endl;</span><br><span class="line">	for (k &#x3D; 0; k &lt; G.arcnum; k++) &#123;</span><br><span class="line">		VerTexType v1, v2;</span><br><span class="line">		int i, j;</span><br><span class="line">		cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k+1) &lt;&lt; &quot;条边依附的顶点&quot;;</span><br><span class="line">		cin &gt;&gt; v1 &gt;&gt; v2;								&#x2F;&#x2F;输入一条边依附的两个顶点</span><br><span class="line">		i &#x3D; LocateVex(G, v1);							&#x2F;&#x2F;确定v1和v2在G中的位置，</span><br><span class="line">		j &#x3D; LocateVex(G, v2);							&#x2F;&#x2F;即顶点在G.vertices(邻接表)中的序号</span><br><span class="line">												</span><br><span class="line">		ArcNode *p1 &#x3D; new ArcNode;						&#x2F;&#x2F;生成一个新的边结点*p1</span><br><span class="line">		p1-&gt;adjvex &#x3D; j;									&#x2F;&#x2F;邻接点序号为j</span><br><span class="line">		p1-&gt;nextarc &#x3D; G.vertices[i].fristarrc;	</span><br><span class="line">		G.vertices[i].fristarrc &#x3D; p1;					&#x2F;&#x2F;将新节点*p1插入vi的边表</span><br><span class="line">		  </span><br><span class="line">		ArcNode *p2 &#x3D; new ArcNode;						&#x2F;&#x2F;生成另一个对称的新的边结点*p2</span><br><span class="line">        p2-&gt;adjvex &#x3D; i;									&#x2F;&#x2F;邻接点序号为i</span><br><span class="line">		p2-&gt;nextarc &#x3D; G.vertices[j].fristarrc;	</span><br><span class="line">		G.vertices[j].fristarrc &#x3D; p2;					&#x2F;&#x2F;将新结点*p2插入顶点Vj的边表</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="创建无向网-1"><a href="#创建无向网-1" class="headerlink" title="创建无向网"></a>创建无向网</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CreateUDN(ALGraph &amp;G) &#123;							&#x2F;&#x2F;采用邻接表表示法，创建无向网G</span><br><span class="line">			</span><br><span class="line">	int i, k;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; &quot;请输入总顶点数和总边数：&quot;  ;				&#x2F;&#x2F;输出总顶点数，总边数</span><br><span class="line">	cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; &quot;请输入顶点：&quot; &lt;&lt; endl;</span><br><span class="line">	for (i &#x3D; 0 ; i &lt; G.vexnum; i++) &#123;					&#x2F;&#x2F;输入各点，构建表头结点</span><br><span class="line">		cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i + 1) &lt;&lt; &quot;个顶点的名称：&quot;;</span><br><span class="line">		cin &gt;&gt; G.vertices[i].data;</span><br><span class="line">		G.vertices[i].fristarrc &#x3D; NULL;                 &#x2F;&#x2F;初始化表头结点的指针域为NULL</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;请输入一条边依附的顶点,和权值&quot; &lt;&lt;endl;</span><br><span class="line">	for (k &#x3D; 0; k &lt; G.arcnum; k++) &#123;</span><br><span class="line">		VerTexType v1, v2;</span><br><span class="line">		int i, j,weight;</span><br><span class="line">		cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k+1) &lt;&lt; &quot;条边依附的顶点&quot;;</span><br><span class="line">		cin &gt;&gt; v1 &gt;&gt; v2&gt;&gt;weight;						&#x2F;&#x2F;输入一条边依附的两个顶点</span><br><span class="line">		i &#x3D; LocateVex(G, v1);							&#x2F;&#x2F;确定v1和v2在G中的位置，</span><br><span class="line">		j &#x3D; LocateVex(G, v2);							&#x2F;&#x2F;即顶点在G.vertices(邻接表)中的序号</span><br><span class="line">												</span><br><span class="line">		ArcNode *p1 &#x3D; new ArcNode;						&#x2F;&#x2F;生成一个新的边结点*p1</span><br><span class="line">		p1-&gt;adjvex &#x3D; j;	</span><br><span class="line">		p1-&gt;info &#x3D; weight;								&#x2F;&#x2F;邻接点序号为j</span><br><span class="line">		p1-&gt;nextarc &#x3D; G.vertices[i].fristarrc;	</span><br><span class="line">		G.vertices[i].fristarrc &#x3D; p1;					&#x2F;&#x2F;将新节点*p1插入vi的边表</span><br><span class="line">		  </span><br><span class="line">		ArcNode *p2 &#x3D; new ArcNode;						&#x2F;&#x2F;生成另一个对称的新的边结点*p2</span><br><span class="line">        p2-&gt;adjvex &#x3D; i;		</span><br><span class="line">		p2-&gt;info &#x3D; weight;								&#x2F;&#x2F;邻接点序号为i</span><br><span class="line">		p2-&gt;nextarc &#x3D; G.vertices[j].fristarrc;	</span><br><span class="line">		G.vertices[j].fristarrc &#x3D; p2;					&#x2F;&#x2F;将新结点*p2插入顶点Vj的边表</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a href="#top">返回目录<a></li>
</ul>
</li>
<li><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>  因为图中的任意顶点都可能和其余的顶点邻接。所以必须记下每个已访问过的顶点，避免同一顶点被访问多次。设一个辅助数组 <strong>IsRead[MVNum]**，初始值为</strong>0/false<strong>，一旦访问过就置</strong>1/true<strong>。即 **打卡</strong> 操作。</p>
<ul>
<li><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3></li>
<li><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3></li>
</ul>
</li>
</ul>
<p><a href="#top">返回目录<a></p>
<ul>
<li><h2 id="邻接矩阵表示法总的代码："><a href="#邻接矩阵表示法总的代码：" class="headerlink" title="邻接矩阵表示法总的代码："></a>邻接矩阵表示法总的代码：</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;math.h&gt; </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define MVNum 10&#x2F;&#x2F;最大顶点数 </span><br><span class="line">#define MAXINT 32768&#x2F;&#x2F;表示极大值 </span><br><span class="line">typedef enum&#123;DG,DN,UDG,UDN&#125; GraphKind; &#x2F;&#x2F;有向图、有向网、无向图、无向网 </span><br><span class="line">typedef int arcType;</span><br><span class="line">typedef char vertexType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define MAX_SIZE 20</span><br><span class="line"></span><br><span class="line">&#x2F;*定义队列*&#x2F;</span><br><span class="line">typedef struct QNode&#123;</span><br><span class="line">    int Qarr[MAX_SIZE];</span><br><span class="line">    int tail,head;</span><br><span class="line">    int size;</span><br><span class="line">&#125;QNode,*Queue;</span><br><span class="line"></span><br><span class="line">void InitQueue(Queue &amp;Q)&#123;</span><br><span class="line">    Q&#x3D; (QNode *)malloc(sizeof(QNode));</span><br><span class="line">    if(Q)&#123;</span><br><span class="line">        Q-&gt;size &#x3D; 0;</span><br><span class="line">        Q-&gt;head &#x3D; 0;</span><br><span class="line">        Q-&gt;tail &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int isEmpty(Queue Q)&#123;</span><br><span class="line">    if(Q-&gt;head &#x3D;&#x3D; Q-&gt;tail)</span><br><span class="line">		return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int isFull(Queue Q)&#123;</span><br><span class="line">    if((Q-&gt;tail +1) % MAX_SIZE &#x3D;&#x3D; Q-&gt;head)</span><br><span class="line">		return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*入队列*&#x2F;</span><br><span class="line">void EnterQueue(Queue Q, int data)&#123;</span><br><span class="line">    if(isFull(Q))&#123;</span><br><span class="line">        printf(&quot;队列已经满!!\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Q-&gt;Qarr[Q-&gt;tail] &#x3D; data;</span><br><span class="line">    Q-&gt;size++;</span><br><span class="line">    Q-&gt;tail &#x3D; (Q-&gt;tail +1) % MAX_SIZE;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OutQueue(Queue Q, int &amp;data)&#123;</span><br><span class="line">    if(isEmpty(Q))&#123;</span><br><span class="line">        printf(&quot;队列为空!!\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    data&#x3D; Q-&gt;Qarr[Q-&gt;head];</span><br><span class="line">    Q-&gt;size--;</span><br><span class="line">    Q-&gt;head &#x3D; (Q-&gt;head +1) % MAX_SIZE;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct MNode&#123;</span><br><span class="line">	vertexType vertex[MVNum];	&#x2F;&#x2F;存储顶点 </span><br><span class="line">	arcType Arc[MVNum][MVNum];	&#x2F;&#x2F;邻接矩阵，存储边 </span><br><span class="line">	int vexnum,arcnum;</span><br><span class="line">   	GraphKind kind;				&#x2F;&#x2F;图的种类，有向无向等 </span><br><span class="line">&#125;GraphNode,*Graph;</span><br><span class="line"></span><br><span class="line">int IsRead[MVNum];</span><br><span class="line"></span><br><span class="line">int Init(Graph &amp;G)&#123;</span><br><span class="line">	G&#x3D;(GraphNode *)malloc(sizeof(GraphNode));</span><br><span class="line">	G-&gt;vexnum&#x3D;0;</span><br><span class="line">	G-&gt;arcnum&#x3D;0;</span><br><span class="line">	if(G) return 1;</span><br><span class="line">	else cout&lt;&lt;&quot;初始化出错！&quot;&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void FindPos(Graph G,char a,char b,int &amp;pos1,int &amp;pos2)&#123;&#x2F;&#x2F;查找位置 </span><br><span class="line">	int i&#x3D;0;</span><br><span class="line">	pos1&#x3D;-1;pos2&#x3D;-1;</span><br><span class="line">	for(int i&#x3D;0;i&lt;G-&gt;vexnum;i++)&#123;</span><br><span class="line">		if(G-&gt;vertex[i]&#x3D;&#x3D;a)&#123;</span><br><span class="line">			pos1&#x3D;i;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(G-&gt;vertex[i]&#x3D;&#x3D;b)&#123;</span><br><span class="line">			pos2&#x3D;i;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreateDG(Graph G)			&#x2F;&#x2F;创建有向图 </span><br><span class="line">&#123;</span><br><span class="line">	int num&#x3D;0,					&#x2F;&#x2F;控制输入顶点数 </span><br><span class="line">		pos1,pos2,				&#x2F;&#x2F;确认顶点位置 </span><br><span class="line">		i,j;</span><br><span class="line">	char a,</span><br><span class="line">		 b,</span><br><span class="line">		 ch;					&#x2F;&#x2F;顶点 </span><br><span class="line">	for(int i&#x3D;0;i&lt;MVNum;i++)&#123;				&#x2F;&#x2F;初始化 </span><br><span class="line">		for(int j&#x3D;0;j&lt;MVNum;j++)&#123;</span><br><span class="line">			G-&gt;Arc[i][j]&#x3D;0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	G-&gt;kind&#x3D;DG;								&#x2F;&#x2F;类型为有向图 </span><br><span class="line">	cout&lt;&lt;&quot;请输入顶点，以#结束&quot;&lt;&lt;endl;</span><br><span class="line">	cin&gt;&gt;ch;</span><br><span class="line">	while(ch!&#x3D;&#39;#&#39;&amp;&amp;num&lt;10)&#123;</span><br><span class="line">		G-&gt;vertex[num]&#x3D;ch;</span><br><span class="line">		cin&gt;&gt;ch;</span><br><span class="line">		num++;</span><br><span class="line">	&#125; </span><br><span class="line">	G-&gt;vexnum&#x3D;num;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;&quot;请输入对应的弧（ab与ba是方向相反的边），以##结束&quot;&lt;&lt;endl;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	while(a!&#x3D;&#39;#&#39;&amp;&amp;b!&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">		FindPos(G,a,b,pos1,pos2);</span><br><span class="line">		cout&lt;&lt;&quot;位置a：&quot;&lt;&lt;pos1&lt;&lt;&quot;位置b：&quot;&lt;&lt;pos2&lt;&lt;endl;</span><br><span class="line">		if(pos1!&#x3D;-1&amp;&amp;pos2!&#x3D;-1)&#123;</span><br><span class="line">			G-&gt;Arc[pos1][pos2]&#x3D;1;</span><br><span class="line">			G-&gt;arcnum++;</span><br><span class="line">		&#125;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreateDN(Graph G)			&#x2F;&#x2F;创建有向网 </span><br><span class="line">&#123;</span><br><span class="line">	int num&#x3D;0,					&#x2F;&#x2F;控制输入顶点数 </span><br><span class="line">		pos1,pos2,				&#x2F;&#x2F;确认顶点位置 </span><br><span class="line">		i,j,</span><br><span class="line">		weight;					&#x2F;&#x2F;权值 </span><br><span class="line">	char a,</span><br><span class="line">		 b,</span><br><span class="line">		 ch;					&#x2F;&#x2F;顶点 </span><br><span class="line">    for(i &#x3D; 0;i &lt; MVNum; i++)&#123; 	&#x2F;&#x2F;初始化弧</span><br><span class="line">        for(j &#x3D; 0;j&lt;MVNum; j++)&#123;</span><br><span class="line">            G-&gt;Arc[i][j] &#x3D; MAXINT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;kind &#x3D; DN; 				&#x2F;&#x2F;图的类型为有向网 </span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入顶点(不超过10个，以#结束):\n&quot;);</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    while(ch!&#x3D;&#39;#&#39; &amp;&amp; num &lt;10)&#123;</span><br><span class="line">        G-&gt;vertex[num] &#x3D; ch;</span><br><span class="line">        cin&gt;&gt;ch;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;vexnum &#x3D; num;  &#x2F;&#x2F;顶点个数</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;请输入对应的弧（ab与ba是方向相反的边）和权值，以###结束&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;weight;</span><br><span class="line">    while(a!&#x3D;&#39;#&#39; &amp;&amp; b!&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;b&lt;&lt;&quot;:&quot;&lt;&lt;weight&lt;&lt;endl;</span><br><span class="line">        FindPos(G,a,b,pos1,pos2);</span><br><span class="line">        printf(&quot;位置a:%d,位置b:%d\n&quot;,pos1,pos2);</span><br><span class="line">        if(pos1!&#x3D; -1 &amp;&amp; pos2!&#x3D; -1)&#123;  &#x2F;&#x2F;忽略不存在的顶点</span><br><span class="line">            G-&gt;Arc[pos1][pos2] &#x3D; weight;</span><br><span class="line">            G-&gt;arcnum++;</span><br><span class="line">        &#125;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreateUDG(Graph G)			&#x2F;&#x2F;创建无向图 </span><br><span class="line">&#123;</span><br><span class="line">	int num&#x3D;0,					&#x2F;&#x2F;控制输入顶点数 </span><br><span class="line">		pos1,pos2,				&#x2F;&#x2F;确认顶点位置 </span><br><span class="line">		i,j;</span><br><span class="line">	char a,</span><br><span class="line">		 b,</span><br><span class="line">		 ch;					&#x2F;&#x2F;顶点 </span><br><span class="line">    for(i &#x3D; 0;i&lt;MVNum;i++)&#123; 	&#x2F;&#x2F;初始化弧</span><br><span class="line">        for(j &#x3D; 0;j&lt;MVNum;j++)&#123;</span><br><span class="line">            G-&gt;Arc[i][j] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;kind &#x3D; UDG; 				&#x2F;&#x2F;图的类型为无向图 </span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入顶点(不超过10个，以#结束):\n&quot;);</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    while(ch!&#x3D;&#39;#&#39; &amp;&amp; num &lt;10)&#123;</span><br><span class="line">        G-&gt;vertex[num] &#x3D; ch;</span><br><span class="line">        cin&gt;&gt;ch;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;vexnum &#x3D; num;  			&#x2F;&#x2F;顶点个数</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;请输入对应的弧（ab与ba是一样的边），以##结束&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    while(a!&#x3D;&#39;#&#39; &amp;&amp; b!&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&quot;-&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">        FindPos(G,a,b,pos1,pos2);</span><br><span class="line">        printf(&quot;位置a:%d,位置b:%d\n&quot;,pos1,pos2);</span><br><span class="line">        if(pos1!&#x3D; -1 &amp;&amp; pos2!&#x3D; -1)&#123;  &#x2F;&#x2F;忽略不存在的顶点</span><br><span class="line">            G-&gt;Arc[pos1][pos2] &#x3D; 1;</span><br><span class="line">            G-&gt;Arc[pos2][pos1] &#x3D; 1;</span><br><span class="line">            G-&gt;arcnum++;</span><br><span class="line">        &#125;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreateUDN(Graph G)			&#x2F;&#x2F;创建无向网</span><br><span class="line">&#123;</span><br><span class="line">	int num&#x3D;0,					&#x2F;&#x2F;控制输入顶点数 </span><br><span class="line">		pos1,pos2,				&#x2F;&#x2F;确认顶点位置 </span><br><span class="line">		i,j,</span><br><span class="line">		weight;					&#x2F;&#x2F;权值 </span><br><span class="line">	char a,</span><br><span class="line">		 b,</span><br><span class="line">		 ch;					&#x2F;&#x2F;顶点 </span><br><span class="line">		 </span><br><span class="line">	for(i &#x3D; 0;i&lt;MVNum; i++)&#123; &#x2F;&#x2F;初始化弧</span><br><span class="line">        for(j &#x3D; 0;j&lt;MVNum; j++)&#123;</span><br><span class="line">            G-&gt;Arc[i][j] &#x3D; MAXINT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;kind &#x3D; UDN; &#x2F;&#x2F;设置图的类型</span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入顶点(不超过10个，以#结束):\n&quot;);</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    while(ch!&#x3D;&#39;#&#39; &amp;&amp; num &lt;10)&#123;</span><br><span class="line">        G-&gt;vertex[num] &#x3D; ch;</span><br><span class="line">        scanf(&quot;%c&quot;,&amp;ch);</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;vexnum &#x3D; num;  &#x2F;&#x2F;顶点个数</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;请输入对应的弧（ab与ba是一样的边）和权值，以###结束&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;weight;</span><br><span class="line">    while(a!&#x3D;&#39;#&#39; &amp;&amp; b!&#x3D;&#39;#&#39;)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;&quot;-&quot;&lt;&lt;b&lt;&lt;&quot;:&quot;&lt;&lt;weight&lt;&lt;endl;</span><br><span class="line">        FindPos(G,a,b,pos1,pos2);</span><br><span class="line">        printf(&quot;位置a:%d,位置b:%d\n&quot;,pos1,pos2);</span><br><span class="line">        if(pos1!&#x3D; -1 &amp;&amp; pos2!&#x3D; -1)&#123;  &#x2F;&#x2F;忽略不存在的顶点</span><br><span class="line">            G-&gt;Arc[pos1][pos2] &#x3D; weight;</span><br><span class="line">            G-&gt;Arc[pos2][pos1] &#x3D; weight;</span><br><span class="line">            G-&gt;arcnum++;</span><br><span class="line">        &#125;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BuildGraph(Graph G)&#123;</span><br><span class="line">	int choose&#x3D;0;				&#x2F;&#x2F;选择 </span><br><span class="line">	cout&lt;&lt;&quot;请选择建立图的类型:&quot;&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;1.有向图      2.有向网&quot;&lt;&lt;endl&lt;&lt;&quot;3.无向图      4.无向网&quot;&lt;&lt;endl;</span><br><span class="line">	cin&gt;&gt;choose;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	switch(choose)&#123;</span><br><span class="line">		case 1:CreateDG(G);break;</span><br><span class="line">		case 2:CreateDN(G);break;</span><br><span class="line">		case 3:CreateUDG(G);break;</span><br><span class="line">		case 4:CreateUDN(G);break;</span><br><span class="line">		default:cout&lt;&lt;&quot;ERROR&quot;;return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DepthFS(Graph G,int pos)&#123;		 &#x2F;*深度优先搜索for图*&#x2F;</span><br><span class="line">    int i &#x3D; 0,j &#x3D; 0;</span><br><span class="line">    if(IsRead[pos] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        IsRead[pos] &#x3D; 1; 			&#x2F;&#x2F;被访问过，打卡 </span><br><span class="line">        printf(&quot;遍历顶点%c\n&quot;,G-&gt;vertex[pos]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(i &#x3D; 0;i&lt;G-&gt;vexnum;i++)&#123;</span><br><span class="line">        if(G-&gt;Arc[pos][i] &#x3D;&#x3D; 1 &amp;&amp; IsRead[i] &#x3D;&#x3D;0)&#123;  &#x2F;&#x2F;存在弧</span><br><span class="line">            DepthFS(G,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DepthFS1(Graph G,int pos)&#123;		 &#x2F;*深度优先搜索for网*&#x2F;</span><br><span class="line">    int i &#x3D; 0,j &#x3D; 0;</span><br><span class="line">    if(IsRead[pos] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        IsRead[pos] &#x3D; 1; 			&#x2F;&#x2F;被访问过，打卡 </span><br><span class="line">        printf(&quot;遍历顶点%c\n&quot;,G-&gt;vertex[pos]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(i &#x3D; 0;i&lt;G-&gt;vexnum;i++)&#123;</span><br><span class="line">        if(G-&gt;Arc[pos][i] !&#x3D;INFINITY &amp;&amp; IsRead[i] &#x3D;&#x3D;0)&#123;  &#x2F;&#x2F;存在弧且未被遍历</span><br><span class="line">            DepthFS1(G,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*深度优先搜索*&#x2F;</span><br><span class="line">void DFS(Graph G)&#123;</span><br><span class="line">    if(G-&gt;kind &#x3D;&#x3D; DG || G-&gt;kind &#x3D;&#x3D; UDG)&#123;  &#x2F;&#x2F;图</span><br><span class="line">        DepthFS(G,0);</span><br><span class="line">    &#125;else if(G-&gt;kind &#x3D;&#x3D; DN || G-&gt;kind &#x3D;&#x3D; UDN)&#123; &#x2F;&#x2F;网</span><br><span class="line">        DepthFS1(G,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BFS1(Graph G,int pos)&#123; &#x2F;&#x2F;广度优先搜索for图</span><br><span class="line">    int i &#x3D; 0,temp;</span><br><span class="line">    Queue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    for(i &#x3D; 0; i&lt;G-&gt;vexnum;i++)&#123;  &#x2F;&#x2F;清零</span><br><span class="line">        IsRead[i] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(IsRead[pos] &#x3D;&#x3D;0)&#123;</span><br><span class="line">        IsRead[pos] &#x3D; 1;</span><br><span class="line">        printf(&quot;遍历顶点:%c\n&quot;,G-&gt;vertex[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    EnterQueue(Q,pos);</span><br><span class="line">    while(!isEmpty(Q))&#123;&#x2F;&#x2F;当队列不为空</span><br><span class="line">        OutQueue(Q,temp);</span><br><span class="line">        for(i &#x3D; 0; i&lt; G-&gt;vexnum;i++)&#123;</span><br><span class="line">            if(G-&gt;Arc[temp][i] &#x3D;&#x3D; 1 &amp;&amp; IsRead[i] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                IsRead[i] &#x3D; 1;</span><br><span class="line">                printf(&quot;遍历顶点:%c\n&quot;,G-&gt;vertex[i]);</span><br><span class="line">                EnterQueue(Q,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(Q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BFS2(Graph G,int pos)&#123; &#x2F;&#x2F;广度优先搜索for图</span><br><span class="line">    int i &#x3D; 0,temp;</span><br><span class="line">    Queue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    for(i &#x3D; 0; i &lt;G-&gt;vexnum;i++)&#123;  &#x2F;&#x2F;清零</span><br><span class="line">        IsRead[i] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(IsRead[pos] &#x3D;&#x3D;0)&#123;</span><br><span class="line">        IsRead[pos] &#x3D; 1;</span><br><span class="line">        printf(&quot;遍历顶点:%c\n&quot;,G-&gt;vertex[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    EnterQueue(Q,pos);</span><br><span class="line">    while(!isEmpty(Q))&#123;&#x2F;&#x2F;当队列不为空</span><br><span class="line">        OutQueue(Q,temp);</span><br><span class="line">        for(i &#x3D; 0; i&lt; G-&gt;vexnum;i++)&#123;</span><br><span class="line">            if(G-&gt;Arc[temp][i] !&#x3D; INFINITY &amp;&amp; IsRead[i] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                IsRead[i] &#x3D; 1;</span><br><span class="line">                printf(&quot;遍历顶点:%c\n&quot;,G-&gt;vertex[i]);</span><br><span class="line">                EnterQueue(Q,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(Q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BFS(Graph G)&#123;</span><br><span class="line">    if(G-&gt;kind &#x3D;&#x3D; DG || G-&gt;kind &#x3D;&#x3D; UDG)&#123;  		&#x2F;&#x2F;图</span><br><span class="line">        BFS1(G,0);</span><br><span class="line">    &#125;else if(G-&gt;kind &#x3D;&#x3D; DN || G-&gt;kind &#x3D;&#x3D; UDN)&#123; 	&#x2F;&#x2F;网</span><br><span class="line">        BFS2(G,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    Graph G &#x3D; NULL;</span><br><span class="line">    Init(G);</span><br><span class="line">    BuildGraph(G);</span><br><span class="line">    for(i &#x3D; 0; i&lt;MVNum; i++)&#123;</span><br><span class="line">        IsRead[i] &#x3D; 0;  &#x2F;&#x2F;未被遍历</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n深度优先搜索:\n&quot;);</span><br><span class="line">    DFS(G);</span><br><span class="line">    printf(&quot;\n广度优先搜索:\n&quot;);</span><br><span class="line">    BFS(G);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  创建如图所示的图：<br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190711143608849.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20190711143608849.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70</a> =400x300)</p>
<ul>
<li><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3>  <img src="https://img-blog.csdnimg.cn/20190711143739583.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190711143815505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#top">返回目录<a></li>
</ul>
</li>
<li><h2 id="邻接表表示法总的代码："><a href="#邻接表表示法总的代码：" class="headerlink" title="邻接表表示法总的代码："></a>邻接表表示法总的代码：</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MVNum 100									    &#x2F;&#x2F;最大顶点信息</span><br><span class="line">int IsRead[MVNum];</span><br><span class="line"></span><br><span class="line">typedef char VerTexType;</span><br><span class="line">typedef int OtherInfo;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;----------图的邻接表存储表示-----------</span><br><span class="line">typedef struct ArcNode &#123;								&#x2F;&#x2F;边结点</span><br><span class="line">	int adjvex;											&#x2F;&#x2F;该边所指向顶点的位置</span><br><span class="line">	struct ArcNode *nextarc;							&#x2F;&#x2F;指向下一条边的指针</span><br><span class="line">	OtherInfo info;										&#x2F;&#x2F;和边相关的信息</span><br><span class="line">													</span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line">typedef struct VNode &#123;</span><br><span class="line">	VerTexType data;									&#x2F;&#x2F;顶点信息</span><br><span class="line">	ArcNode *fristarrc;							    	&#x2F;&#x2F;指向第一条依附该顶点的边 </span><br><span class="line">	                                                                                                                                                                                                                                                                </span><br><span class="line">&#125; VNode,AdjList[MVNum];</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">	AdjList vertices;									&#x2F;&#x2F; 邻接表</span><br><span class="line">	int vexnum;                                         &#x2F;&#x2F;图的当前顶点数</span><br><span class="line">	int arcnum;											&#x2F;&#x2F;图的当前边数	</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line">int LocateVex(ALGraph G,VerTexType v) &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; G.vexnum; i++) </span><br><span class="line">		if (G.vertices[i].data &#x3D;&#x3D; v)</span><br><span class="line">			return i;	      </span><br><span class="line">		return -1;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreateUDG(ALGraph &amp;G) &#123;								&#x2F;&#x2F;采用邻接表表示法，创建无向图G</span><br><span class="line">			</span><br><span class="line">	int i, k;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; &quot;请输入总顶点数和总边数：&quot;  ;				&#x2F;&#x2F;输出总顶点数，总边数</span><br><span class="line">	cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; &quot;请输入顶点：&quot; &lt;&lt; endl;</span><br><span class="line">	for (i &#x3D; 0 ; i &lt; G.vexnum; i++) &#123;					&#x2F;&#x2F;输入各点，构建表头结点</span><br><span class="line">		cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i + 1) &lt;&lt; &quot;个顶点的名称：&quot;;</span><br><span class="line">		cin &gt;&gt; G.vertices[i].data;</span><br><span class="line">		G.vertices[i].fristarrc &#x3D; NULL;                 &#x2F;&#x2F;初始化表头结点的指针域为NULL</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;请输入一条边依附的顶点:&quot; &lt;&lt;endl;</span><br><span class="line">	for (k &#x3D; 0; k &lt; G.arcnum; k++) &#123;</span><br><span class="line">		VerTexType v1, v2;</span><br><span class="line">		int i, j;</span><br><span class="line">		cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k+1) &lt;&lt; &quot;条边依附的顶点&quot;;</span><br><span class="line">		cin &gt;&gt; v1 &gt;&gt; v2;								&#x2F;&#x2F;输入一条边依附的两个顶点</span><br><span class="line">		i &#x3D; LocateVex(G, v1);							&#x2F;&#x2F;确定v1和v2在G中的位置，</span><br><span class="line">		j &#x3D; LocateVex(G, v2);							&#x2F;&#x2F;即顶点在G.vertices(邻接表)中的序号</span><br><span class="line">												</span><br><span class="line">		ArcNode *p1 &#x3D; new ArcNode;						&#x2F;&#x2F;生成一个新的边结点*p1</span><br><span class="line">		p1-&gt;adjvex &#x3D; j;									&#x2F;&#x2F;邻接点序号为j</span><br><span class="line">		p1-&gt;nextarc &#x3D; G.vertices[i].fristarrc;	</span><br><span class="line">		G.vertices[i].fristarrc &#x3D; p1;					&#x2F;&#x2F;将新节点*p1插入vi的边表</span><br><span class="line">		  </span><br><span class="line">		ArcNode *p2 &#x3D; new ArcNode;						&#x2F;&#x2F;生成另一个对称的新的边结点*p2</span><br><span class="line">        p2-&gt;adjvex &#x3D; i;									&#x2F;&#x2F;邻接点序号为i</span><br><span class="line">		p2-&gt;nextarc &#x3D; G.vertices[j].fristarrc;	</span><br><span class="line">		G.vertices[j].fristarrc &#x3D; p2;					&#x2F;&#x2F;将新结点*p2插入顶点Vj的边表</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreateUDN(ALGraph &amp;G) &#123;							&#x2F;&#x2F;采用邻接表表示法，创建无向网G</span><br><span class="line">			</span><br><span class="line">	int i, k;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; &quot;请输入总顶点数和总边数：&quot;  ;				&#x2F;&#x2F;输出总顶点数，总边数</span><br><span class="line">	cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; &quot;请输入顶点：&quot; &lt;&lt; endl;</span><br><span class="line">	for (i &#x3D; 0 ; i &lt; G.vexnum; i++) &#123;					&#x2F;&#x2F;输入各点，构建表头结点</span><br><span class="line">		cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (i + 1) &lt;&lt; &quot;个顶点的名称：&quot;;</span><br><span class="line">		cin &gt;&gt; G.vertices[i].data;</span><br><span class="line">		G.vertices[i].fristarrc &#x3D; NULL;                 &#x2F;&#x2F;初始化表头结点的指针域为NULL</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;请输入一条边依附的顶点,和权值&quot; &lt;&lt;endl;</span><br><span class="line">	for (k &#x3D; 0; k &lt; G.arcnum; k++) &#123;</span><br><span class="line">		VerTexType v1, v2;</span><br><span class="line">		int i, j,weight;</span><br><span class="line">		cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; (k+1) &lt;&lt; &quot;条边依附的顶点&quot;;</span><br><span class="line">		cin &gt;&gt; v1 &gt;&gt; v2&gt;&gt;weight;						&#x2F;&#x2F;输入一条边依附的两个顶点</span><br><span class="line">		i &#x3D; LocateVex(G, v1);							&#x2F;&#x2F;确定v1和v2在G中的位置，</span><br><span class="line">		j &#x3D; LocateVex(G, v2);							&#x2F;&#x2F;即顶点在G.vertices(邻接表)中的序号</span><br><span class="line">												</span><br><span class="line">		ArcNode *p1 &#x3D; new ArcNode;						&#x2F;&#x2F;生成一个新的边结点*p1</span><br><span class="line">		p1-&gt;adjvex &#x3D; j;	</span><br><span class="line">		p1-&gt;info &#x3D; weight;								&#x2F;&#x2F;邻接点序号为j</span><br><span class="line">		p1-&gt;nextarc &#x3D; G.vertices[i].fristarrc;	</span><br><span class="line">		G.vertices[i].fristarrc &#x3D; p1;					&#x2F;&#x2F;将新节点*p1插入vi的边表</span><br><span class="line">		  </span><br><span class="line">		ArcNode *p2 &#x3D; new ArcNode;						&#x2F;&#x2F;生成另一个对称的新的边结点*p2</span><br><span class="line">        p2-&gt;adjvex &#x3D; i;		</span><br><span class="line">		p2-&gt;info &#x3D; weight;								&#x2F;&#x2F;邻接点序号为i</span><br><span class="line">		p2-&gt;nextarc &#x3D; G.vertices[j].fristarrc;	</span><br><span class="line">		G.vertices[j].fristarrc &#x3D; p2;					&#x2F;&#x2F;将新结点*p2插入顶点Vj的边表</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DepthFS(ALGraph G,int pos)&#123; 		&#x2F;*深度优先搜索for图*&#x2F;</span><br><span class="line">	ArcNode *p&#x3D;NULL;</span><br><span class="line">    int i &#x3D; 0,j &#x3D; 0;</span><br><span class="line">    if(IsRead[pos] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        IsRead[pos] &#x3D; 1; 				&#x2F;&#x2F;被访问过，打卡 </span><br><span class="line">        printf(&quot;遍历顶点%c\n&quot;,G.vertices[pos].data);</span><br><span class="line">        p&#x3D; G.vertices[pos].fristarrc; &#x2F;&#x2F;指向依赖该点的边。边又有三个域：邻接点的位置，权重，指向下一条边的指针。 </span><br><span class="line">    &#125;</span><br><span class="line">	 </span><br><span class="line">	while(p!&#x3D;NULL)&#123;</span><br><span class="line">		if(!IsRead[p-&gt;adjvex])&#123;</span><br><span class="line">			DepthFS(G,p-&gt;adjvex);			</span><br><span class="line">		&#125;						</span><br><span class="line">		p&#x3D;p-&gt;nextarc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BFS(ALGraph G,int pos)&#123; 		&#x2F;&#x2F;广度优先搜索for图</span><br><span class="line">    int i &#x3D; 0,temp;</span><br><span class="line">    ArcNode * p &#x3D; NULL;</span><br><span class="line">    queue&lt;char&gt;Q;</span><br><span class="line">    </span><br><span class="line">    for(i &#x3D; 0; i &lt;G.vexnum;i++)&#123; 	 &#x2F;&#x2F;清零</span><br><span class="line">        IsRead[i] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(IsRead[pos] &#x3D;&#x3D;0)&#123;</span><br><span class="line">        IsRead[pos] &#x3D; 1;</span><br><span class="line">        printf(&quot;遍历顶点:%c\n&quot;,G.vertices[pos].data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Q.push(pos);</span><br><span class="line">    while(!Q.empty())&#123;			&#x2F;&#x2F;当队列不为空</span><br><span class="line">        temp&#x3D;Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        p&#x3D;G.vertices[temp].fristarrc;</span><br><span class="line">        while(p)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!IsRead[p-&gt;adjvex])</span><br><span class="line">            &#123;</span><br><span class="line">                IsRead[p-&gt;adjvex]&#x3D;true;</span><br><span class="line">                printf(&quot;遍历顶点:%c\n&quot;,G.vertices[p-&gt;adjvex].data);</span><br><span class="line">                Q.push(p-&gt;adjvex);</span><br><span class="line">            &#125;</span><br><span class="line">            p&#x3D;p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	ALGraph G;</span><br><span class="line">	CreateUDG(G);</span><br><span class="line">	</span><br><span class="line">	int i;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for (i &#x3D; 0; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">		VNode temp &#x3D; G.vertices[i];					 &#x2F;&#x2F;将G的顶点信息付给temp</span><br><span class="line">		ArcNode *p &#x3D; temp.fristarrc;				 &#x2F;&#x2F;将顶点信息temp中的边信息给p</span><br><span class="line">		if ( p &#x3D;&#x3D;  NULL)&#123;</span><br><span class="line">			cout &lt;&lt; G.vertices[i].data;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; temp.data;</span><br><span class="line">			while (p)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; &quot;-&gt;&quot;;</span><br><span class="line">				cout &lt;&lt; p-&gt;adjvex;</span><br><span class="line">				p &#x3D; p-&gt;nextarc;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">&#x2F;&#x2F;			if(!p)&#123;</span><br><span class="line">&#x2F;&#x2F;				cout&lt;&lt;&quot;-&gt;^&quot;;</span><br><span class="line">&#x2F;&#x2F;			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;深度遍历:&quot;&lt;&lt;endl; </span><br><span class="line">	DepthFS(G,0);</span><br><span class="line">	cout&lt;&lt;&quot;广度遍历:&quot;&lt;&lt;endl; </span><br><span class="line">	BFS(G,0); </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><h3 id="运行结果：-1"><a href="#运行结果：-1" class="headerlink" title="运行结果："></a>运行结果：</h3>  创建上图所示的图<br>  <img src="https://img-blog.csdnimg.cn/20190711143919973.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190711144443375.JPG" alt="在这里插入图片描述"><br><a href="#top">返回目录<a></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>哈弗曼编码与译码</title>
    <url>/2019/07/08/%E5%93%88%E5%BC%97%E6%9B%BC%E7%BC%96%E7%A0%81%E4%B8%8E%E8%AF%91%E7%A0%81/</url>
    <content><![CDATA[<body>
    <div id="top"></div>
</body>


<h1 id="哈弗曼树"><a href="#哈弗曼树" class="headerlink" title="哈弗曼树"></a>哈弗曼树</h1><ul>
<li><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2>  假设有m个权值{w<del>1</del>，w<del>2</del>，…w<del>m</del>}，可以构造一颗含n个叶子结点的二叉树，每个叶子结点的权重为w<del>i</del>，则其中带权路径长度WPL最小的二叉树称为最优二叉树或哈弗曼树。</li>
<li><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2>  权值越大的结点离根节点越近。根据这个特点可以构造哈弗曼树。<h1 id="哈弗曼树的构造算法"><a href="#哈弗曼树的构造算法" class="headerlink" title="哈弗曼树的构造算法"></a>哈弗曼树的构造算法</h1></li>
</ul>
<ol>
<li><p>根据给定的n个权值{w<del>1</del>，w<del>2</del>，…w<del>n</del>}，构造n棵只有根结点的二叉树。构成森林F。</p>
</li>
<li><p>在森林F中选取两棵根结点权值最小的树作为左右子树构造一颗新的二叉树，置新二叉树根结点权值为其左右子树根节点权值之和。</p>
</li>
<li><p>从森林F中删除这两棵树，同时将新得到的二叉树加入森林F中。</p>
</li>
<li><p>重复（2）和（3），直到F只含一棵树为止，这棵树即是 哈弗曼树</p>
<p> 演示过程：<br> <img src="https://img-blog.csdnimg.cn/20190708093145389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#top">回到目录</a></p>
<h1 id="哈弗曼算法的实现"><a href="#哈弗曼算法的实现" class="headerlink" title="哈弗曼算法的实现"></a>哈弗曼算法的实现</h1></li>
</ol>
<ul>
<li><h2 id="哈弗曼的存储表示"><a href="#哈弗曼的存储表示" class="headerlink" title="哈弗曼的存储表示"></a>哈弗曼的存储表示</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">	char letter, *code;		&#x2F;&#x2F;letter字符，code生成的哈弗曼编码</span><br><span class="line"></span><br><span class="line">	int weight;				&#x2F;&#x2F;权重</span><br><span class="line"></span><br><span class="line">	int parent, lchild, rchild;</span><br><span class="line"></span><br><span class="line">&#125;HTNode, *HuffmanTree;</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="构造哈弗曼树"><a href="#构造哈弗曼树" class="headerlink" title="构造哈弗曼树"></a>构造哈弗曼树</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*在HT[1...i]中选择parent为0且权值最小的结点  </span><br><span class="line"></span><br><span class="line">    返回该结点的下标值  </span><br><span class="line"></span><br><span class="line">    此函数被Select函数调用 </span><br><span class="line">*&#x2F;</span><br><span class="line">int Min(HuffmanTree &amp;HT,int i) &#123;   </span><br><span class="line">    int j;  </span><br><span class="line">    unsigned int k &#x3D; UINT_iMAX;						&#x2F;&#x2F;假设各结点的权值不会超过UINT_MAX  </span><br><span class="line">    int flag;  </span><br><span class="line"></span><br><span class="line">    for(j &#x3D; 1; j &lt;&#x3D; i; ++j)&#123;  </span><br><span class="line"></span><br><span class="line">        if(HT[j].weight &lt; k &amp;&amp; HT[j].parent &#x3D;&#x3D; 0)&#123;	&#x2F;&#x2F;用父结点是否为0来判断此结点是否已经被选过  </span><br><span class="line"></span><br><span class="line">            k &#x3D; HT[j].weight;  						 &#x2F;&#x2F;找到最小值 </span><br><span class="line">            flag &#x3D; j;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    HT[flag].parent &#x3D; 1;							&#x2F;&#x2F;作个标记，说明已经被选择了。</span><br><span class="line"></span><br><span class="line">    return flag;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;在HT[1...i]中选择parent为0且权值最小的两个结点，其序号分别为s1,s2  </span><br><span class="line">&#x2F;&#x2F;s1 &lt;&#x3D; s2 </span><br><span class="line">void Select(HuffmanTree &amp;HT, int i, int &amp;s1, int &amp;s2) &#123;  </span><br><span class="line">    s1 &#x3D; Min(HT,i);  </span><br><span class="line">    s2 &#x3D; Min(HT,i);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void CreateHuffmanTree(HuffmanTree &amp;HT, char t[], int w[])&#123;		&#x2F;&#x2F;t[]为a[]形参，即字符，w[]为b[]形参，即权值 </span><br><span class="line"></span><br><span class="line">	int m&#x3D;2*n-1; 				&#x2F;&#x2F;总共需要2n－1个节点</span><br><span class="line">	int i, s1, s2;</span><br><span class="line"></span><br><span class="line">	if(n&lt;&#x3D;1)					&#x2F;&#x2F;如果只有一个就不用创建</span><br><span class="line">		return ;</span><br><span class="line"></span><br><span class="line">	HT&#x3D;new HTNode[m+1];			&#x2F;&#x2F;开辟空间</span><br><span class="line"></span><br><span class="line">	for(i&#x3D;1; i&lt;&#x3D;n; i++)&#123;		&#x2F;&#x2F;将1-n号单元中的双亲、左孩子、右孩子的下标都初始化为0 		</span><br><span class="line">	</span><br><span class="line">		HT[i].parent&#x3D;0;</span><br><span class="line">		</span><br><span class="line">		HT[i].lchild&#x3D;0;</span><br><span class="line">	</span><br><span class="line">		HT[i].rchild&#x3D;0;</span><br><span class="line">		</span><br><span class="line">		HT[i].code&#x3D;&#39;\0&#39;;</span><br><span class="line">	</span><br><span class="line">		HT[i].letter&#x3D;t[i-1];</span><br><span class="line">	</span><br><span class="line">		HT[i].weight&#x3D;w[i-1]; 	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(i&#x3D;n+1; i&lt;&#x3D;m; i++)	&#123; 		&#x2F;&#x2F;初始化	</span><br><span class="line"></span><br><span class="line">		HT[i].code&#x3D;&#39;\0&#39;;</span><br><span class="line"></span><br><span class="line">		HT[i].parent&#x3D;0;</span><br><span class="line"></span><br><span class="line">		HT[i].lchild&#x3D;0;</span><br><span class="line"></span><br><span class="line">		HT[i].rchild&#x3D;0;</span><br><span class="line"></span><br><span class="line">		HT[i].letter&#x3D;&#39; &#39;;</span><br><span class="line"></span><br><span class="line">		HT[i].weight&#x3D;0;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;&quot;-------------------------&quot;&lt;&lt;endl;		&#x2F;&#x2F;初始化结束，以下开始创建哈夫曼树 </span><br><span class="line">	</span><br><span class="line">	for(i&#x3D;n+1; i&lt;&#x3D;m; i++)&#123;</span><br><span class="line"></span><br><span class="line">		Select(HT, i-1,s1, s2);						&#x2F;&#x2F;在n个数中找出权值最小的两个</span><br><span class="line">		</span><br><span class="line">		HT[s1].parent&#x3D;i;</span><br><span class="line">		HT[s2].parent&#x3D;i;							&#x2F;&#x2F;将他们两个的parent节点设置为i;	</span><br><span class="line">	</span><br><span class="line">		HT[i].lchild&#x3D;s1;</span><br><span class="line">		HT[i].rchild&#x3D;s2;							&#x2F;&#x2F;把这两个分别当作左右节点</span><br><span class="line">		HT[i].weight&#x3D;HT[s1].weight+HT[s2].weight;	&#x2F;&#x2F;他们两个的双亲的权值为他们两个的和。 </span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#top">回到目录</a></p>
</li>
</ul>
<h1 id="哈弗曼不等长编码"><a href="#哈弗曼不等长编码" class="headerlink" title="哈弗曼不等长编码"></a>哈弗曼不等长编码</h1><p><em>在构造哈弗曼树之后，求哈弗曼编码的思想是：</em><br>依次以叶子为出发点，向上回溯至根结点为止。回溯时走左分支则生成代码0，走右分支则生成代码1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CreatHuffmanCode(HuffmanTree HT)&#123;</span><br><span class="line"></span><br><span class="line">	int start, c, f;</span><br><span class="line"></span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	char *cd&#x3D;new char [n]; 		&#x2F;&#x2F;临时存放编码 </span><br><span class="line">	</span><br><span class="line">	cd[n-1]&#x3D;&#39;\0&#39;;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;&quot;字符编码为：&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	for(i&#x3D;1; i&lt;&#x3D;n; i++)&#123;</span><br><span class="line"></span><br><span class="line">		start&#x3D;n-1;	&#x2F;&#x2F;开始时指向编码结束符位置 </span><br><span class="line">	</span><br><span class="line">		c&#x3D;i;	</span><br><span class="line">		f&#x3D;HT[i].parent;	&#x2F;&#x2F;f指向节点c的双亲节点 </span><br><span class="line">	</span><br><span class="line">		while(f!&#x3D;0)&#123;	&#x2F;&#x2F;从叶子节点开始向上回溯，直到根节点 </span><br><span class="line"></span><br><span class="line">			--start;</span><br><span class="line"></span><br><span class="line">			if(HT[f].lchild&#x3D;&#x3D;c)&#123;	&#x2F;&#x2F;如果是左孩子，则生成代码‘0 ’ </span><br><span class="line">				</span><br><span class="line">				cd[start]&#x3D;&#39;0&#39;;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			else&#123;			&#x2F;&#x2F;如果是左孩子，则生成代码‘1 ’ </span><br><span class="line">				cd[start]&#x3D;&#39;1&#39;;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			c&#x3D;f;</span><br><span class="line"></span><br><span class="line">			f&#x3D;HT[f].parent;	&#x2F;&#x2F;继续向上回溯 </span><br><span class="line"></span><br><span class="line">		&#125;		</span><br><span class="line">	</span><br><span class="line">		HT[i].code&#x3D;new char[n-start];</span><br><span class="line">	</span><br><span class="line">		strcpy(HT[i].code,&amp;cd[start]);</span><br><span class="line">	</span><br><span class="line">		cout&lt;&lt;HT[i].letter&lt;&lt;&quot;:&quot;&lt;&lt;HT[i].code&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	delete cd;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="#top">回到目录</a></p>
<h1 id="哈弗曼译码"><a href="#哈弗曼译码" class="headerlink" title="哈弗曼译码"></a>哈弗曼译码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void HuffmanTreeYima(HuffmanTree HT,char cod[],int b) &#123;          &#x2F;&#x2F;译码 </span><br><span class="line"></span><br><span class="line">	char code[100]; </span><br><span class="line"></span><br><span class="line">    char temp[50]; </span><br><span class="line"></span><br><span class="line">    int t&#x3D;0; </span><br><span class="line"></span><br><span class="line">	int s&#x3D;0; </span><br><span class="line"></span><br><span class="line"> 	int xx&#x3D;0;									&#x2F;&#x2F;记录从第几位起不能译码 </span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0; i&lt;b; i++)&#123; </span><br><span class="line">	</span><br><span class="line">		temp[t++]&#x3D;cod[i];    		 			&#x2F;&#x2F;读取字符，直到找到编码 </span><br><span class="line"></span><br><span class="line">	    temp[t] &#x3D; &#39;\0&#39;;       		 			&#x2F;&#x2F;有效字符串</span><br><span class="line">	</span><br><span class="line">	    for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;       			&#x2F;&#x2F;依次与所有字符编码开始匹配</span><br><span class="line">		</span><br><span class="line">	  	 	if (!strcmp(HT[j].code,temp))&#123;      &#x2F;&#x2F;匹配成功   </span><br><span class="line">	</span><br><span class="line">	    			code[s]&#x3D;HT[j].letter;   	&#x2F;&#x2F;将字符保存到code中</span><br><span class="line">	</span><br><span class="line">	                s++; </span><br><span class="line">	</span><br><span class="line">	  				xx+&#x3D;t;</span><br><span class="line">	</span><br><span class="line">	                strcpy(temp,&quot;&quot;);            &#x2F;&#x2F;将TEMP置空 </span><br><span class="line">	</span><br><span class="line">	                t&#x3D;0;         				&#x2F;&#x2F;t置空</span><br><span class="line">	</span><br><span class="line">	                break;</span><br><span class="line">	</span><br><span class="line">	 	  	&#125;	</span><br><span class="line">	  	&#125; 	</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	if(t&#x3D;&#x3D;0)&#123;     &#x2F;&#x2F;t如果被置空了，表示都匹配出来了，打印译码</span><br><span class="line"></span><br><span class="line">	 	code[s]&#x3D;&#39;\0&#39;;</span><br><span class="line"></span><br><span class="line">	    cout&lt;&lt;&quot;译码为:&quot;&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">	    cout&lt;&lt;code&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;                &#x2F;&#x2F;t如果没有被置空 ， 源码无法被完全匹配</span><br><span class="line">	  	cout&lt;&lt;&quot;二进制源码有错！从第&quot;&lt;&lt;xx+1&lt;&lt;&quot;位开始&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><a href="#top">回到目录</a></p>
<h1 id="总的代码："><a href="#总的代码：" class="headerlink" title="总的代码："></a>总的代码：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define  UINT_iMAX 10000 </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">	char letter, *code;		&#x2F;&#x2F;letter字符，code生成的哈弗曼编码</span><br><span class="line">	</span><br><span class="line">	int weight;				&#x2F;&#x2F;权重</span><br><span class="line"></span><br><span class="line">	int parent, lchild, rchild;</span><br><span class="line"></span><br><span class="line">&#125;HTNode, *HuffmanTree;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int n;	&#x2F;&#x2F;全局变量会被默认赋值0 </span><br><span class="line">char coding[100];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*在HT[1...i]中选择parent为0且权值最小的结点  </span><br><span class="line"></span><br><span class="line">    返回该结点的下标值  </span><br><span class="line"></span><br><span class="line">    此函数被Select函数调用 </span><br><span class="line">*&#x2F;</span><br><span class="line">int Min(HuffmanTree &amp;HT,int i) &#123;   </span><br><span class="line"></span><br><span class="line">    int j;  </span><br><span class="line"></span><br><span class="line">    unsigned int k &#x3D; UINT_iMAX;	&#x2F;&#x2F;假设各结点的权值不会超过UINT_MAX  </span><br><span class="line"></span><br><span class="line">    int flag;  </span><br><span class="line"></span><br><span class="line">    for(j &#x3D; 1; j &lt;&#x3D; i; ++j)&#123;  </span><br><span class="line"></span><br><span class="line">        if(HT[j].weight &lt; k &amp;&amp; HT[j].parent &#x3D;&#x3D; 0)&#123;	&#x2F;&#x2F;用父结点是否为0来判断此结点是否已经被选过  </span><br><span class="line"></span><br><span class="line">            k &#x3D; HT[j].weight;  &#x2F;&#x2F;找到最小值 </span><br><span class="line">            flag &#x3D; j;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    HT[flag].parent &#x3D; 1;	&#x2F;&#x2F;作个标记，说明已经被选择了。</span><br><span class="line"></span><br><span class="line">    return flag;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;在HT[1...i]中选择parent为0且权值最小的两个结点，其序号分别为s1,s2  </span><br><span class="line">&#x2F;&#x2F;s1 &lt;&#x3D; s2 </span><br><span class="line">void Select(HuffmanTree &amp;HT, int i, int &amp;s1, int &amp;s2) &#123; </span><br><span class="line"> </span><br><span class="line">    s1 &#x3D; Min(HT,i);  </span><br><span class="line">    s2 &#x3D; Min(HT,i);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void CreateHuffmanTree(HuffmanTree &amp;HT, char t[], int w[])&#123;		&#x2F;&#x2F;t[]为a[]形参，即字符，w[]为b[]形参，即权值 </span><br><span class="line"></span><br><span class="line">	int m&#x3D;2*n-1; 	&#x2F;&#x2F;总共需要2n－1个节点</span><br><span class="line">	int i, s1, s2;</span><br><span class="line"></span><br><span class="line">	if(n&lt;&#x3D;1)	&#x2F;&#x2F;如果只有一个就不用创建</span><br><span class="line">		return ;</span><br><span class="line"></span><br><span class="line">	HT&#x3D;new HTNode[m+1];	&#x2F;&#x2F;开辟空间</span><br><span class="line"></span><br><span class="line">	for(i&#x3D;1; i&lt;&#x3D;n; i++)&#123;		&#x2F;&#x2F;将1-n号单元中的双亲、左孩子、右孩子的下标都初始化为0 		</span><br><span class="line">	</span><br><span class="line">		HT[i].parent&#x3D;0;</span><br><span class="line">		</span><br><span class="line">		HT[i].lchild&#x3D;0;</span><br><span class="line">	</span><br><span class="line">		HT[i].rchild&#x3D;0;</span><br><span class="line">		</span><br><span class="line">		HT[i].code&#x3D;&#39;\0&#39;;</span><br><span class="line">	</span><br><span class="line">		HT[i].letter&#x3D;t[i-1];</span><br><span class="line">	</span><br><span class="line">		HT[i].weight&#x3D;w[i-1]; 	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(i&#x3D;n+1; i&lt;&#x3D;m; i++)	&#123; 		&#x2F;&#x2F;初始化	</span><br><span class="line"></span><br><span class="line">		HT[i].code&#x3D;&#39;\0&#39;;</span><br><span class="line"></span><br><span class="line">		HT[i].parent&#x3D;0;</span><br><span class="line"></span><br><span class="line">		HT[i].lchild&#x3D;0;</span><br><span class="line"></span><br><span class="line">		HT[i].rchild&#x3D;0;</span><br><span class="line"></span><br><span class="line">		HT[i].letter&#x3D;&#39; &#39;;</span><br><span class="line"></span><br><span class="line">		HT[i].weight&#x3D;0;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;&quot;-------------------------&quot;&lt;&lt;endl;		&#x2F;&#x2F;初始化结束，以下开始创建哈夫曼树 </span><br><span class="line">	</span><br><span class="line">	for(i&#x3D;n+1; i&lt;&#x3D;m; i++)&#123;</span><br><span class="line"></span><br><span class="line">		Select(HT, i-1,s1, s2);&#x2F;&#x2F;在n个数中找出权值最小的两个</span><br><span class="line">		</span><br><span class="line">		HT[s1].parent&#x3D;i;</span><br><span class="line">		HT[s2].parent&#x3D;i;&#x2F;&#x2F;将他们两个的parent节点设置为i;	</span><br><span class="line">	</span><br><span class="line">		HT[i].lchild&#x3D;s1;</span><br><span class="line">		HT[i].rchild&#x3D;s2;&#x2F;&#x2F;把这两个分别当作左右节点</span><br><span class="line">		HT[i].weight&#x3D;HT[s1].weight+HT[s2].weight;&#x2F;&#x2F;他们两个的双亲为他们两个的和。 </span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreatHuffmanCode(HuffmanTree HT)&#123;</span><br><span class="line"></span><br><span class="line">	int start, c, f;</span><br><span class="line"></span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	char *cd&#x3D;new char [n]; 		&#x2F;&#x2F;临时存放编码 </span><br><span class="line">	</span><br><span class="line">	cd[n-1]&#x3D;&#39;\0&#39;;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;&quot;字符编码为：&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	for(i&#x3D;1; i&lt;&#x3D;n; i++)&#123;</span><br><span class="line"></span><br><span class="line">		start&#x3D;n-1;	&#x2F;&#x2F;开始时指向编码结束符位置 </span><br><span class="line">	</span><br><span class="line">		c&#x3D;i;	</span><br><span class="line">		f&#x3D;HT[i].parent;	&#x2F;&#x2F;f指向节点c的双亲节点 </span><br><span class="line">	</span><br><span class="line">		while(f!&#x3D;0)&#123;	&#x2F;&#x2F;从叶子节点开始向上回溯，直到根节点 </span><br><span class="line"></span><br><span class="line">			--start;</span><br><span class="line"></span><br><span class="line">			if(HT[f].lchild&#x3D;&#x3D;c)&#123;	&#x2F;&#x2F;如果是左孩子，则生成代码‘0 ’ </span><br><span class="line">				</span><br><span class="line">				cd[start]&#x3D;&#39;0&#39;;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			else&#123;			&#x2F;&#x2F;如果是左孩子，则生成代码‘1 ’ </span><br><span class="line">				cd[start]&#x3D;&#39;1&#39;;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			c&#x3D;f;</span><br><span class="line"></span><br><span class="line">			f&#x3D;HT[f].parent;	&#x2F;&#x2F;继续向上回溯 </span><br><span class="line"></span><br><span class="line">		&#125;		</span><br><span class="line">	</span><br><span class="line">		HT[i].code&#x3D;new char[n-start];</span><br><span class="line">	</span><br><span class="line">		strcpy(HT[i].code,&amp;cd[start]);</span><br><span class="line">	</span><br><span class="line">		cout&lt;&lt;HT[i].letter&lt;&lt;&quot;:&quot;&lt;&lt;HT[i].code&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	delete cd;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void HuffmanTreeYima(HuffmanTree HT,char cod[],int b) &#123;          &#x2F;&#x2F;译码 </span><br><span class="line"></span><br><span class="line">	char code[100]; </span><br><span class="line"></span><br><span class="line">    char temp[50]; </span><br><span class="line"></span><br><span class="line">    int t&#x3D;0; </span><br><span class="line"></span><br><span class="line">	int s&#x3D;0; </span><br><span class="line"></span><br><span class="line"> 	int xx&#x3D;0;									&#x2F;&#x2F;记录从第几位起不能译码 </span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0; i&lt;b; i++)&#123; </span><br><span class="line">	</span><br><span class="line">		temp[t++]&#x3D;cod[i];    		 			&#x2F;&#x2F;读取字符，直到找到编码 </span><br><span class="line"></span><br><span class="line">	    temp[t] &#x3D; &#39;\0&#39;;       		 			&#x2F;&#x2F;有效字符串</span><br><span class="line">	</span><br><span class="line">	    for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;       			&#x2F;&#x2F;依次与所有字符编码开始匹配</span><br><span class="line">		</span><br><span class="line">	  	 	if (!strcmp(HT[j].code,temp))&#123;      &#x2F;&#x2F;匹配成功   </span><br><span class="line">	</span><br><span class="line">	    			code[s]&#x3D;HT[j].letter;   	&#x2F;&#x2F;将字符保存到code中</span><br><span class="line">	</span><br><span class="line">	                s++; </span><br><span class="line">	</span><br><span class="line">	  				xx+&#x3D;t;</span><br><span class="line">	</span><br><span class="line">	                strcpy(temp,&quot;&quot;);            &#x2F;&#x2F;将TEMP置空 </span><br><span class="line">	</span><br><span class="line">	                t&#x3D;0;         				&#x2F;&#x2F;t置空</span><br><span class="line">	</span><br><span class="line">	                break;</span><br><span class="line">	</span><br><span class="line">	 	  	&#125;	</span><br><span class="line">	  	&#125; 	</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	if(t&#x3D;&#x3D;0)&#123;     &#x2F;&#x2F;t如果被置空了，表示都匹配出来了，打印译码</span><br><span class="line"></span><br><span class="line">	 	code[s]&#x3D;&#39;\0&#39;;</span><br><span class="line"></span><br><span class="line">	    cout&lt;&lt;&quot;译码为:&quot;&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">	    cout&lt;&lt;code&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;                &#x2F;&#x2F;t如果没有被置空 ， 源码无法被完全匹配</span><br><span class="line">	  	cout&lt;&lt;&quot;二进制源码有错！从第&quot;&lt;&lt;xx+1&lt;&lt;&quot;位开始&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()&#123;  </span><br><span class="line"></span><br><span class="line">    HuffmanTree HT;   </span><br><span class="line"></span><br><span class="line">    char a[20], buff[20], p;	&#x2F;&#x2F;a存放字符 buff为输入的字符串 p为输入译码时的字符 </span><br><span class="line"></span><br><span class="line">    int b[20];&#x2F;&#x2F;存放权值信息 </span><br><span class="line"></span><br><span class="line">    int  i, j;</span><br><span class="line"></span><br><span class="line">	int symbol&#x3D;1, x, k; &#x2F;&#x2F;译码时做判断用的变量  </span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;请输入一段字符:&quot;;</span><br><span class="line"></span><br><span class="line">    cin.getline(buff,10);		&#x2F;&#x2F;接收10个字符到m中，其中最后一个为&#39;\0&#39;.</span><br><span class="line"></span><br><span class="line">    int len&#x3D;strlen(buff); </span><br><span class="line"></span><br><span class="line"> 	for (i&#x3D;0;i&lt;len;i++) &#123;</span><br><span class="line"> 		</span><br><span class="line">		for(j&#x3D;0; j&lt;n;  j++) &#123;</span><br><span class="line"></span><br><span class="line">		   if (a[j]&#x3D;&#x3D;buff[i]) &#123;</span><br><span class="line">		</span><br><span class="line">		   	 	b[j]&#x3D;b[j]+1;		</span><br><span class="line">		    	break;		</span><br><span class="line">		   &#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (j&gt;&#x3D;n)&#123;</span><br><span class="line"></span><br><span class="line">			a[n]&#x3D;buff[i];</span><br><span class="line"></span><br><span class="line">			b[n]&#x3D;1;</span><br><span class="line"></span><br><span class="line">			n++;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;&quot;字符和权值信息如下&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	for (i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line"></span><br><span class="line">	  cout&lt;&lt;&quot;字符：&quot;&lt;&lt;a[i]&lt;&lt;&quot;  权值：&quot;&lt;&lt;b[i]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    CreateHuffmanTree(HT, a, b);</span><br><span class="line"></span><br><span class="line">    CreatHuffmanCode(HT);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;&quot;译码：&quot;&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line"> 	while(1)&#123; </span><br><span class="line"></span><br><span class="line">  		cout&lt;&lt;&quot;请输入要译码的二进制字符串,输入&#39;#&#39;结束：&quot;;</span><br><span class="line"></span><br><span class="line">   		x&#x3D;1;		&#x2F;&#x2F;判断是否有非法字符只能是0 1 </span><br><span class="line"></span><br><span class="line">   		k&#x3D;0;		&#x2F;&#x2F;作为循环变量来使coding[k]&#x3D;输入的字符 </span><br><span class="line"></span><br><span class="line">   		symbol&#x3D;1;	&#x2F;&#x2F;判断是否输入结束 </span><br><span class="line"></span><br><span class="line"> 		while(symbol)&#123; </span><br><span class="line"></span><br><span class="line">   			cin&gt;&gt;p; </span><br><span class="line"></span><br><span class="line">   			if(p!&#x3D;&#39;1&#39;&amp;&amp;p!&#x3D;&#39;0&#39;&amp;&amp;p!&#x3D;&#39;#&#39;)&#123; &#x2F;&#x2F;若存在其它字符，x设为0，表示输入的不是二进制</span><br><span class="line">   			 	x&#x3D;0;</span><br><span class="line">   			&#125;</span><br><span class="line"></span><br><span class="line">  			coding[k]&#x3D;p;</span><br><span class="line"></span><br><span class="line">   			if(p&#x3D;&#x3D;&#39;#&#39;)  	symbol&#x3D;0;  &#x2F;&#x2F;#号结束标志</span><br><span class="line"></span><br><span class="line">  			k++;</span><br><span class="line"></span><br><span class="line">  		&#125;</span><br><span class="line"></span><br><span class="line"> 		if(x&#x3D;&#x3D;1)&#123;</span><br><span class="line">  			HuffmanTreeYima(HT,coding,k-1);        &#x2F;&#x2F;进行译码</span><br><span class="line">  		&#125;</span><br><span class="line">  		else&#123;</span><br><span class="line">  			 cout&lt;&lt;&quot;有非法字符！&quot;&lt;&lt;endl;</span><br><span class="line">  		&#125;</span><br><span class="line"></span><br><span class="line">		cout&lt;&lt;&quot;是否继续?(Y&#x2F;N):&quot;;</span><br><span class="line">		cin&gt;&gt;p;</span><br><span class="line">		</span><br><span class="line">		if(p&#x3D;&#x3D;&#39;y&#39;||p&#x3D;&#x3D;&#39;Y&#39;)	 continue;		</span><br><span class="line">		else 	break;</span><br><span class="line"></span><br><span class="line"> 	&#125;</span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="#top">回到目录</a></p>
<h1 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h1><p><img src="https://img-blog.csdnimg.cn/2019070811015013.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>上面运行结果存储变化：</strong><br>HT的初态：<br><img src="https://img-blog.csdnimg.cn/20190708113029284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>HT的终态：<br><img src="https://img-blog.csdnimg.cn/20190708112940475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#top">回到目录</a></p>
]]></content>
      <tags>
        <tag>哈弗曼</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2019/07/07/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[ <body >
    <div id="topAnchor"></div>
</body>

<p>@[TOC]</p>
<h2 id="1-树结构"><a href="#1-树结构" class="headerlink" title="1.树结构"></a>1.树结构</h2><ul>
<li><p>在一个树结构中，有且仅有一个结点没有直接前驱，这个结点就是树的根结点。</p>
</li>
<li><p>除根结点外，其余每个结点有且仅有一个直接前驱。</p>
</li>
<li><p>每个结点可以有任意多个直接后继。</p>
<h2 id="2-树的基本概念"><a href="#2-树的基本概念" class="headerlink" title="2.树的基本概念"></a>2.树的基本概念</h2></li>
<li><p>结点（Node）：树中的独立单元。如下图中的A-M。</p>
</li>
<li><p>结点的度（Degree）：结点的子树个数。如下图A的度为3，E的度为2等。</p>
</li>
<li><p>树的度：树内各结点度的最大值。下图树的度为3。</p>
</li>
<li><p>叶子结点（Leaf）：度为0的结点。下图中K、L、F、G、M、I、J都是树的叶子。</p>
</li>
<li><p>父结点（Parent）：有子树的结点是其子树的根节点的父结点。</p>
</li>
<li><p>孩子结点（Child）：结点的子树的根称为该节点的孩子。如下图B的父节点是A，B的孩子有E、F。</p>
</li>
<li><p>兄弟结点（Sibling）：具有同一个父结点的各结点之间互称兄弟。如下图H、I、J互为兄弟。</p>
</li>
<li><p>祖先结点（Ancestor）：沿树根到该结点路径上的所有结点都是这个结点的祖先结点。如下图M的祖先为A、D、H</p>
</li>
<li><p>子孙结点（Descendant）：某一结点的子树中的所有结点是这个结点的子孙。如下图B的子孙为E、K、L、F。</p>
</li>
<li><p>层次（Level）：根为第1层，其他任一结点的层数是其父结点的层数加1。</p>
</li>
<li><p>树的深度（Depth）：树中所有结点中的最大层次是这棵树的深度或高度。下图树的深度为4。</p>
</li>
<li><p>森林（forest）：n（n&gt;0）棵互不相交的树的集合。<br><img src="https://img-blog.csdnimg.cn/20190706083353721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="树"><br><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
<h2 id="3-二叉树的基本概念"><a href="#3-二叉树的基本概念" class="headerlink" title="3.二叉树的基本概念"></a>3.二叉树的基本概念</h2></li>
<li><h3 id="二叉树的定义："><a href="#二叉树的定义：" class="headerlink" title="二叉树的定义："></a>二叉树的定义：</h3></li>
</ul>
<ol>
<li>它是n（n&gt;0）个结点的集合，每个结点最多只能有<strong>两个子结点</strong>。</li>
<li>二叉树的子树仍然是二叉树。两个子树分别为左子树和右子树。</li>
<li>由于子树<strong>有左右之分</strong>，所以二叉树是有序树。</li>
</ol>
<ul>
<li><h3 id="二叉树的5种基本形态："><a href="#二叉树的5种基本形态：" class="headerlink" title="二叉树的5种基本形态："></a>二叉树的5种基本形态：</h3><img src="https://img-blog.csdnimg.cn/20190706102632944.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><h3 id="二叉树的特殊类型："><a href="#二叉树的特殊类型：" class="headerlink" title="二叉树的特殊类型："></a>二叉树的特殊类型：</h3><ul>
<li><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4>  深度为k且含有2^k^-1个结点的二叉树。即除叶结点外，每层的结点都有两个子结点。<br>  <img src="https://img-blog.csdnimg.cn/20190706130155267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4>  除二叉树最后一层外，其他各层的结点数都达到最大个数，且最后一次从左到右要连续存在。<br><img src="https://img-blog.csdnimg.cn/20190706130506750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<p><strong><em>注意：满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。</em></strong></p>
<p><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
<ul>
<li><h3 id="二叉树的性质："><a href="#二叉树的性质：" class="headerlink" title="二叉树的性质："></a>二叉树的性质：</h3><ul>
<li><h4 id="性质一：在二叉树的第i层上至多有2-i-1-个节点-i-gt-1-。"><a href="#性质一：在二叉树的第i层上至多有2-i-1-个节点-i-gt-1-。" class="headerlink" title="性质一：在二叉树的第i层上至多有2^(i-1)^个节点(i&gt;=1)。"></a>性质一：在二叉树的第i层上至多有2^(i-1)^个节点(i&gt;=1)。</h4><p>  <em>证明：利用数学归纳法进行证明<br>当i==1时，此时二叉树只有根节点。2^(i-1)^= 1。显然成立，<br>假设i&gt;1时，第i层的节点数目为2^(i-1)。<br>根据假设，只需证明第i+1层节点数为2^i 即可。<br>由于二叉树每个节点最多有两个孩子，故第(i+1)层上的节点数最多是第i层的两倍。<br>即：第i+1层上节点数最多为: 2</em> 2^(i-1) = 2 ^ i<br>故假设成立，命题得证。*</p>
</li>
<li><h4 id="性质二：深度为k的二叉树至多有2-k-1个节点。"><a href="#性质二：深度为k的二叉树至多有2-k-1个节点。" class="headerlink" title="性质二：深度为k的二叉树至多有2^k^-1个节点。"></a>性质二：深度为k的二叉树至多有2^k^-1个节点。</h4><p>  <em>证明：二叉树节点数最多时，每层的节点树都必须最多。<br>根据性质一，深度为k的二叉树的节点数最多为：公比为2的等比数列前n项和。<br>即：2^0^+ 2^1^ +….+2^(k-1)^ = 2 ^ k^ -1</em></p>
</li>
<li><h4 id="性质三：对任何一棵二叉树T，如果终端节点数为n0，度为2的节点数为-n2-，那么-n0-n2-1。"><a href="#性质三：对任何一棵二叉树T，如果终端节点数为n0，度为2的节点数为-n2-，那么-n0-n2-1。" class="headerlink" title="性质三：对任何一棵二叉树T，如果终端节点数为n0，度为2的节点数为                    n2 ，那么 n0= n2  +1。"></a>性质三：对任何一棵二叉树T，如果终端节点数为n<del>0</del>，度为2的节点数为                    n<del>2</del> ，那么 n<del>0</del>= n<del>2</del>  +1。</h4><p>  <em>证明：从结点角度看结点总数，二叉树结点度数最大为2，<br>则 ： n =  n<del>0</del>+n<del>1</del>+n<del>2</del> (等式一)<br>从分支（线）角度看结点总数，<br>则：  n = n<del>1</del>+ 2n<del>2</del>+1(根节点)（等式二）<br>可以推出  n<del>0</del>= n<del>2</del> +1</em></p>
</li>
<li><h4 id="性质四：-具有n个节点的完全二叉树的高度为至少为log2-n-1"><a href="#性质四：-具有n个节点的完全二叉树的高度为至少为log2-n-1" class="headerlink" title="性质四： 具有n个节点的完全二叉树的高度为至少为log2(n+1)"></a>性质四： 具有n个节点的完全二叉树的高度为至少为log<del>2</del>(n+1)</h4><p>  <em>证明：高度为k的二叉树最多有2^k^–1个结点。反之，对于包含n个节点的二叉树的高度至少为log<del>2</del>(n+1)。</em></p>
</li>
<li><h4 id="性质五：如果对一棵有n个节点的完全二叉树的节点按层序编号（从第一层开-始到最下一层，每一层从左到右编号），对任一节点i，有："><a href="#性质五：如果对一棵有n个节点的完全二叉树的节点按层序编号（从第一层开-始到最下一层，每一层从左到右编号），对任一节点i，有：" class="headerlink" title="性质五：如果对一棵有n个节点的完全二叉树的节点按层序编号（从第一层开            始到最下一层，每一层从左到右编号），对任一节点i，有："></a>性质五：如果对一棵有n个节点的完全二叉树的节点按层序编号（从第一层开            始到最下一层，每一层从左到右编号），对任一节点i，有：</h4><ol>
<li>如果i=1 ，则结点为根节点，没有双亲。<br> 如果i&gt;1，则其父节点是  <strong>⌊i/2⌋</strong> 。</li>
<li>如果2i &gt; n ，则节点<strong>i</strong>没有左孩子 ；否则其左孩子节点为2*i。</li>
<li>如果2i+1&gt;n ，则节点<strong>i</strong>没有右孩子；否则其右孩子节点为2*1+1。</li>
</ol>
</li>
</ul>
<p><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
<h2 id="4-二叉树的操作"><a href="#4-二叉树的操作" class="headerlink" title="4.二叉树的操作"></a>4.二叉树的操作</h2></li>
<li><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p> 顺序存储使用一组地址连续的存储单元来存取元素，对于完全二叉树，只要从根起按层序存储即可，依次自上而下，自左而右存取结点元素。<br> 对于一般二叉树，则需将其与完全二叉树的结点相对照，不存在的结点用 <strong>“0”或“#”</strong> 等代替。因为由性质5可知，顺序存储只能这样去体现出结点间的逻辑关系。<br> 由此可见，对于一般二叉树，更适合采取链式存储。</p>
</li>
<li><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p> 由二叉树的特点，可知一个结点至少包含3个域：**<em>数据域和左、右指针域。**</em></p>
<ul>
<li><h4 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef char datatype;</span><br><span class="line"></span><br><span class="line">typedef struct BiTNode&#123;			&#x2F;&#x2F;二叉树节点 </span><br><span class="line">	datatype data;</span><br><span class="line">	struct BiTNode *lchild;</span><br><span class="line">	struct BiTNode *rchild;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>将根节点初始化为“A”，可随意。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void init(BiTree &amp;T)&#123;</span><br><span class="line">	if((T&#x3D;new BiTNode)!&#x3D;NULL)&#123;</span><br><span class="line">		T-&gt;data&#x3D;&#39;A&#39;;</span><br><span class="line">		T-&gt;lchild&#x3D;NULL;</span><br><span class="line">		T-&gt;rchild&#x3D;NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		cout&lt;&lt;&quot;初始化失败&quot;&lt;&lt;endl;</span><br><span class="line">		exit(1); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h4><p>如：ab##c##，表示这样的二叉树：<br><img src="https://img-blog.csdnimg.cn/20190707092720289.png" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CreateBiTree(BiTree &amp;T)&#123;	&#x2F;&#x2F;按先序序列创建二叉树 </span><br><span class="line">	datatype data;</span><br><span class="line">	cin&gt;&gt;data;</span><br><span class="line">	if(data&#x3D;&#x3D;&#39;#&#39;) T&#x3D;NULL;</span><br><span class="line">	else &#123;</span><br><span class="line">		T&#x3D;(BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">		T-&gt;data&#x3D;data;</span><br><span class="line">		CreateBiTree(T-&gt;lchild);</span><br><span class="line">		CreateBiTree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="访问结点"><a href="#访问结点" class="headerlink" title="访问结点"></a>访问结点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Visit(BiTree T)&#123;			&#x2F;&#x2F;访问结点</span><br><span class="line">	if(T-&gt;data!&#x3D;&#39;#&#39;) </span><br><span class="line">		cout&lt;&lt;T-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
</li>
<li><h4 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">oid PreOrder(BiTree T)&#123;			&#x2F;&#x2F;递归先序遍历 </span><br><span class="line">	if(T!&#x3D;NULL)&#123;</span><br><span class="line">		Visit(T);</span><br><span class="line">		PreOrder(T-&gt;lchild);</span><br><span class="line">		PreOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InOrder(BiTree T)&#123;			&#x2F;&#x2F;递归中序遍历 </span><br><span class="line">	if(T!&#x3D;NULL)&#123;</span><br><span class="line">		InOrder(T-&gt;lchild);</span><br><span class="line">		Visit(T);</span><br><span class="line">		InOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PostOrder(BiTree T)&#123;		&#x2F;&#x2F;递归后序遍历 </span><br><span class="line">	if(T!&#x3D;NULL)&#123;</span><br><span class="line">		PostOrder(T-&gt;lchild);</span><br><span class="line">		PostOrder(T-&gt;rchild);</span><br><span class="line">		Visit(T);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="递归遍历改写为非递归"><a href="#递归遍历改写为非递归" class="headerlink" title="递归遍历改写为非递归"></a>递归遍历改写为非递归</h4><p>递归代码看上去简单、简洁，但是其时间复杂度是呈指数型增长的，规模稍微一大，大家可想而知后果如何。所以一般以递归来分析问题，再改写为非递归形式。</p>
</li>
<li><h5 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h5><p>需要用到<a href="https://blog.csdn.net/songsongL/article/details/94553726">栈</a>，前面已经实现过栈了，这里直接用库函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void PreOrder2(BiTree T)&#123;		&#x2F;&#x2F;非递归先序遍历 </span><br><span class="line">	stack&lt;BiTree&gt; stack;</span><br><span class="line">	BiTree p&#x3D;T;</span><br><span class="line">	while(p||!stack.empty())&#123;</span><br><span class="line">	if(p!&#x3D;NULL)&#123;</span><br><span class="line">		stack.push(p);</span><br><span class="line">		cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">		p&#x3D;p-&gt;lchild;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		p&#x3D;stack.top();</span><br><span class="line">		stack.pop();</span><br><span class="line">		p&#x3D;p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h5><p>它与非递归先序遍历差不多，就是访问结点的时机不一样。 先序遍历在入栈过程中访问结点，后序遍历在出栈过程中访问结点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void InOrder2(BiTree T)&#123;		&#x2F;&#x2F;非递归中序遍历 </span><br><span class="line">	stack&lt;BiTree&gt; stack;</span><br><span class="line">	BiTree p&#x3D;T;</span><br><span class="line">	while(p||!stack.empty())&#123;</span><br><span class="line">	if(p!&#x3D;NULL)&#123;</span><br><span class="line">		stack.push(p);</span><br><span class="line">		p&#x3D;p-&gt;lchild;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		p&#x3D;stack.top();</span><br><span class="line">		cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;		</span><br><span class="line">		stack.pop();</span><br><span class="line">		p&#x3D;p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h5 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h5><p>这个是遍历中最难的，需要增加一个标记。<br>和先序遍历、中序遍历非递归算法一样，后序遍历非递归算法同样是使用栈来实现：从根结点开始，将所有最左结点全部压栈，</p>
</li>
</ul>
<p> <strong>每当一个结点出栈时，要先扫描该结点的右子树，</strong> 只有当一个结点的左孩子和右孩子结点均被访问过了（<strong>标记</strong> 就可以看有没有访问了），才能访问结点自身。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct BiTNodePost&#123;</span><br><span class="line">	BiTree biTree;</span><br><span class="line">	char tag;</span><br><span class="line">&#125;BiTNodePost,*BiTreePost;</span><br><span class="line"></span><br><span class="line">void PostOrder2(BiTree T)&#123;				&#x2F;&#x2F;非递归后序遍历 </span><br><span class="line">	stack&lt;BiTreePost&gt; stack;</span><br><span class="line">	BiTree p&#x3D;T;</span><br><span class="line">	BiTreePost BT;</span><br><span class="line">	while(p!&#x3D;NULL||!stack.empty())&#123;</span><br><span class="line">		while(p!&#x3D;NULL)&#123;</span><br><span class="line">		BT&#x3D;(BiTreePost)malloc(sizeof(BiTreePost));</span><br><span class="line">		BT-&gt;biTree&#x3D;p;</span><br><span class="line">		BT-&gt;tag&#x3D;&#39;L&#39;;</span><br><span class="line">		stack.push(BT);</span><br><span class="line">		p&#x3D;p-&gt;lchild;</span><br><span class="line">	&#125;</span><br><span class="line">	while(!stack.empty()&amp;&amp;(stack.top())-&gt;tag&#x3D;&#x3D;&#39;R&#39;)&#123;</span><br><span class="line">		BT&#x3D;stack.top();</span><br><span class="line">		stack.pop();</span><br><span class="line">		BT-&gt;biTree;</span><br><span class="line">		cout&lt;&lt;BT-&gt;biTree-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	if(!stack.empty())&#123;</span><br><span class="line">		BT&#x3D;stack.top();</span><br><span class="line">		BT-&gt;tag&#x3D;&#39;R&#39;;</span><br><span class="line">		p&#x3D;BT-&gt;biTree;		</span><br><span class="line">		p&#x3D;p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
<ul>
<li><h4 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h4>这里需要用到<a href="https://blog.csdn.net/songsongL/article/details/94714607">队列</a>，前面已经实现过，这里直接用库函数。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void LevelOrder(BiTree T)&#123;				&#x2F;&#x2F;层次遍历 </span><br><span class="line">	BiTree p&#x3D;T;</span><br><span class="line">	queue&lt;BiTree&gt; queue;</span><br><span class="line">	queue.push(p);</span><br><span class="line">	while(!queue.empty())&#123;</span><br><span class="line">		p&#x3D;queue.front();</span><br><span class="line">		cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">		queue.pop();</span><br><span class="line">		if(p-&gt;lchild!&#x3D;NULL) queue.push(p-&gt;lchild);</span><br><span class="line">		if(p-&gt;rchild!&#x3D;NULL) queue.push(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="计算二叉树的深度"><a href="#计算二叉树的深度" class="headerlink" title="计算二叉树的深度"></a>计算二叉树的深度</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Depth(BiTree T)&#123;				&#x2F;&#x2F;二叉树的深度 </span><br><span class="line">	if(T&#x3D;&#x3D;NULL) return 0;</span><br><span class="line">	else&#123;</span><br><span class="line">		int m&#x3D;Depth(T-&gt;lchild);</span><br><span class="line">		int n&#x3D;Depth(T-&gt;rchild);</span><br><span class="line">		if(m&gt;n) return m+1;</span><br><span class="line">		else return n+1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="计算二叉树的叶子节点个数"><a href="#计算二叉树的叶子节点个数" class="headerlink" title="计算二叉树的叶子节点个数"></a>计算二叉树的叶子节点个数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int NodeCount(BiTree T)&#123;		&#x2F;&#x2F;二叉树的叶子节点个数 </span><br><span class="line">	if(T&#x3D;&#x3D;NULL) return 0;</span><br><span class="line">	else return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></li>
</ul>
<h2 id="5-总的代码："><a href="#5-总的代码：" class="headerlink" title="5.总的代码："></a>5.总的代码：</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stdlib.h&gt; </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef char datatype;</span><br><span class="line"></span><br><span class="line">typedef struct BiTNode&#123;			&#x2F;&#x2F;二叉树节点 </span><br><span class="line">	datatype data;</span><br><span class="line">	struct BiTNode *lchild;</span><br><span class="line">	struct BiTNode *rchild;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line">void init(BiTree &amp;T)&#123;</span><br><span class="line">	if((T&#x3D;new BiTNode)!&#x3D;NULL)&#123;</span><br><span class="line">		T-&gt;data&#x3D;&#39;A&#39;;</span><br><span class="line">		T-&gt;lchild&#x3D;NULL;</span><br><span class="line">		T-&gt;rchild&#x3D;NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		cout&lt;&lt;&quot;初始化失败&quot;&lt;&lt;endl;</span><br><span class="line">		exit(1); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreateBiTree(BiTree &amp;T)&#123;	&#x2F;&#x2F;按先序序列创建二叉树 </span><br><span class="line">	datatype data;</span><br><span class="line">	cin&gt;&gt;data;</span><br><span class="line">	if(data&#x3D;&#x3D;&#39;#&#39;) T&#x3D;NULL;</span><br><span class="line">	else &#123;</span><br><span class="line">		T&#x3D;(BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">		T-&gt;data&#x3D;data;</span><br><span class="line">		CreateBiTree(T-&gt;lchild);</span><br><span class="line">		CreateBiTree(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Visit(BiTree T)&#123;			&#x2F;&#x2F;输出 </span><br><span class="line">	if(T-&gt;data!&#x3D;&#39;#&#39;) </span><br><span class="line">		cout&lt;&lt;T-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PreOrder(BiTree T)&#123;&#x2F;&#x2F;递归先序遍历 </span><br><span class="line">	if(T!&#x3D;NULL)&#123;</span><br><span class="line">		Visit(T);</span><br><span class="line">		PreOrder(T-&gt;lchild);</span><br><span class="line">		PreOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InOrder(BiTree T)&#123;&#x2F;&#x2F;递归中序遍历 </span><br><span class="line">	if(T!&#x3D;NULL)&#123;</span><br><span class="line">		InOrder(T-&gt;lchild);</span><br><span class="line">		Visit(T);</span><br><span class="line">		InOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PostOrder(BiTree T)&#123;&#x2F;&#x2F;递归后序遍历 </span><br><span class="line">	if(T!&#x3D;NULL)&#123;</span><br><span class="line">		PostOrder(T-&gt;lchild);</span><br><span class="line">		PostOrder(T-&gt;rchild);</span><br><span class="line">		Visit(T);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PreOrder2(BiTree T)&#123;&#x2F;&#x2F;非递归先序遍历 </span><br><span class="line">	stack&lt;BiTree&gt; stack;</span><br><span class="line">	BiTree p&#x3D;T;</span><br><span class="line">	while(p||!stack.empty())&#123;</span><br><span class="line">	if(p!&#x3D;NULL)&#123;</span><br><span class="line">		stack.push(p);</span><br><span class="line">		cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">		p&#x3D;p-&gt;lchild;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		p&#x3D;stack.top();</span><br><span class="line">		stack.pop();</span><br><span class="line">		p&#x3D;p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InOrder2(BiTree T)&#123;&#x2F;&#x2F;非递归中序遍历 </span><br><span class="line">	stack&lt;BiTree&gt; stack;</span><br><span class="line">	BiTree p&#x3D;T;</span><br><span class="line">	while(p||!stack.empty())&#123;</span><br><span class="line">	if(p!&#x3D;NULL)&#123;</span><br><span class="line">		stack.push(p);</span><br><span class="line">		p&#x3D;p-&gt;lchild;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		p&#x3D;stack.top();</span><br><span class="line">		cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;		</span><br><span class="line">		stack.pop();</span><br><span class="line">		p&#x3D;p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct BiTNodePost&#123;</span><br><span class="line">	BiTree biTree;</span><br><span class="line">	char tag;</span><br><span class="line">&#125;BiTNodePost,*BiTreePost;</span><br><span class="line"></span><br><span class="line">void PostOrder2(BiTree T)&#123;&#x2F;&#x2F;非递归后序遍历 </span><br><span class="line">	stack&lt;BiTreePost&gt; stack;</span><br><span class="line">	BiTree p&#x3D;T;</span><br><span class="line">	BiTreePost BT;</span><br><span class="line">	while(p!&#x3D;NULL||!stack.empty())&#123;</span><br><span class="line">		while(p!&#x3D;NULL)&#123;</span><br><span class="line">		BT&#x3D;(BiTreePost)malloc(sizeof(BiTreePost));</span><br><span class="line">		BT-&gt;biTree&#x3D;p;</span><br><span class="line">		BT-&gt;tag&#x3D;&#39;L&#39;;</span><br><span class="line">		stack.push(BT);</span><br><span class="line">		p&#x3D;p-&gt;lchild;</span><br><span class="line">	&#125;</span><br><span class="line">	while(!stack.empty()&amp;&amp;(stack.top())-&gt;tag&#x3D;&#x3D;&#39;R&#39;)&#123;</span><br><span class="line">		BT&#x3D;stack.top();</span><br><span class="line">		stack.pop();</span><br><span class="line">		BT-&gt;biTree;</span><br><span class="line">		cout&lt;&lt;BT-&gt;biTree-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	if(!stack.empty())&#123;</span><br><span class="line">		BT&#x3D;stack.top();</span><br><span class="line">		BT-&gt;tag&#x3D;&#39;R&#39;;</span><br><span class="line">		p&#x3D;BT-&gt;biTree;		</span><br><span class="line">		p&#x3D;p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LevelOrder(BiTree T)&#123;&#x2F;&#x2F;层次遍历 </span><br><span class="line">	BiTree p&#x3D;T;</span><br><span class="line">	queue&lt;BiTree&gt; queue;</span><br><span class="line">	queue.push(p);</span><br><span class="line">	while(!queue.empty())&#123;</span><br><span class="line">		p&#x3D;queue.front();</span><br><span class="line">		cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">		queue.pop();</span><br><span class="line">		if(p-&gt;lchild!&#x3D;NULL) queue.push(p-&gt;lchild);</span><br><span class="line">		if(p-&gt;rchild!&#x3D;NULL) queue.push(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Depth(BiTree T)&#123;			&#x2F;&#x2F;二叉树的深度 </span><br><span class="line">	if(T&#x3D;&#x3D;NULL) return 0;</span><br><span class="line">	else&#123;</span><br><span class="line">		int m&#x3D;Depth(T-&gt;lchild);</span><br><span class="line">		int n&#x3D;Depth(T-&gt;rchild);</span><br><span class="line">		if(m&gt;n) return m+1;</span><br><span class="line">		else return n+1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int NodeCount(BiTree T)&#123;		&#x2F;&#x2F;二叉树的叶子节点个数 </span><br><span class="line">	if(T&#x3D;&#x3D;NULL) return 0;</span><br><span class="line">	else return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	BiTree T;</span><br><span class="line">	init(T);</span><br><span class="line">	cout&lt;&lt;&quot;请输入一串字符构成二叉树&quot;&lt;&lt;endl;</span><br><span class="line">	CreateBiTree(T);</span><br><span class="line">	cout&lt;&lt;&quot;递归先序遍历&quot;&lt;&lt;endl;</span><br><span class="line">	PreOrder(T);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;非递归先序遍历&quot;&lt;&lt;endl;</span><br><span class="line">	PreOrder2(T);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;递归中序遍历&quot;&lt;&lt;endl;</span><br><span class="line">	InOrder(T);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;非递归中序遍历&quot;&lt;&lt;endl;</span><br><span class="line">	InOrder2(T);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;递归后序遍历&quot;&lt;&lt;endl;</span><br><span class="line">	PostOrder(T);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;非递归后序遍历&quot;&lt;&lt;endl;</span><br><span class="line">	PostOrder2(T);	</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;层次遍历&quot;&lt;&lt;endl;</span><br><span class="line">	LevelOrder(T); </span><br><span class="line">	cout&lt;&lt;&quot;二叉树的深度 ：&quot;&lt;&lt;Depth(T)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;二叉树的叶子节点个数 &quot;&lt;&lt;NodeCount(T)&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-运行结果："><a href="#6-运行结果：" class="headerlink" title="6.运行结果："></a>6.运行结果：</h2><p> <img src="https://img-blog.csdnimg.cn/20190707102238154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
<p>*[⌊i/2⌋]: 该符号表示不大于x的最大整数，即向下取整。</p>
]]></content>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>队列--循环队列与链队</title>
    <url>/2019/07/05/%E9%98%9F%E5%88%97--%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E4%B8%8E%E9%93%BE%E9%98%9F/</url>
    <content><![CDATA[ <body >
    <div id="topAnchor"></div>
</body>

<p>@[TOC]</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><ul>
<li>逻辑结构：线性表</li>
<li>存储结构：顺序存储\链式存储</li>
<li>基本运算：<ol>
<li>初始化</li>
<li>判断队空</li>
<li>判断队满</li>
<li>入队</li>
<li>出队</li>
<li>访问队头</li>
</ol>
</li>
</ul>
<p><strong><em>注意：队列也是线性表，其特殊性在于有特殊的运算规则。即：队结构只能在一端进行插入，该操作端称为队尾，另一端删除元素，该操作端称为队头。按照“先进先出”（First In First Out,FIFO）原则处理数据节点。</em></strong></p>
<h2 id="1-循环队列"><a href="#1-循环队列" class="headerlink" title="1.循环队列"></a>1.循环队列</h2><p>之所以用循环对列，就是了为了提高利用率。要不然每删除一个元素，对头就空了一个还用不了了。<br>实现循环，就用“模”运算：<br><strong>队空的条件</strong>：Q.front == Q.rear<br><strong>堆满条件</strong>：（Q.rear+1）%Max == Q.front</p>
<h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	ElemType *base;</span><br><span class="line">	int front;</span><br><span class="line">	int rear;							&#x2F;&#x2F;队头、尾 </span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SqQueueInit(SqQueue &amp;Q)&#123;			&#x2F;&#x2F;初始化队列 </span><br><span class="line">	Q.base&#x3D;new ElemType[MAX];</span><br><span class="line">	Q.front&#x3D;Q.rear&#x3D;0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断队空"><a href="#判断队空" class="headerlink" title="判断队空"></a>判断队空</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool SqQueueEmpty(SqQueue Q)&#123;			&#x2F;&#x2F;判断队列空 </span><br><span class="line">	if(Q.front&#x3D;&#x3D;Q.rear)&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断队满"><a href="#判断队满" class="headerlink" title="判断队满"></a>判断队满</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool SqQueueFull(SqQueue Q)&#123;			&#x2F;&#x2F;判断队列满 </span><br><span class="line">	if((Q.rear+1)%MAX&#x3D;&#x3D;Q.front)&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SqQueue SqQueueIn(SqQueue Q,ElemType x)&#123;	&#x2F;&#x2F;入队 </span><br><span class="line">	if(SqQueueFull(Q))&#123;</span><br><span class="line">		cout&lt;&lt;&quot;队满了&quot;&lt;&lt;endl;</span><br><span class="line">		return Q;</span><br><span class="line">	&#125;</span><br><span class="line">	Q.base[Q.rear]&#x3D;x;</span><br><span class="line">	Q.rear&#x3D;(Q.rear+1)%MAX;</span><br><span class="line">	return Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SqQueue SqQueueOut(SqQueue Q,ElemType *x)&#123;&#x2F;&#x2F;出队 </span><br><span class="line">	if(SqQueueEmpty(Q))&#123;</span><br><span class="line">		cout&lt;&lt;&quot;队空&quot;&lt;&lt;endl;</span><br><span class="line">		return Q;</span><br><span class="line">	&#125;</span><br><span class="line">	*x&#x3D;Q.base[Q.front];</span><br><span class="line">	Q.front&#x3D;(Q.front+1)%MAX;</span><br><span class="line">	return Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问队头"><a href="#访问队头" class="headerlink" title="访问队头"></a>访问队头</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ElemType GetSqQueueTop(SqQueue Q)&#123;			&#x2F;&#x2F;访问队头元素 </span><br><span class="line">	return (Q.base[Q.front]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算队列长度"><a href="#计算队列长度" class="headerlink" title="计算队列长度"></a>计算队列长度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int GetQueueLength(SqQueue Q)&#123;				&#x2F;&#x2F;元素个数 </span><br><span class="line">	return (Q.rear-Q.front+MAX)%MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
<h3 id="总的代码"><a href="#总的代码" class="headerlink" title="总的代码:"></a>总的代码:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAX 100							&#x2F;&#x2F;定义队列的最大值 </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef int ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	ElemType *base;</span><br><span class="line">	int front;</span><br><span class="line">	int rear;							&#x2F;&#x2F;队头、尾 </span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line">void SqQueueInit(SqQueue &amp;Q)&#123;			&#x2F;&#x2F;初始化队列 </span><br><span class="line">	Q.base&#x3D;new ElemType[MAX];</span><br><span class="line">	if(!Q.base)</span><br><span class="line">		exit(1);</span><br><span class="line">	Q.front&#x3D;Q.rear&#x3D;0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool SqQueueEmpty(SqQueue Q)&#123;			&#x2F;&#x2F;判断队列空 </span><br><span class="line">	if(Q.front&#x3D;&#x3D;Q.rear)&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool SqQueueFull(SqQueue Q)&#123;			&#x2F;&#x2F;判断队列满 </span><br><span class="line">	if((Q.rear+1)%MAX&#x3D;&#x3D;Q.front)&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqQueue SqQueueIn(SqQueue Q,ElemType x)&#123;	&#x2F;&#x2F;入队 </span><br><span class="line">	if(SqQueueFull(Q))&#123;</span><br><span class="line">		cout&lt;&lt;&quot;队满了&quot;&lt;&lt;endl;</span><br><span class="line">		return Q;</span><br><span class="line">	&#125;</span><br><span class="line">	Q.base[Q.rear]&#x3D;x;</span><br><span class="line">	Q.rear&#x3D;(Q.rear+1)%MAX;</span><br><span class="line">	return Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElemType GetSqQueueTop(SqQueue Q)&#123;			&#x2F;&#x2F;获取队头元素 </span><br><span class="line">	return (Q.base[Q.front]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetQueueLength(SqQueue Q)&#123;				&#x2F;&#x2F;元素个数 </span><br><span class="line">	return (Q.rear-Q.front+MAX)%MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqQueue SqQueueOut(SqQueue Q,ElemType *x)&#123;	&#x2F;&#x2F;出队 </span><br><span class="line">	if(SqQueueEmpty(Q))&#123;</span><br><span class="line">		cout&lt;&lt;&quot;队空&quot;&lt;&lt;endl;</span><br><span class="line">		return Q;</span><br><span class="line">	&#125;</span><br><span class="line">	*x&#x3D;Q.base[Q.front];</span><br><span class="line">	Q.front&#x3D;(Q.front+1)%MAX;</span><br><span class="line">	return Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	&#x2F;&#x2F;测试 </span><br><span class="line">	int a[5];</span><br><span class="line">	cout&lt;&lt;&quot;请输入5个整数构成一个队列&quot; &lt;&lt;endl;</span><br><span class="line">	for(int i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125; </span><br><span class="line">	SqQueue s;</span><br><span class="line">	SqQueueInit(s);</span><br><span class="line">	cout&lt;&lt;&quot;现在将初始化一个队列！&quot;&lt;&lt;endl;</span><br><span class="line">	if(SqQueueEmpty(s))&#123;</span><br><span class="line">		cout&lt;&lt;&quot;队空&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else cout&lt;&lt;&quot;队非空&quot;&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;现在将上面的元素入队&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">	 	s&#x3D;SqQueueIn(s,a[i]);</span><br><span class="line">	 &#125;</span><br><span class="line">	cout&lt;&lt;&quot;现在将依次出队&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">	 	cout&lt;&lt;&quot;对头元素&quot;&lt;&lt;GetSqQueueTop(s)&lt;&lt;endl;</span><br><span class="line">	 	cout&lt;&lt;&quot;当前元素个数&quot;&lt;&lt;GetQueueLength(s)&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">	 	s&#x3D;SqQueueOut(s,&amp;s.front);</span><br><span class="line">	 &#125;	</span><br><span class="line">	if(SqQueueEmpty(s))&#123;</span><br><span class="line">		cout&lt;&lt;&quot;队空&quot;&lt;&lt;endl;</span><br><span class="line">			&#125;  </span><br><span class="line">		else cout&lt;&lt;&quot;队非空&quot;&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">	return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="https://img-blog.csdnimg.cn/2019070510010396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
<h2 id="2-链队"><a href="#2-链队" class="headerlink" title="2.链队"></a>2.链队</h2><h3 id="链队的定义"><a href="#链队的定义" class="headerlink" title="链队的定义"></a>链队的定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int DATATYPE;</span><br><span class="line"></span><br><span class="line">typedef struct QNode			&#x2F;&#x2F;定义节点</span><br><span class="line">&#123;</span><br><span class="line">    DATATYPE data;</span><br><span class="line">    struct QNode * next;</span><br><span class="line">    </span><br><span class="line">&#125;QNode,*Queue;</span><br><span class="line"></span><br><span class="line">typedef struct					&#x2F;&#x2F;定义一个链队 </span><br><span class="line">&#123;</span><br><span class="line">    Queue front;  				&#x2F;&#x2F;队头指针 </span><br><span class="line">    Queue rear;					&#x2F;&#x2F;队尾指针</span><br><span class="line">    int count; 					&#x2F;&#x2F;计数器 记录链队的元素个数</span><br><span class="line">    </span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void init(LinkQueue &amp;Q)</span><br><span class="line">&#123;</span><br><span class="line">    Q.front&#x3D;Q.rear&#x3D;new QNode;</span><br><span class="line">    if(!Q.front) </span><br><span class="line">    	exit(1);</span><br><span class="line">    Q.front-&gt;next&#x3D;NULL;					&#x2F;&#x2F;与单链表一样，为了方便，给队列添加了头结点 </span><br><span class="line">    Q.count&#x3D;0;							&#x2F;&#x2F;初始化时长度为零</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断空"><a href="#判断空" class="headerlink" title="判断空"></a>判断空</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool SqQueueEmpty(SqQueue Q)&#123;			&#x2F;&#x2F;判断队列空 </span><br><span class="line">	if(Q.front&#x3D;&#x3D;Q.rear)&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断队满-1"><a href="#判断队满-1" class="headerlink" title="判断队满"></a>判断队满</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool IsEmpty(LinkQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">    return (Q.front&#x3D;&#x3D;Q.rear? true:false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
<h3 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void EnQueue(LinkQueue &amp;Q,DATATYPE a)	&#x2F;&#x2F;入队 </span><br><span class="line">&#123;</span><br><span class="line">    Queue p&#x3D;new QNode;</span><br><span class="line">    if(!p)								&#x2F;&#x2F;申请不成功</span><br><span class="line">        exit(1);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;data&#x3D;a;			</span><br><span class="line">        p-&gt;next&#x3D;NULL;					&#x2F;&#x2F;将新节点的指针域清空 </span><br><span class="line">        Q.rear-&gt;next&#x3D;p;					&#x2F;&#x2F;新节点挂在队尾上 </span><br><span class="line">        Q.rear&#x3D;p;						&#x2F;&#x2F;更新新的队尾 </span><br><span class="line">        Q.count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h3><p><strong><em>注意：当队列中最后一个元素被删时，队列尾指针也丢失了，因此需要对队尾指针从新赋值。</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void DeQueue(LinkQueue &amp;Q,DATATYPE &amp;a)	&#x2F;&#x2F;出队 </span><br><span class="line">&#123;</span><br><span class="line">    if( IsEmpty(Q))</span><br><span class="line">        cout&lt;&lt;&quot;error!队空&quot;&lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">    	Queue p;</span><br><span class="line">        p &#x3D;Q.front-&gt;next;				</span><br><span class="line">        a&#x3D;p-&gt;data;</span><br><span class="line">		Q.front-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">        Q.count--;</span><br><span class="line">        if(Q.rear&#x3D;&#x3D;p)</span><br><span class="line">        	Q.rear&#x3D;Q.front;		&#x2F;&#x2F;最后一个，队尾指针指向头结点</span><br><span class="line">        delete p;		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问队头-1"><a href="#访问队头-1" class="headerlink" title="访问队头"></a>访问队头</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DATATYPE GetFront(LinkQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">    if(IsEmpty(Q))</span><br><span class="line">        return 0;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return Q.front-&gt;next-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算队列长度-1"><a href="#计算队列长度-1" class="headerlink" title="计算队列长度"></a>计算队列长度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int length(LinkQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">    return Q.count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
<h3 id="总的代码-1"><a href="#总的代码-1" class="headerlink" title="总的代码:"></a>总的代码:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef int DATATYPE;</span><br><span class="line"></span><br><span class="line">typedef struct QNode			&#x2F;&#x2F;定义节点</span><br><span class="line">&#123;</span><br><span class="line">    DATATYPE data;</span><br><span class="line">    struct QNode * next;</span><br><span class="line">    </span><br><span class="line">&#125;QNode,*Queue;</span><br><span class="line"></span><br><span class="line">typedef struct					&#x2F;&#x2F;定义一个链队 </span><br><span class="line">&#123;</span><br><span class="line">    Queue front;  				&#x2F;&#x2F;队头指针 </span><br><span class="line">    Queue rear;					&#x2F;&#x2F;队尾指针</span><br><span class="line">    int count; 					&#x2F;&#x2F;计数器 记录链队的元素个数</span><br><span class="line">    </span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line">void init(LinkQueue &amp;Q);					&#x2F;&#x2F;初始化</span><br><span class="line">bool IsEmpty(LinkQueue Q);					&#x2F;&#x2F;判断是否为空</span><br><span class="line">void EnQueue(LinkQueue &amp;Q,DATATYPE a);		&#x2F;&#x2F;入队 </span><br><span class="line">void DeQueue(LinkQueue &amp;Q,DATATYPE &amp;a);		&#x2F;&#x2F;出栈</span><br><span class="line">DATATYPE GetFront(LinkQueue Q);				&#x2F;&#x2F;访问队头 </span><br><span class="line">int length(LinkQueue Q);					&#x2F;&#x2F;计算队列长度(元素个数) </span><br><span class="line"></span><br><span class="line">void init(LinkQueue &amp;Q)</span><br><span class="line">&#123;</span><br><span class="line">    Q.front&#x3D;Q.rear&#x3D;new QNode;</span><br><span class="line">    if(!Q.front) </span><br><span class="line">    	exit(1);</span><br><span class="line">    Q.front-&gt;next&#x3D;NULL;					&#x2F;&#x2F;与单链表一样，为了方便，给队列添加了头结点 </span><br><span class="line">    Q.count&#x3D;0;							&#x2F;&#x2F;初始化时长度为零</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsEmpty(LinkQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">    return (Q.front&#x3D;&#x3D;Q.rear? true:false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EnQueue(LinkQueue &amp;Q,DATATYPE a)	&#x2F;&#x2F;入队 </span><br><span class="line">&#123;</span><br><span class="line">    Queue p&#x3D;new QNode;</span><br><span class="line">    if(!p)								&#x2F;&#x2F;申请不成功</span><br><span class="line">        exit(1);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;data&#x3D;a;			</span><br><span class="line">        p-&gt;next&#x3D;NULL;					&#x2F;&#x2F;将新节点的指针域清空 </span><br><span class="line">        Q.rear-&gt;next&#x3D;p;					&#x2F;&#x2F;新节点挂在队尾上 </span><br><span class="line">        Q.rear&#x3D;p;						&#x2F;&#x2F;更新新的队尾 </span><br><span class="line">        Q.count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DeQueue(LinkQueue &amp;Q,DATATYPE &amp;a)	&#x2F;&#x2F;出队 </span><br><span class="line">&#123;</span><br><span class="line">    if( IsEmpty(Q))</span><br><span class="line">        cout&lt;&lt;&quot;error!队空&quot;&lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">    	Queue p;</span><br><span class="line">        p &#x3D;Q.front-&gt;next;				&#x2F;&#x2F;将即将出队的数据存在a中。不存也不影响出队操作 </span><br><span class="line">        a&#x3D;p-&gt;data;</span><br><span class="line">		Q.front-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">        Q.count--;</span><br><span class="line">        if(Q.rear&#x3D;&#x3D;p)</span><br><span class="line">        	Q.rear&#x3D;Q.front;</span><br><span class="line">        delete p;		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DATATYPE GetFront(LinkQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">    if(IsEmpty(Q))</span><br><span class="line">        return 0;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return Q.front-&gt;next-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int length(LinkQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">    return Q.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    init(Q);       			 &#x2F;&#x2F; 初始化队列 </span><br><span class="line">	for (int i&#x3D;0; i&lt;5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	EnQueue(Q,i); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    DATATYPE temp;	</span><br><span class="line">    while(!IsEmpty(Q))</span><br><span class="line">    &#123;    </span><br><span class="line">    	printf(&quot;队列长度为：%d\n&quot;,length(Q));</span><br><span class="line">		printf(&quot;此时的队头为：%d\n&quot;,GetFront(Q));  </span><br><span class="line">		DeQueue(Q,temp);</span><br><span class="line">        printf(&quot;将%d出队\n&quot;,temp); </span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="运行结果：-1"><a href="#运行结果：-1" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="https://img-blog.csdnimg.cn/20190705110242977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong><em>注意一个小细节：</em></strong><br>在进行某些操作时，不管是栈还是队列还是其他，需要注意函数是设为 <strong><em>void</em></strong> 型还是有返回类型。如果是 <strong><em>void</em></strong> ，要想要改变参数，需要用 * 或 <strong><em>&amp;</em></strong>，如果有返回就不需要了。</p>
<p><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
]]></content>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>栈的应用--数值转换与表达式求值</title>
    <url>/2019/07/04/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8--%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[ <body >
    <div id="topAnchor"></div>
</body>


<h1 id="1-数值转换"><a href="#1-数值转换" class="headerlink" title="1.数值转换"></a>1.数值转换</h1><p>原理大家肯定都知道，就除K取余，直到商为0时，倒序输出余数即为转换后的K进制数。一说倒序，就很符合栈（Last In First Out，LIFO）“后进先出”的思想。<br>这个简单，直接上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define MAX 100&#x2F;&#x2F;定义栈的最大值 </span><br><span class="line"></span><br><span class="line">typedef int ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	ElemType base[MAX];</span><br><span class="line">	int top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line">SqStack SqStackInit()&#123;&#x2F;&#x2F;初始化栈 </span><br><span class="line">	SqStack S;</span><br><span class="line">	S.top&#x3D;-1;</span><br><span class="line">	return S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int StackEmpty(SqStack S)&#123;&#x2F;&#x2F;判断栈空 </span><br><span class="line">	if(S.top&#x3D;&#x3D;-1)&#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	else return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqStack SqStackPush(SqStack S,ElemType x)&#123;&#x2F;&#x2F;入栈 </span><br><span class="line">	if(S.top&#x3D;&#x3D;MAX-1)&#123;</span><br><span class="line">		printf(&quot;栈满了&quot;);</span><br><span class="line">		return S;</span><br><span class="line">	&#125;</span><br><span class="line">	S.top++;</span><br><span class="line">	S.base[S.top]&#x3D;x;</span><br><span class="line">	return S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElemType GetSqStackTop(SqStack S)&#123;&#x2F;&#x2F;获取栈顶元素 </span><br><span class="line">	return (S.base[S.top]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqStack SqStackPop(SqStack S,ElemType *x)&#123;&#x2F;&#x2F;出栈 </span><br><span class="line">		if(StackEmpty(S))&#123;</span><br><span class="line">			printf(&quot;栈空了&quot;); </span><br><span class="line">			return S;</span><br><span class="line">	    &#125;</span><br><span class="line">		*x&#x3D;S.base[S.top];</span><br><span class="line">		S.top--;</span><br><span class="line">		return S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Fprintf(int m)&#123;		&#x2F;&#x2F;转换进制后能显示ABC等</span><br><span class="line">	if(m&lt;10)&#123;</span><br><span class="line">		printf(&quot;%d&quot;,m);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		char c&#x3D;m-10+&#39;A&#39;;</span><br><span class="line">		printf(&quot;%c&quot;,c);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve(int n,int r)&#123;</span><br><span class="line">	int m;</span><br><span class="line">	SqStack ss&#x3D;SqStackInit();</span><br><span class="line">	while(n&gt;&#x3D;r)&#123;</span><br><span class="line">		m&#x3D;n%r;</span><br><span class="line">		n&#x3D;n&#x2F;r;</span><br><span class="line">		ss&#x3D;SqStackPush(ss,m);</span><br><span class="line">	&#125;</span><br><span class="line">	ss&#x3D;SqStackPush(ss,n);</span><br><span class="line">	while(!StackEmpty(ss))&#123;</span><br><span class="line">		int m&#x3D;GetSqStackTop(ss);</span><br><span class="line">		ss&#x3D;SqStackPop(ss,&amp;m);</span><br><span class="line">		Fprintf(m);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	&#x2F;&#x2F;测试 </span><br><span class="line">&#x2F;&#x2F;	int a[5];</span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;&quot;请输入5个整数构成一个栈&quot; &lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	for(int i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">&#x2F;&#x2F;		cin&gt;&gt;a[i];</span><br><span class="line">&#x2F;&#x2F;	&#125; </span><br><span class="line">&#x2F;&#x2F;	SqStack s&#x3D;SqStackInit();</span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;&quot;现在将初始化一个栈！&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	if(StackEmpty(s))&#123;</span><br><span class="line">&#x2F;&#x2F;		cout&lt;&lt;&quot;栈空&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	&#125;</span><br><span class="line">&#x2F;&#x2F;	else cout&lt;&lt;&quot;栈非空&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;&quot;现在将上面的元素入栈&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	for(int i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">&#x2F;&#x2F;	 	s&#x3D;SqStackPush(s,a[i]);</span><br><span class="line">&#x2F;&#x2F;	 &#125;</span><br><span class="line">&#x2F;&#x2F;	cout&lt;&lt;&quot;现在将依次出栈&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	for(int i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">&#x2F;&#x2F;	 	cout&lt;&lt;&quot;栈顶元素&quot;&lt;&lt;GetSqStackTop(s)&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;	 	s&#x3D;SqStackPop(s,&amp;s.top);</span><br><span class="line">&#x2F;&#x2F;	 &#125;	</span><br><span class="line">&#x2F;&#x2F;	if(StackEmpty(s))&#123;</span><br><span class="line">&#x2F;&#x2F;		cout&lt;&lt;&quot;栈空&quot;&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;			&#125;  </span><br><span class="line">&#x2F;&#x2F;		else cout&lt;&lt;&quot;栈非空&quot;&lt;&lt;endl;</span><br><span class="line">	int n,r;</span><br><span class="line">	printf(&quot;请输入一个整数和要转换的进制数\n&quot;);</span><br><span class="line">	</span><br><span class="line">	while(scanf(&quot;%d %d&quot;,&amp;n,&amp;r))&#123;</span><br><span class="line">		solve(n,r);</span><br><span class="line">		printf(&quot;请输入一个整数和要转换的进制数\n&quot;);</span><br><span class="line">	&#125; </span><br><span class="line">	return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p><img src="https://img-blog.csdnimg.cn/20190704122615842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
<h1 id="2-表达式求值"><a href="#2-表达式求值" class="headerlink" title="2.表达式求值"></a>2.表达式求值</h1><p>如果学过编译原理，这个是比较好理解的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;              &#x2F;&#x2F; 内含isdigit()函数</span><br><span class="line">#include &lt;string.h&gt;         </span><br><span class="line">#define STACK_INIT_SIZE 100     &#x2F;&#x2F; 栈容量</span><br><span class="line">#define STACK_INCREMENT 10      &#x2F;&#x2F; 栈增量</span><br><span class="line"></span><br><span class="line">typedef float DATATYPE;</span><br><span class="line">typedef char SYMBOLTYPE;</span><br><span class="line"></span><br><span class="line">typedef struct stack</span><br><span class="line">&#123;</span><br><span class="line">    int *base;         		&#x2F;&#x2F; 基地址</span><br><span class="line">    int *top;          		&#x2F;&#x2F; 栈顶指针</span><br><span class="line">    int stackSize;          &#x2F;&#x2F; 栈容量</span><br><span class="line">&#125;*Stack,LinkStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈的初始化</span><br><span class="line">Stack Init_Stack(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    S&#x3D;(Stack)malloc(sizeof(Stack));</span><br><span class="line">    if(!S)</span><br><span class="line">        exit(0);</span><br><span class="line">        </span><br><span class="line">    S-&gt;base &#x3D; (int*)malloc(STACK_INIT_SIZE*sizeof(DATATYPE));</span><br><span class="line"></span><br><span class="line">    if(!S-&gt;base)</span><br><span class="line">        exit(0);</span><br><span class="line"></span><br><span class="line">    S-&gt;top &#x3D; S-&gt;base;</span><br><span class="line">    S-&gt;stackSize &#x3D; STACK_INIT_SIZE;</span><br><span class="line">    return S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判栈空</span><br><span class="line">int IsEmpty(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;    if (S-&gt;top &#x3D;&#x3D; S-&gt;base)&#123;</span><br><span class="line">&#x2F;&#x2F;        return 1;</span><br><span class="line">&#x2F;&#x2F;    &#125; </span><br><span class="line">&#x2F;&#x2F;	else&#123;</span><br><span class="line">&#x2F;&#x2F;        return 0;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">    return (S-&gt;top&#x3D;&#x3D;S-&gt;base ? 1:0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判栈满</span><br><span class="line">int IsFull(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;    if (S-&gt;top - S-&gt;base &#x3D;&#x3D; S-&gt;stackSize) &#123;</span><br><span class="line">&#x2F;&#x2F;        return 1;</span><br><span class="line">&#x2F;&#x2F;    &#125; </span><br><span class="line">&#x2F;&#x2F;	else&#123;</span><br><span class="line">&#x2F;&#x2F;        return 0;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">    return (S-&gt;top - S-&gt;base &#x3D;&#x3D; S-&gt;stackSize ? 1:0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 操作数压栈</span><br><span class="line">void Push(Stack S, DATATYPE e)</span><br><span class="line">&#123;</span><br><span class="line">    if (IsFull(S))</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        S-&gt;base &#x3D; (int*)malloc((STACK_INIT_SIZE+STACK_INCREMENT)*sizeof(DATATYPE));</span><br><span class="line"></span><br><span class="line">        if (!S-&gt;base)</span><br><span class="line"></span><br><span class="line">            exit(0);        &#x2F;&#x2F; 存储分配失败</span><br><span class="line"></span><br><span class="line">        S-&gt;top &#x3D; S-&gt;base + S-&gt;stackSize;</span><br><span class="line"></span><br><span class="line">        S-&gt;stackSize +&#x3D; STACK_INCREMENT;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *S-&gt;top++ &#x3D; e;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 运算符压栈</span><br><span class="line">void PushSymbol(Stack S, SYMBOLTYPE e)</span><br><span class="line">&#123;</span><br><span class="line">    if (IsFull(S))</span><br><span class="line">    &#123;</span><br><span class="line">        S-&gt;base &#x3D; (int*)malloc((STACK_INIT_SIZE+STACK_INCREMENT)*sizeof(DATATYPE));</span><br><span class="line"></span><br><span class="line">        if (!S-&gt;base)</span><br><span class="line">            exit(0);        &#x2F;&#x2F; 存储分配失败</span><br><span class="line"></span><br><span class="line">        S-&gt;top &#x3D; S-&gt;base + S-&gt;stackSize;</span><br><span class="line">        S-&gt;stackSize +&#x3D; STACK_INCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *S-&gt;top++ &#x3D; e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 操作数弹栈</span><br><span class="line">DATATYPE Pop(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    if (S-&gt;top &#x3D;&#x3D; S-&gt;base)</span><br><span class="line">        return 0;              &#x2F;&#x2F; 空栈弹出0保证部分负数的正确运算</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return *--S-&gt;top;     &#x2F;&#x2F; *--S-&gt;top就是*(--S-&gt;top)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 运算符弹栈</span><br><span class="line">SYMBOLTYPE PopSymbol(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    if (S-&gt;top &#x3D;&#x3D; S-&gt;base)</span><br><span class="line">        return 0;</span><br><span class="line">    else&#123;</span><br><span class="line">        return *--S-&gt;top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈的销毁</span><br><span class="line">void DestroyStack(Stack S) &#123;</span><br><span class="line">    free(S-&gt;base);</span><br><span class="line">	free(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 运算符优先级表</span><br><span class="line">char Priority[7][7] &#x3D;		   &#x2F;&#x2F;行row（左边的）是栈顶运算符，列col（上边的）是入栈运算符</span><br><span class="line">&#123;       				 	</span><br><span class="line">		 &#x2F;&#x2F; &#39;+&#39; &#39;-&#39; &#39;*&#39; &#39;&#x2F;&#39; &#39;(&#39; &#39;)&#39; &#39;#&#39;   			</span><br><span class="line">    &#123;&#x2F;*&#39;+&#39;*&#x2F;&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;&#x2F;*&#39;-&#39;*&#x2F;&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;&#x2F;*&#39;*&#39;*&#x2F;&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;&#x2F;*&#39;&#x2F;&#39;*&#x2F;&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;&#x2F;*&#39;(&#39;*&#x2F;&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&#x3D;&#39;,&#39;0&#39;&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;&#x2F;*&#39;)&#39;*&#x2F;&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;,&#39;0&#39;,&#39;&gt;&#39;,&#39;&gt;&#39;&#125;,</span><br><span class="line"></span><br><span class="line">  	&#123;&#x2F;*&#39;#&#39;*&#x2F;&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;&lt;&#39;,&#39;0&#39;,&#39;&#x3D;&#39;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 确定运算符所在的行数或列数</span><br><span class="line">int Operator(char c)</span><br><span class="line">&#123;</span><br><span class="line">    switch(c)</span><br><span class="line">    &#123;</span><br><span class="line">        case &#39;+&#39;: return 0;</span><br><span class="line">        case &#39;-&#39;: return 1;</span><br><span class="line">        case &#39;*&#39;: return 2;</span><br><span class="line">        case &#39;&#x2F;&#39;: return 3;</span><br><span class="line">        case &#39;(&#39;: return 4;</span><br><span class="line">        case &#39;)&#39;: return 5;</span><br><span class="line">        case &#39;#&#39;: return 6;</span><br><span class="line">        default:  return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 计算弹出的两个操作数与弹出栈顶运算符的值</span><br><span class="line">float Calculation(float a, char op, float b)</span><br><span class="line">&#123;</span><br><span class="line">    switch(op)</span><br><span class="line">    &#123;</span><br><span class="line">        case &#39;+&#39;: return a+b;</span><br><span class="line">        case &#39;-&#39;: return a-b;</span><br><span class="line">        case &#39;*&#39;: return a*b;</span><br><span class="line">        case &#39;&#x2F;&#39;: return a&#x2F;b;</span><br><span class="line">        default:  return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 表达式求值函数</span><br><span class="line">float CalculatingExpression(char *s)</span><br><span class="line">&#123;</span><br><span class="line">    int i;  </span><br><span class="line">    strcat(s, &quot;#&quot;);                 				&#x2F;&#x2F; 为表达式s串接&quot;#&quot;</span><br><span class="line">    Stack OPND&#x3D;NULL;</span><br><span class="line">    OPND &#x3D; Init_Stack(OPND);       					&#x2F;&#x2F; 创建操作数栈</span><br><span class="line">    </span><br><span class="line">    Stack OPTR&#x3D;NULL;</span><br><span class="line">    OPTR &#x3D; Init_Stack(OPTR);       					&#x2F;&#x2F; 创建运算符栈</span><br><span class="line"></span><br><span class="line">    PushSymbol(OPTR, &#39;#&#39;);          				&#x2F;&#x2F;&quot;#&quot;压栈作为运算符栈的栈底元素</span><br><span class="line"></span><br><span class="line">    for (i&#x3D;0; i&lt;strlen(s); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while(s[i]&#x3D;&#x3D;&#39; &#39;)            				&#x2F;&#x2F; while循环跳过空格</span><br><span class="line">            i++;</span><br><span class="line"> </span><br><span class="line">        if (isdigit(s[i]))         					&#x2F;&#x2F; 判断是否是数字</span><br><span class="line">        &#123;</span><br><span class="line">            int j&#x3D;i;</span><br><span class="line">            i++;</span><br><span class="line">            while(isdigit(s[i]))        			&#x2F;&#x2F; 确定是几位数</span><br><span class="line">            &#123;</span><br><span class="line">               i++;</span><br><span class="line">            &#125;                  </span><br><span class="line">			char str[10]&#x3D;&quot;&quot;;</span><br><span class="line">  			if (!isdigit(s[i]))     				&#x2F;&#x2F; 此时的i应该指向一个运算符(包括#) </span><br><span class="line">            &#123;		 </span><br><span class="line">	            for (;j&lt;i;j++)          			&#x2F;&#x2F; 将字符串数组下标j到i的数字字符转换为字符串</span><br><span class="line">	            &#123;</span><br><span class="line">	                char c[2] &#x3D; &#123;s[j]&#125;;</span><br><span class="line">	                strcat(str, c);</span><br><span class="line">	            &#125;</span><br><span class="line">	            i--;								&#x2F;&#x2F;如果不减1，for循环里的i++则跳过了运算符</span><br><span class="line">            &#125;           </span><br><span class="line"></span><br><span class="line">            float operand &#x3D; atof(str);  			&#x2F;&#x2F; 将字符串转换为浮点数</span><br><span class="line">            Push(OPND, operand);        			&#x2F;&#x2F; 浮点数压入操作数栈</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;										&#x2F;&#x2F; 不是数字，就是操作符了 </span><br><span class="line"></span><br><span class="line">            int row &#x3D; Operator(*(OPTR-&gt;top-1)), 	&#x2F;&#x2F; 确定栈顶运算符的行数</span><br><span class="line">				col &#x3D; Operator(s[i]);       		&#x2F;&#x2F; 确定入栈运算符的列数</span><br><span class="line"></span><br><span class="line">            switch(Priority[row][col])              &#x2F;&#x2F; 确定优先级</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                case &#39;&lt;&#39;: PushSymbol(OPTR, s[i]); break;</span><br><span class="line"></span><br><span class="line">                case &#39;&gt;&#39;: Push(OPND, Calculation(Pop(OPND), PopSymbol(OPTR), Pop(OPND))); --i; break;       </span><br><span class="line"></span><br><span class="line">                             &#x2F;&#x2F;Push()参数里右边的Pop先执行；--i是为了下次继续对当前入栈运算符s[i]进行判断</span><br><span class="line"></span><br><span class="line">                case &#39;&#x3D;&#39;: PopSymbol(OPTR); break;</span><br><span class="line"></span><br><span class="line">                default:  printf(&quot;输入错误，请检查数字之间是否有空格，表达式是否正确！\n&quot;);</span><br><span class="line"></span><br><span class="line">                          DestroyStack(OPTR);</span><br><span class="line"></span><br><span class="line">                          DestroyStack(OPND);</span><br><span class="line"></span><br><span class="line">                          return -1;           &#x2F;&#x2F; 运行到这一步，说明表达式错误</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DestroyStack(OPTR);</span><br><span class="line"></span><br><span class="line">    return Pop(OPND);       &#x2F;&#x2F; 运行到这一步，说明表达式正确，弹出操作数栈的值即为运算结果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    char s[100];</span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入要计算的表达式：\n&quot;);</span><br><span class="line"></span><br><span class="line">    gets(s);</span><br><span class="line"></span><br><span class="line">    printf(&quot;表达式 %s 的值为：\n&quot;, s);</span><br><span class="line"></span><br><span class="line">    printf(&quot;%1.2f&quot;, CalculatingExpression(s));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="运行结果：-1"><a href="#运行结果：-1" class="headerlink" title="运行结果："></a>运行结果：</h2><p><strong><em>注意：“/”，做的是取商操作，不是“÷”。</em></strong><br><img src="https://img-blog.csdnimg.cn/20190704123502959.png" alt="在这里插入图片描述"><br><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
]]></content>
      <tags>
        <tag>栈的应用</tag>
      </tags>
  </entry>
  <entry>
    <title>栈--顺序栈与链栈</title>
    <url>/2019/07/03/%E6%A0%88--%E9%A1%BA%E5%BA%8F%E6%A0%88%E4%B8%8E%E9%93%BE%E6%A0%88/</url>
    <content><![CDATA[ <body >
    <div id="topAnchor"></div>
</body>


<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><ul>
<li>逻辑结构：线性表</li>
<li>存储结构：顺序存储\链式存储</li>
<li>基本运算：<ol>
<li>初始化</li>
<li>判断栈空</li>
<li>判断栈满</li>
<li>入栈</li>
<li>出栈</li>
<li>取栈顶元素</li>
</ol>
</li>
</ul>
<p><strong><em>注意：栈也是线性表，其特殊性在于有特殊的运算规则。即：栈结构只能在一端进行操作，该操作端称为栈顶，另一端称为栈底。按照“后进先出”（Last In First Out,LIFO）原则处理数据节点。</em></strong></p>
<h2 id="1-顺序栈"><a href="#1-顺序栈" class="headerlink" title="1. 顺序栈"></a>1. 顺序栈</h2><ul>
<li><h4 id="顺序栈的定义"><a href="#顺序栈的定义" class="headerlink" title="顺序栈的定义"></a>顺序栈的定义</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct stack</span><br><span class="line">&#123;</span><br><span class="line">    int *base;        	 	&#x2F;&#x2F; 基地址</span><br><span class="line">    int *top;          		&#x2F;&#x2F; 栈顶指针</span><br><span class="line">    int stackSize;          &#x2F;&#x2F; 栈容量</span><br><span class="line">&#125;*Stack;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="顺序栈的初始化"><a href="#顺序栈的初始化" class="headerlink" title="顺序栈的初始化"></a>顺序栈的初始化</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack Init_Stack(Stack S)				&#x2F;&#x2F; 栈的初始化</span><br><span class="line">&#123;</span><br><span class="line">    S&#x3D;(Stack)malloc(sizeof(Stack));</span><br><span class="line">    if(!S)</span><br><span class="line">        exit(0);</span><br><span class="line">        </span><br><span class="line">    S-&gt;base &#x3D; (int*)malloc(STACK_INIT_SIZE*sizeof(DATATYPE));</span><br><span class="line"></span><br><span class="line">    if(!S-&gt;base)</span><br><span class="line">        exit(0);</span><br><span class="line"></span><br><span class="line">    S-&gt;top &#x3D; S-&gt;base;</span><br><span class="line">    S-&gt;stackSize &#x3D; STACK_INIT_SIZE;</span><br><span class="line">    return S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="判断栈空"><a href="#判断栈空" class="headerlink" title="判断栈空"></a>判断栈空</h4>栈底等于栈顶即为空。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int IsEmpty(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    if (S-&gt;top &#x3D;&#x3D; S-&gt;base)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; </span><br><span class="line">	else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="判断栈满"><a href="#判断栈满" class="headerlink" title="判断栈满"></a>判断栈满</h4>栈顶减栈底等于栈容量即为栈满。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int IsFull(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    if (S-&gt;top - S-&gt;base &#x3D;&#x3D; S-&gt;stackSize) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; </span><br><span class="line">	else&#123;</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></li>
<li><h4 id="顺序栈的入栈"><a href="#顺序栈的入栈" class="headerlink" title="顺序栈的入栈"></a>顺序栈的入栈</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Push(Stack S, DATATYPE e)				&#x2F;&#x2F; 数据压进栈</span><br><span class="line">&#123;</span><br><span class="line">    assert(S);</span><br><span class="line"></span><br><span class="line">    if (IsFull(S))</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        S-&gt;base &#x3D; (int*)malloc((STACK_INIT_SIZE+STACK_INCREMENT)*sizeof(DATATYPE));</span><br><span class="line"></span><br><span class="line">        if (!S-&gt;base)</span><br><span class="line"></span><br><span class="line">            exit(0);       					 &#x2F;&#x2F; 存储分配失败</span><br><span class="line"></span><br><span class="line">        S-&gt;top &#x3D; S-&gt;base + S-&gt;stackSize;</span><br><span class="line"></span><br><span class="line">        S-&gt;stackSize +&#x3D; STACK_INCREMENT;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *S-&gt;top++ &#x3D; e;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="顺序栈的出栈"><a href="#顺序栈的出栈" class="headerlink" title="顺序栈的出栈"></a>顺序栈的出栈</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DATATYPE Pop(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    assert(S);</span><br><span class="line">    if (S-&gt;top &#x3D;&#x3D; S-&gt;base)</span><br><span class="line">        return 0;     </span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return *--S-&gt;top;     &#x2F;&#x2F; *--S-&gt;top就是*(--S-&gt;top)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 访问栈顶 </span><br><span class="line">DATATYPE GetTop(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    assert(S);</span><br><span class="line">    if (S-&gt;top &#x3D;&#x3D; S-&gt;base)</span><br><span class="line">        return 0;         </span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return *(S-&gt;top-1);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><em>注意：取栈顶元素与出栈的区别：</em></strong><br>*<strong>出栈</strong>：数据从栈中移出，<br><strong>取栈顶</strong>：只是访问了一下栈顶，数据还在栈中。*</p>
<ul>
<li><h4 id="顺序栈的销毁"><a href="#顺序栈的销毁" class="headerlink" title="顺序栈的销毁"></a>顺序栈的销毁</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void DestroyStack(Stack S) &#123;</span><br><span class="line">    free(S-&gt;base);</span><br><span class="line">	free(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></li>
<li><h4 id="总的代码"><a href="#总的代码" class="headerlink" title="总的代码"></a>总的代码</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;             &#x2F;&#x2F; 断言函数</span><br><span class="line">#define STACK_INIT_SIZE 100     &#x2F;&#x2F; 栈容量</span><br><span class="line">#define STACK_INCREMENT 10      &#x2F;&#x2F; 栈增量</span><br><span class="line"></span><br><span class="line">typedef int DATATYPE;</span><br><span class="line"></span><br><span class="line">typedef struct stack</span><br><span class="line">&#123;</span><br><span class="line">    int *base;        	 &#x2F;&#x2F; 基地址</span><br><span class="line">    int *top;         	 &#x2F;&#x2F; 栈顶指针</span><br><span class="line">    int stackSize;       &#x2F;&#x2F; 栈容量</span><br><span class="line">&#125;*Stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈的初始化</span><br><span class="line">Stack Init_Stack(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    S&#x3D;(Stack)malloc(sizeof(Stack));</span><br><span class="line">    if(!S)</span><br><span class="line">        exit(0);</span><br><span class="line">        </span><br><span class="line">    S-&gt;base &#x3D; (int*)malloc(STACK_INIT_SIZE*sizeof(DATATYPE));</span><br><span class="line"></span><br><span class="line">    if(!S-&gt;base)</span><br><span class="line">        exit(0);</span><br><span class="line"></span><br><span class="line">    S-&gt;top &#x3D; S-&gt;base;</span><br><span class="line">    S-&gt;stackSize &#x3D; STACK_INIT_SIZE;</span><br><span class="line">    return S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判栈空</span><br><span class="line">int IsEmpty(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    if (S-&gt;top &#x3D;&#x3D; S-&gt;base)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; </span><br><span class="line">	else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判栈满</span><br><span class="line">int IsFull(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    if (S-&gt;top - S-&gt;base &#x3D;&#x3D; S-&gt;stackSize) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; </span><br><span class="line">	else&#123;</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 操作数压栈</span><br><span class="line">void Push(Stack S, DATATYPE e)</span><br><span class="line">&#123;</span><br><span class="line">    assert(S);</span><br><span class="line"></span><br><span class="line">    if (IsFull(S))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        S-&gt;base &#x3D; (int*)malloc((STACK_INIT_SIZE+STACK_INCREMENT)*sizeof(DATATYPE));</span><br><span class="line"></span><br><span class="line">        if (!S-&gt;base)</span><br><span class="line"></span><br><span class="line">            exit(0);        &#x2F;&#x2F; 存储分配失败</span><br><span class="line"></span><br><span class="line">        S-&gt;top &#x3D; S-&gt;base + S-&gt;stackSize;</span><br><span class="line"></span><br><span class="line">        S-&gt;stackSize +&#x3D; STACK_INCREMENT;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *S-&gt;top++ &#x3D; e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 操作数弹栈</span><br><span class="line">DATATYPE Pop(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    assert(S);</span><br><span class="line">    if (S-&gt;top &#x3D;&#x3D; S-&gt;base)</span><br><span class="line">        return 0;              &#x2F;&#x2F; 空栈弹出0保证部分负数的正确运算</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return *--S-&gt;top;     &#x2F;&#x2F; *--S-&gt;top就是*(--S-&gt;top)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 访问栈顶 </span><br><span class="line">DATATYPE GetTop(Stack S)</span><br><span class="line">&#123;</span><br><span class="line">    assert(S);</span><br><span class="line">    if (S-&gt;top &#x3D;&#x3D; S-&gt;base)</span><br><span class="line">        return 0;         </span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return *(S-&gt;top-1);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 栈的销毁</span><br><span class="line">void DestroyStack(Stack S) &#123;</span><br><span class="line">    free(S-&gt;base);</span><br><span class="line">	free(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  	Stack OPND&#x3D;NULL;</span><br><span class="line">    OPND &#x3D; Init_Stack(OPND);        &#x2F;&#x2F; 创建操作数栈</span><br><span class="line">	int i;</span><br><span class="line">	for (i&#x3D;0; i&lt;5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	Push(OPND,i); </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    for (i&#x3D;0; i&lt;5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	printf(&quot;此时的栈顶为：%d\n&quot;,GetTop(OPND));</span><br><span class="line">    	printf(&quot;将%d出栈\n&quot;,Pop(OPND)); </span><br><span class="line">    &#125;</span><br><span class="line">    DestroyStack(OPND);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><img src="https://img-blog.csdnimg.cn/20190703105612641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a><h2 id="2-链栈"><a href="#2-链栈" class="headerlink" title="2.链栈"></a>2.链栈</h2></li>
<li><h4 id="链栈的定义"><a href="#链栈的定义" class="headerlink" title="链栈的定义"></a>链栈的定义</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct node			&#x2F;&#x2F;定义节点</span><br><span class="line">&#123;</span><br><span class="line">    DATATYPE data;</span><br><span class="line">    struct node * next;</span><br><span class="line">&#125; StackNode;</span><br><span class="line"></span><br><span class="line">typedef struct				&#x2F;&#x2F;定义一个链栈</span><br><span class="line">&#123;</span><br><span class="line">    StackNode * top;  		&#x2F;&#x2F;总指向栈顶 </span><br><span class="line">    int count;				&#x2F;&#x2F;计数器 记录链栈的元素个数</span><br><span class="line">&#125;Stack,*LinkStack;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="链栈的初始化"><a href="#链栈的初始化" class="headerlink" title="链栈的初始化"></a>链栈的初始化</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void init(LinkStack s)</span><br><span class="line">&#123;</span><br><span class="line">    s-&gt;top&#x3D;NULL;		&#x2F;&#x2F;该指针箭头指向为空</span><br><span class="line">    s-&gt;count&#x3D;0;			&#x2F;&#x2F;初始化时长度为零</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="判断栈空-1"><a href="#判断栈空-1" class="headerlink" title="判断栈空"></a>判断栈空</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int IsEmpty(LinkStack s)</span><br><span class="line">&#123;</span><br><span class="line">    return (s-&gt;top&#x3D;&#x3D;NULL? TRUE:FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
<ul>
<li><h4 id="链栈的入栈"><a href="#链栈的入栈" class="headerlink" title="链栈的入栈"></a>链栈的入栈</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void push(LinkStack s,DATATYPE a)</span><br><span class="line">&#123;</span><br><span class="line">    StackNode * p&#x3D;(StackNode *)malloc(sizeof(StackNode));</span><br><span class="line">    if(NULL&#x3D;&#x3D;p)				&#x2F;&#x2F;申请不成功</span><br><span class="line">        exit(1);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;data&#x3D;a;			</span><br><span class="line">        p-&gt;next&#x3D;s-&gt;top;		&#x2F;&#x2F;将新节点的指针域指向原栈顶节点</span><br><span class="line">        s-&gt;top&#x3D;p;			&#x2F;&#x2F;栈顶指针指向新节点</span><br><span class="line">        s-&gt;count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="链栈的出栈"><a href="#链栈的出栈" class="headerlink" title="链栈的出栈"></a>链栈的出栈</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DATATYPE pop(LinkStack s)</span><br><span class="line">&#123;</span><br><span class="line">    DATATYPE a; </span><br><span class="line">    if( IsEmpty(s))</span><br><span class="line">        return FALSE;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        a &#x3D;s-&gt;top-&gt;data;			&#x2F;&#x2F;将即将弹出的数据存在a中。不存也不影响出栈操作 </span><br><span class="line">        s-&gt;top&#x3D;s-&gt;top-&gt;next;</span><br><span class="line">        s-&gt;count--;</span><br><span class="line">        free(s-&gt;top);		</span><br><span class="line">		return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="取栈顶元素-1"><a href="#取栈顶元素-1" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DATATYPE GetTop(LinkStack S)</span><br><span class="line">&#123;</span><br><span class="line">    if(IsEmpty(S))</span><br><span class="line">        return FALSE;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return S-&gt;top-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
<ul>
<li><h4 id="总的代码-1"><a href="#总的代码-1" class="headerlink" title="总的代码"></a>总的代码</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># include&lt;stdio.h&gt;</span><br><span class="line"># include&lt;stdlib.h&gt;</span><br><span class="line"># define FALSE 0</span><br><span class="line"># define TRUE 1</span><br><span class="line"></span><br><span class="line">typedef int DATATYPE;</span><br><span class="line"></span><br><span class="line">typedef struct node			&#x2F;&#x2F;定义节点</span><br><span class="line">&#123;</span><br><span class="line">    DATATYPE data;</span><br><span class="line">    struct node * next;</span><br><span class="line">&#125; StackNode;</span><br><span class="line"></span><br><span class="line">typedef struct				&#x2F;&#x2F;定义一个链栈</span><br><span class="line">&#123;</span><br><span class="line">    StackNode * top;  		&#x2F;&#x2F;总指向栈顶 </span><br><span class="line">    int count;				&#x2F;&#x2F;计数器 记录链栈的元素个数</span><br><span class="line">&#125;Stack,*LinkStack;</span><br><span class="line"></span><br><span class="line">void init(LinkStack s);					&#x2F;&#x2F;初始化</span><br><span class="line">int IsEmpty(LinkStack s);				&#x2F;&#x2F;判断是否为空（链栈一般不会为满）</span><br><span class="line">void push(LinkStack s,DATATYPE a);		&#x2F;&#x2F;入栈</span><br><span class="line">DATATYPE pop(LinkStack s);				&#x2F;&#x2F;出栈</span><br><span class="line">DATATYPE GetTop(LinkStack S);			&#x2F;&#x2F;取栈顶元素</span><br><span class="line">int length(LinkStack s);				&#x2F;&#x2F;取链栈长度</span><br><span class="line"></span><br><span class="line">void init(LinkStack s)</span><br><span class="line">&#123;</span><br><span class="line">    s-&gt;top&#x3D;NULL;		&#x2F;&#x2F;该指针箭头指向为空</span><br><span class="line">    s-&gt;count&#x3D;0;			&#x2F;&#x2F;初始化时长度为零</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int IsEmpty(LinkStack s)</span><br><span class="line">&#123;</span><br><span class="line">    return (s-&gt;top&#x3D;&#x3D;NULL? TRUE:FALSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push(LinkStack s,DATATYPE a)</span><br><span class="line">&#123;</span><br><span class="line">    StackNode * p&#x3D;(StackNode *)malloc(sizeof(StackNode));</span><br><span class="line">    if(NULL&#x3D;&#x3D;p)				&#x2F;&#x2F;申请不成功</span><br><span class="line">        exit(1);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;data&#x3D;a;			</span><br><span class="line">        p-&gt;next&#x3D;s-&gt;top;		&#x2F;&#x2F;将新节点的指针域指向原栈顶节点</span><br><span class="line">        s-&gt;top&#x3D;p;			&#x2F;&#x2F;栈顶指针指向新节点</span><br><span class="line">        s-&gt;count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DATATYPE pop(LinkStack s)</span><br><span class="line">&#123;</span><br><span class="line">    DATATYPE a; </span><br><span class="line">    if( IsEmpty(s))</span><br><span class="line">        return FALSE;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        a &#x3D;s-&gt;top-&gt;data;			&#x2F;&#x2F;将即将弹出的数据存在a中。不存也不影响出栈操作 </span><br><span class="line">        s-&gt;top&#x3D;s-&gt;top-&gt;next;</span><br><span class="line">        s-&gt;count--;</span><br><span class="line">        free(s-&gt;top);		</span><br><span class="line">		return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DATATYPE GetTop(LinkStack S)</span><br><span class="line">&#123;</span><br><span class="line">    if(IsEmpty(S))</span><br><span class="line">        return FALSE;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return S-&gt;top-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int length(LinkStack s)</span><br><span class="line">&#123;</span><br><span class="line">    return s-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    init(&amp;S);        &#x2F;&#x2F; 创建操作数栈</span><br><span class="line"> 	int i;</span><br><span class="line">	for (i&#x3D;0; i&lt;5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	push(&amp;S,i); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;链栈长度为：%d\n&quot;,length(&amp;S));</span><br><span class="line">    	</span><br><span class="line">    while(!IsEmpty(&amp;S))</span><br><span class="line">    &#123;    </span><br><span class="line">		printf(&quot;此时的栈顶为：%d\n&quot;,GetTop(&amp;S));  </span><br><span class="line">        printf(&quot;将%d出栈\n&quot;,pop(&amp;S)); </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><img src="https://img-blog.csdnimg.cn/20190703142621889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<p><strong><em>注意：顺序栈的栈顶指向的是即将入栈的位置，没有指着任何数据，所以栈顶减栈底可以判断是否为空或满。而链栈的指针指向的是栈顶的数据，所以s-&gt;top==NULL就可以判断是否为空。别搞混了。</em></strong></p>
<p><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
]]></content>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>链表--学生信息管理</title>
    <url>/2019/07/02/%E9%93%BE%E8%A1%A8--%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[ <body >
    <div id="topAnchor"></div>
</body>


<h1 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h1><ul>
<li>逻辑结构：线性表</li>
<li>存储结构：链式存储</li>
<li>基本运算：<pre><code>  1. 初始化
  2. 查找节点
  3. 插入节点
  4. 删除节点
  5. 创建单链表</code></pre>
<h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2>其中，节点包含两部分的内容：</li>
</ul>
<p><strong>数据域：</strong> 保存该节点的实际数据。<br><strong>指针域：</strong> 保存的是下一节点的地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Student			&#x2F;&#x2F;学生结构</span><br><span class="line">&#123;</span><br><span class="line">	char Name[10];		&#x2F;&#x2F;姓名</span><br><span class="line">	int No;				&#x2F;&#x2F;学号</span><br><span class="line">	float Score[3];		&#x2F;&#x2F;三科的成绩</span><br><span class="line">	float Total;		&#x2F;&#x2F;总分</span><br><span class="line">	float Ave;			&#x2F;&#x2F;平均分</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct Node		&#x2F;&#x2F;结点</span><br><span class="line">&#123;</span><br><span class="line">	struct Student st;	&#x2F;&#x2F;数据域</span><br><span class="line">	struct Node *next;	&#x2F;&#x2F;指针域</span><br><span class="line">&#125;NODE, *PNODE;			&#x2F;&#x2F;NODE等价于struct Student st||PNODE等价于struct Node *next</span><br><span class="line">						&#x2F;&#x2F;NODE * P&#x3D;&#x3D;PNODE P。为了提高可读性用NODE定义指向其他任意节点。用PNODE专指向头结点 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化一个头结点，它不存储学生信息，也可以不存任何信息，也可以存附加信息，如存表长。它的指针域指向第一个节点。之所以引入头结点，就是为了方便，即使不用头结点，也能完成相同的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PNODE InitList(PNODE pHead)</span><br><span class="line">&#123;</span><br><span class="line">	PNODE p&#x3D;pHead;</span><br><span class="line">	p &#x3D; (PNODE)malloc(sizeof(NODE));&#x2F;&#x2F;为头结点分配内存</span><br><span class="line">	if(NULL &#x3D;&#x3D; p)	&#x2F;&#x2F;判断内存是否为空</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;内存分配失败,程序终止!\n&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;next &#x3D; NULL;&#x2F;&#x2F;清空指针域</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找可以按不同的域去查找，这里以按姓名查找为例，核心代码都一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SearchStudent(PNODE pHead)			&#x2F;&#x2F;查找学生信息</span><br><span class="line">&#123;</span><br><span class="line">	char Name[10];</span><br><span class="line">	printf(&quot;请输入你需要查找的学生的姓名:&quot;);</span><br><span class="line">	scanf(&quot;%s&quot;,Name);</span><br><span class="line">	PNODE p &#x3D; pHead-&gt;next;				&#x2F;&#x2F;p指向第一个节点 </span><br><span class="line">	while(p)</span><br><span class="line">	&#123;</span><br><span class="line">		if(0 &#x3D;&#x3D; strcmp(Name,p-&gt;st.Name))</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;%s %d %g %g %g %g %g\n&quot;,p-&gt;st.Name, p-&gt;st.No, p-&gt;st.Score[0], p-&gt;st.Score[1], p-&gt;st.Score[2], p-&gt;st.Total, p-&gt;st.Ave);</span><br><span class="line">		&#125;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void InsertStudent(PNODE pHead)		&#x2F;&#x2F;插入学生信息</span><br><span class="line">&#123;</span><br><span class="line">	PNODE p &#x3D; pHead;</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	struct Student stu;				&#x2F;&#x2F;学生结构，为数据域</span><br><span class="line">	int pos;						&#x2F;&#x2F;插入结点的位置</span><br><span class="line">	printf(&quot;请输入插入学生的位置:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;pos);</span><br><span class="line">	while(p &amp;&amp; i&lt;pos-1)</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	if(p &#x3D;&#x3D; NULL || i&gt;pos)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;插入结点的位置不存在!\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;你将在第%d个学生后面插入一个学生\n&quot;,pos-1);</span><br><span class="line">	printf(&quot;请输入第%d个学生的姓名:&quot;,pos);</span><br><span class="line">	scanf(&quot;%s&quot;,stu.Name);</span><br><span class="line">	printf(&quot;请输入第%d个学生的学号:&quot;,pos);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;stu.No);</span><br><span class="line">	printf(&quot;请输入第%d个学生的语文成绩:&quot;,pos);</span><br><span class="line">	scanf(&quot;%f&quot;,&amp;stu.Score[0]);</span><br><span class="line">	printf(&quot;请输入第%d个学生的数学成绩:&quot;,pos);</span><br><span class="line">	scanf(&quot;%f&quot;,&amp;stu.Score[1]);</span><br><span class="line">	printf(&quot;请输入第%d个学生的英语成绩:&quot;,pos);</span><br><span class="line">	scanf(&quot;%f&quot;,&amp;stu.Score[2]);</span><br><span class="line"></span><br><span class="line">	stu.Total &#x3D; stu.Score[0] + stu.Score[1] + stu.Score[2];&#x2F;&#x2F;计算总分	</span><br><span class="line">	stu.Ave &#x3D; stu.Total &#x2F; 3.0f;&#x2F;&#x2F;计算平均分</span><br><span class="line">	PNODE pNew &#x3D; (PNODE)malloc(sizeof(NODE));</span><br><span class="line">	if(NULL &#x3D;&#x3D; pNew)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;动态内存分配失败,程序终止!\n&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line">	pNew-&gt;st &#x3D; stu;</span><br><span class="line">	PNODE q &#x3D; p-&gt;next;			&#x2F;&#x2F;先把后继存起来 </span><br><span class="line">	p-&gt;next &#x3D; pNew;				&#x2F;&#x2F;然后把要插的插进来 </span><br><span class="line">	pNew-&gt;next &#x3D; q;				&#x2F;&#x2F;将刚刚保存的节点挂上 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除与插入其实差不多，主要就是改变指针的指向，使其指向合适的位置即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void DeleteStudent(PNODE pHead)				&#x2F;&#x2F;删除学生信息</span><br><span class="line">&#123;</span><br><span class="line">	PNODE p &#x3D; pHead;</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	int pos;</span><br><span class="line">	printf(&quot;请输入你需要删除的学生的编号:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;pos);</span><br><span class="line">	while(p &amp;&amp; i&lt;pos-1)</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(p &#x3D;&#x3D; NULL || i&gt;pos-1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;没找到需要删除的学生的编号!\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	PNODE q &#x3D; p-&gt;next;</span><br><span class="line">	p-&gt;next &#x3D; q-&gt;next;</span><br><span class="line">	free(q);</span><br><span class="line">	q &#x3D;&#x3D; NULL;</span><br><span class="line">	printf(&quot;你已经成功删除了第%d个学生的信息!\n&quot;,pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
<h2 id="创建单链表"><a href="#创建单链表" class="headerlink" title="创建单链表"></a>创建单链表</h2><p>链表的形成，有两种策略：有点栈和队列的意味。<br><strong>前插法创建单链表：</strong> 后插入的值在链表的前面。<br><strong>后插法创建单链表：</strong> 后插入的就挂在链尾即可。</p>
<ol>
<li>采用后插法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void InputStudent(PNODE pHead)			&#x2F;&#x2F;采用后插法创建单链表 </span><br><span class="line">&#123;</span><br><span class="line">	NODE stu;</span><br><span class="line">	PNODE p&#x3D;pHead;</span><br><span class="line">	PNODE pTail&#x3D;NULL;</span><br><span class="line">	while(NULL !&#x3D; p-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	pTail&#x3D;p; </span><br><span class="line"></span><br><span class="line">	printf(&quot;请输入学生的人数:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;len);</span><br><span class="line">	int i;</span><br><span class="line">	for(i&#x3D;0; i&lt;len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		system(&quot;cls&quot;);				&#x2F;&#x2F;清屏</span><br><span class="line">		&#x2F;&#x2F;下面得到数据域</span><br><span class="line">		printf(&quot;请输入第%d个学生的姓名:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%s&quot;, stu.st.Name);</span><br><span class="line">		printf(&quot;请输入第%d个学生的学号:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;stu.st.No);</span><br><span class="line">		printf(&quot;请输入第%d个学生的语文成绩:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%f&quot;, &amp;stu.st.Score[0]);</span><br><span class="line">		printf(&quot;请输入第%d个学生的数学成绩:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%f&quot;, &amp;stu.st.Score[1]);</span><br><span class="line">		printf(&quot;请输入第%d个学生的英语成绩:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%f&quot;, &amp;stu.st.Score[2]);</span><br><span class="line"></span><br><span class="line">		stu.st.Total &#x3D; stu.st.Score[0] + stu.st.Score[1] + stu.st.Score[2];	&#x2F;&#x2F;计算总分</span><br><span class="line">		stu.st.Ave &#x3D; stu.st.Total &#x2F; 3.0f;									&#x2F;&#x2F;计算平均分</span><br><span class="line"></span><br><span class="line">		PNODE pNew &#x3D; (PNODE)malloc(sizeof(NODE));							&#x2F;&#x2F;为新节点分配内存</span><br><span class="line">		if(NULL &#x3D;&#x3D; pNew)															&#x2F;&#x2F;判断内存是否为空</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;内存分配失败,程序终止!\n&quot;);</span><br><span class="line">			exit(-1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pNew-&gt;st &#x3D; stu.st;													&#x2F;&#x2F;初始化结点的数据域	</span><br><span class="line">		pNew-&gt;next &#x3D; NULL;													&#x2F;&#x2F;清空新结点的指针域</span><br><span class="line">		&#x2F;&#x2F;以上两步构建了新的尾巴 </span><br><span class="line">		</span><br><span class="line">		pTail-&gt;next &#x3D; pNew;													&#x2F;&#x2F;将新结点挂在了链上 </span><br><span class="line">		&#x2F;&#x2F;后插法，插入的位置就是即将成为尾部的位置 </span><br><span class="line">		pTail &#x3D; pNew;																&#x2F;&#x2F;将pTail移到新的尾结点上</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>采用前插法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PNODE InputStudent()									&#x2F;&#x2F;采用前插法创建单链表 </span><br><span class="line">&#123;</span><br><span class="line">	int len;&#x2F;&#x2F;学生的人数</span><br><span class="line">	NODE stu;</span><br><span class="line">	PNODE pHead &#x3D; (PNODE)malloc(sizeof(NODE));		&#x2F;&#x2F;定义一个头结点并且为头结点分配内存</span><br><span class="line">	if(NULL &#x3D;&#x3D; pHead)	&#x2F;&#x2F;判断内存是否为空</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;内存分配失败,程序终止!\n&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line">	pHead.next &#x3D; NULL;&#x2F;&#x2F;清空指针域</span><br><span class="line">	printf(&quot;请输入学生的人数:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;len);</span><br><span class="line">	for(int i&#x3D;0; i&lt;len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		system(&quot;cls&quot;);		&#x2F;&#x2F;清屏</span><br><span class="line">		&#x2F;&#x2F;下面得到数据域</span><br><span class="line">		printf(&quot;请输入第%d个学生的姓名:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%s&quot;, stu.st.Name);</span><br><span class="line">		printf(&quot;请输入第%d个学生的年龄:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;stu.st.Age);</span><br><span class="line">		printf(&quot;请输入第%d个学生的学号:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;stu.st.No);</span><br><span class="line">		printf(&quot;请输入第%d个学生的语文成绩:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%f&quot;, &amp;stu.st.Score[0]);</span><br><span class="line">		printf(&quot;请输入第%d个学生的数学成绩:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%f&quot;, &amp;stu.st.Score[1]);</span><br><span class="line">		printf(&quot;请输入第%d个学生的英语成绩:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%f&quot;, &amp;stu.st.Score[2]);</span><br><span class="line"></span><br><span class="line">		stu.st.Total &#x3D; stu.st.Score[0] + stu.st.Score[1] + stu.st.Score[2];&#x2F;&#x2F;计算总分</span><br><span class="line">		stu.st.Ave &#x3D; stu.st.Total &#x2F; 3.0f;			&#x2F;&#x2F;计算平均分</span><br><span class="line"></span><br><span class="line">		PNODE pNew &#x3D; (PNODE)malloc(sizeof(NODE));	&#x2F;&#x2F;为新节点分配内存</span><br><span class="line">		if(NULL &#x3D;&#x3D; pNew)							&#x2F;&#x2F;判断内存是否为空</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;内存分配失败,程序终止!\n&quot;);</span><br><span class="line">			exit(-1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pNew.st &#x3D; stu.st;	&#x2F;&#x2F;初始化结点的数据域	</span><br><span class="line">		pNew.next &#x3D; pHead.next;	&#x2F;&#x2F;新结点的指针域为头结点的指针域 。</span><br><span class="line">&#x2F;&#x2F;		前插法插入的位置就是即将取代当前头结点的位置。</span><br><span class="line">&#x2F;&#x2F;		因为 pNew与pHead数据域不一样，所以不能 pNew&#x3D;pHead。 </span><br><span class="line">		pHead.next&#x3D;pNew;	&#x2F;&#x2F;更新头结点</span><br><span class="line">	&#125;</span><br><span class="line">	return pHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
<h1 id="总的代码如下："><a href="#总的代码如下：" class="headerlink" title="总的代码如下："></a>总的代码如下：</h1><p>代码中将初始化嵌套在了输入函数中，也可以拿出开成为独立的功能函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">struct Student			&#x2F;&#x2F;学生结构</span><br><span class="line">&#123;</span><br><span class="line">	char Name[10];		&#x2F;&#x2F;姓名</span><br><span class="line">	int No;				&#x2F;&#x2F;学号</span><br><span class="line">	float Score[3];		&#x2F;&#x2F;三科的成绩</span><br><span class="line">	float Total;		&#x2F;&#x2F;总分</span><br><span class="line">	float Ave;			&#x2F;&#x2F;平均分</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct Node		&#x2F;&#x2F;结点</span><br><span class="line">&#123;</span><br><span class="line">	struct Student st;	&#x2F;&#x2F;数据域</span><br><span class="line">	struct Node *next;	&#x2F;&#x2F;指针域</span><br><span class="line">&#125;NODE, *PNODE;			&#x2F;&#x2F;NODE等价于struct Student st||PNODE等价于struct Node *next</span><br><span class="line">						&#x2F;&#x2F;NODE * P&#x3D;&#x3D;PNODE P。为了提高可读性用NODE定义指向其他任意节点。用PNODE专指向头结点 </span><br><span class="line"></span><br><span class="line">PNODE InputStudent2();	&#x2F;&#x2F;输入函数,用于输入学生信息(前插法) </span><br><span class="line">PNODE InputStudent(PNODE pHead);	&#x2F;&#x2F;输入函数,用于输入学生信息(后插法) </span><br><span class="line">void OutputStudent(PNODE pHead);	&#x2F;&#x2F;输出学生信息</span><br><span class="line">void DeleteStudent(PNODE pHead);	&#x2F;&#x2F;删除学生信息</span><br><span class="line">void SearchStudent(PNODE pHead);	&#x2F;&#x2F;查找学生信息</span><br><span class="line">void ChangeStudent(PNODE pHead);	&#x2F;&#x2F;修改学生信息</span><br><span class="line">void InsertStudent(PNODE pHead);	&#x2F;&#x2F;增加学生信息</span><br><span class="line">void ScortByChinese(PNODE pHead);	&#x2F;&#x2F;对学生的语文成绩排序</span><br><span class="line">void ScortByMath(PNODE pHead);		&#x2F;&#x2F;对学生的数学成绩排序</span><br><span class="line">void ScortByEnglish(PNODE pHead);	&#x2F;&#x2F;对学生的英语成绩排序</span><br><span class="line">void ScortByTotal(PNODE pHead);		&#x2F;&#x2F;对学生的总分排序</span><br><span class="line"></span><br><span class="line">void welcome()&#123;</span><br><span class="line">	printf(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&quot;);</span><br><span class="line">	printf(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&quot;);</span><br><span class="line">	printf(&quot;**************欢迎使用学生成绩管理系统******************\n\n&quot;);</span><br><span class="line">	printf(&quot;--------------------------------------------------------\n\n&quot;);</span><br><span class="line">	printf(&quot;********************************************************\n\n&quot;);</span><br><span class="line">	printf(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&quot;);</span><br><span class="line">	printf(&quot;请按任意将进入学生管理系统:\n&quot;);</span><br><span class="line">	getchar();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void menu()&#123;</span><br><span class="line">	printf(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&quot;);</span><br><span class="line">	printf(&quot;------------- 请选择要操作的命令：------------------\n\n&quot;);</span><br><span class="line">	printf(&quot;------ 1  输入学生信息-------  2  输出学生信息------\n\n&quot;);</span><br><span class="line">	printf(&quot;------ 3  删除学生信息-------  4  查找学生信息------\n\n&quot;);</span><br><span class="line">	printf(&quot;------ 5  修改学生信息-------  6  增加学生信息------\n\n&quot;);</span><br><span class="line">	printf(&quot;------ 7  将学生的语文成绩按从大到小排--------------\n\n&quot;);</span><br><span class="line">	printf(&quot;------ 8  将学生的数学成绩按从大到小排--------------\n\n&quot;);</span><br><span class="line">	printf(&quot;------ 9  将学生的英语成绩按从大到小排--------------\n\n&quot;);</span><br><span class="line">    printf(&quot;------ 10 将学生的总成绩按从大到小排----------------\n\n&quot;);</span><br><span class="line">	printf(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&quot;);</span><br><span class="line">	printf(&quot;------ ¤¤¤¤   其他键退出系统    ¤¤¤¤   ------\n\n&quot;);</span><br><span class="line">	printf(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	welcome();	</span><br><span class="line">	system(&quot;cls&quot;);</span><br><span class="line">	int Item;</span><br><span class="line">	PNODE pHead &#x3D; NULL;&#x2F;&#x2F;定义一个指针</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		menu();</span><br><span class="line">		printf(&quot;请选择操作命令:&quot;);</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;Item);</span><br><span class="line">		system(&quot;cls&quot;);</span><br><span class="line">		switch(Item)</span><br><span class="line">		&#123;</span><br><span class="line">		    case 1:pHead &#x3D; InputStudent(pHead);break;</span><br><span class="line">			case 2:OutputStudent(pHead);break;</span><br><span class="line">			case 3:DeleteStudent(pHead);break;</span><br><span class="line">			case 4:SearchStudent(pHead);break;</span><br><span class="line">			case 5:ChangeStudent(pHead);break;</span><br><span class="line">			case 6:InsertStudent(pHead);break;</span><br><span class="line">			case 7:ScortByChinese(pHead);</span><br><span class="line">				   OutputStudent(pHead);break;</span><br><span class="line">			case 8:ScortByMath(pHead);</span><br><span class="line">				   OutputStudent(pHead);break;</span><br><span class="line">			case 9:ScortByEnglish(pHead);</span><br><span class="line">				   OutputStudent(pHead);break;</span><br><span class="line">			case 10:ScortByTotal(pHead);</span><br><span class="line">				    OutputStudent(pHead);break;</span><br><span class="line">			default:printf(&quot;系统已经退出，欢迎再次使用！\n&quot;),exit(1); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PNODE InputStudent(PNODE pHead)			&#x2F;&#x2F;输入函数,用于输入学生信息。采用后插法创建单链表 </span><br><span class="line">&#123;</span><br><span class="line">	int len;							&#x2F;&#x2F;学生的人数</span><br><span class="line">	NODE stu;</span><br><span class="line">	</span><br><span class="line">	PNODE p&#x3D;pHead;</span><br><span class="line">	PNODE pTail&#x3D;NULL;</span><br><span class="line">	if(NULL &#x3D;&#x3D; p)						&#x2F;&#x2F;判断之前是否录入过数据 </span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; (PNODE)malloc(sizeof(NODE));&#x2F;&#x2F;为头结点分配内存</span><br><span class="line">		if(NULL &#x3D;&#x3D; p)					&#x2F;&#x2F;判断内存是否为空</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;内存分配失败,程序终止!\n&quot;);</span><br><span class="line">			exit(-1);</span><br><span class="line">		&#125;</span><br><span class="line">		pTail &#x3D; p;						&#x2F;&#x2F;尾指针初始时指向头结点</span><br><span class="line">		pTail-&gt;next &#x3D; NULL;				&#x2F;&#x2F;清空指针域</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		PNODE temp &#x3D; p;	</span><br><span class="line">		while(NULL !&#x3D; temp-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			temp &#x3D; temp-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		pTail&#x3D;temp; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;请输入学生的人数:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;len);</span><br><span class="line">	int i;</span><br><span class="line">	for(i&#x3D;0; i&lt;len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		system(&quot;cls&quot;);&#x2F;&#x2F;清屏</span><br><span class="line">		printf(&quot;请输入第%d个学生的姓名:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%s&quot;, stu.st.Name);</span><br><span class="line">		printf(&quot;请输入第%d个学生的学号:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;stu.st.No);</span><br><span class="line">		printf(&quot;请输入第%d个学生的语文成绩:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%f&quot;, &amp;stu.st.Score[0]);</span><br><span class="line">		printf(&quot;请输入第%d个学生的数学成绩:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%f&quot;, &amp;stu.st.Score[1]);</span><br><span class="line">		printf(&quot;请输入第%d个学生的英语成绩:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%f&quot;, &amp;stu.st.Score[2]);</span><br><span class="line"></span><br><span class="line">		stu.st.Total &#x3D; stu.st.Score[0] + stu.st.Score[1] + stu.st.Score[2];&#x2F;&#x2F;计算总分</span><br><span class="line">		stu.st.Ave &#x3D; stu.st.Total &#x2F; 3.0f;		&#x2F;&#x2F;计算平均分</span><br><span class="line"></span><br><span class="line">		PNODE pNew &#x3D; (PNODE)malloc(sizeof(NODE));	&#x2F;&#x2F;为新节点分配内存</span><br><span class="line">		if(NULL &#x3D;&#x3D; pNew)	&#x2F;&#x2F;判断内存是否为空</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;内存分配失败,程序终止!\n&quot;);</span><br><span class="line">			exit(-1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pNew-&gt;st &#x3D; stu.st;	&#x2F;&#x2F;初始化结点的数据域	</span><br><span class="line">		pNew-&gt;next &#x3D; NULL;	&#x2F;&#x2F;清空新结点的指针域</span><br><span class="line">		&#x2F;&#x2F;以上两步构建了新的尾巴 </span><br><span class="line">		</span><br><span class="line">		pTail-&gt;next &#x3D; pNew;	&#x2F;&#x2F;将新结点挂在了链上 </span><br><span class="line">		&#x2F;&#x2F;后插法，插入的位置就是即将成为尾部的位置 </span><br><span class="line">		pTail &#x3D; pNew;	&#x2F;&#x2F;将pTail移到新的尾结点上</span><br><span class="line">	&#125;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PNODE InputStudent2()&#x2F;&#x2F;输入函数,用于输入学生信息。采用前插法创建单链表 </span><br><span class="line">&#123;</span><br><span class="line">	int len;&#x2F;&#x2F;学生的人数</span><br><span class="line">	NODE stu;</span><br><span class="line">	PNODE pHead &#x3D; (PNODE)malloc(sizeof(NODE));&#x2F;&#x2F;定义一个头结点并且为头结点分配内存</span><br><span class="line">	if(NULL &#x3D;&#x3D; pHead)	&#x2F;&#x2F;判断内存是否为空</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;内存分配失败,程序终止!\n&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line">	pHead-&gt;next &#x3D; NULL;&#x2F;&#x2F;清空指针域</span><br><span class="line">	printf(&quot;请输入学生的人数:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;len);</span><br><span class="line">	int i;</span><br><span class="line">	for(i&#x3D;0; i&lt;len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		system(&quot;cls&quot;);&#x2F;&#x2F;清屏</span><br><span class="line">		printf(&quot;请输入第%d个学生的姓名:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%s&quot;, stu.st.Name);</span><br><span class="line">		printf(&quot;请输入第%d个学生的学号:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;stu.st.No);</span><br><span class="line">		printf(&quot;请输入第%d个学生的语文成绩:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%f&quot;, &amp;stu.st.Score[0]);</span><br><span class="line">		printf(&quot;请输入第%d个学生的数学成绩:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%f&quot;, &amp;stu.st.Score[1]);</span><br><span class="line">		printf(&quot;请输入第%d个学生的英语成绩:\n&quot;, i+1);</span><br><span class="line">		scanf(&quot;%f&quot;, &amp;stu.st.Score[2]);</span><br><span class="line"></span><br><span class="line">		stu.st.Total &#x3D; stu.st.Score[0] + stu.st.Score[1] + stu.st.Score[2];&#x2F;&#x2F;计算总分</span><br><span class="line">		stu.st.Ave &#x3D; stu.st.Total &#x2F; 3.0f;		&#x2F;&#x2F;计算平均分</span><br><span class="line"></span><br><span class="line">		PNODE pNew &#x3D; (PNODE)malloc(sizeof(NODE));	&#x2F;&#x2F;为新节点分配内存</span><br><span class="line">		if(NULL &#x3D;&#x3D; pNew)	&#x2F;&#x2F;判断内存是否为空</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;内存分配失败,程序终止!\n&quot;);</span><br><span class="line">			exit(-1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pNew-&gt;st &#x3D; stu.st;	&#x2F;&#x2F;初始化结点的数据域	</span><br><span class="line">		pNew-&gt;next &#x3D; pHead-&gt;next;	&#x2F;&#x2F;新结点的指针域为头结点的指针域 。</span><br><span class="line">&#x2F;&#x2F;		前插法插入的位置就是即将取代当前头结点的位置。</span><br><span class="line">&#x2F;&#x2F;		因为 pNew与pHead数据域不一样，所以不能 pNew&#x3D;pHead。 </span><br><span class="line">		pHead-&gt;next&#x3D;pNew;	&#x2F;&#x2F;更新头结点</span><br><span class="line">	&#125;</span><br><span class="line">	return pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InsertStudent(PNODE pHead)&#x2F;&#x2F;增加学生信息</span><br><span class="line">&#123;</span><br><span class="line">	PNODE p &#x3D; pHead;</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	struct Student stu;&#x2F;&#x2F;学生结构</span><br><span class="line">	int pos;&#x2F;&#x2F;插入结点的位置</span><br><span class="line">	printf(&quot;请输入插入学生的位置:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;pos);</span><br><span class="line">	while(p &amp;&amp; i&lt;pos-1)</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	if(p &#x3D;&#x3D; NULL || i&gt;pos)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;插入结点的位置不存在!\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;你将在第%d个学生后面插入一个学生\n&quot;,pos-1);</span><br><span class="line">	printf(&quot;请输入第%d个学生的姓名:&quot;,pos);</span><br><span class="line">	scanf(&quot;%s&quot;,stu.Name);</span><br><span class="line">	printf(&quot;请输入第%d个学生的学号:&quot;,pos);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;stu.No);</span><br><span class="line">	printf(&quot;请输入第%d个学生的语文成绩:&quot;,pos);</span><br><span class="line">	scanf(&quot;%f&quot;,&amp;stu.Score[0]);</span><br><span class="line">	printf(&quot;请输入第%d个学生的数学成绩:&quot;,pos);</span><br><span class="line">	scanf(&quot;%f&quot;,&amp;stu.Score[1]);</span><br><span class="line">	printf(&quot;请输入第%d个学生的英语成绩:&quot;,pos);</span><br><span class="line">	scanf(&quot;%f&quot;,&amp;stu.Score[2]);</span><br><span class="line"></span><br><span class="line">	stu.Total &#x3D; stu.Score[0] + stu.Score[1] + stu.Score[2];&#x2F;&#x2F;计算总分	</span><br><span class="line">	stu.Ave &#x3D; stu.Total &#x2F; 3.0f;&#x2F;&#x2F;计算平均分</span><br><span class="line">	PNODE pNew &#x3D; (PNODE)malloc(sizeof(NODE));</span><br><span class="line">	if(NULL &#x3D;&#x3D; pNew)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;动态内存分配失败,程序终止!\n&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line">	pNew-&gt;st &#x3D; stu;</span><br><span class="line">	PNODE q &#x3D; p-&gt;next;	&#x2F;&#x2F;先把后继存起来 </span><br><span class="line">	p-&gt;next &#x3D; pNew;		&#x2F;&#x2F;然后把要插的插进来 </span><br><span class="line">	pNew-&gt;next &#x3D; q;		&#x2F;&#x2F;将刚刚保存的节点挂上 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OutputStudent(PNODE pHead)&#x2F;&#x2F;输出学生信息</span><br><span class="line">&#123;</span><br><span class="line">	PNODE p &#x3D; pHead-&gt;next;&#x2F;&#x2F;定义一个指针用于遍历学生信息，p指向第一个节点 </span><br><span class="line">	printf(&quot;   姓名    学号    语文    数学    英语     总分    平均分\n&quot;);	</span><br><span class="line">	while(p)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%6s  %8d  %6g  %6g  %6g  %6g  %10g\n&quot;, p-&gt;st.Name,p-&gt;st.No, p-&gt;st.Score[0], p-&gt;st.Score[1], p-&gt;st.Score[2], p-&gt;st.Total, p-&gt;st.Ave);</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DeleteStudent(PNODE pHead)&#x2F;&#x2F;删除学生信息</span><br><span class="line">&#123;</span><br><span class="line">	PNODE p &#x3D; pHead;</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	int pos;</span><br><span class="line">	printf(&quot;请输入你需要删除的学生的编号:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;pos);</span><br><span class="line">	while(p &amp;&amp; i&lt;pos-1)</span><br><span class="line">	&#123;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(p &#x3D;&#x3D; NULL || i&gt;pos-1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;没找到需要删除的学生的编号!\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	PNODE q &#x3D; p-&gt;next;</span><br><span class="line">	p-&gt;next &#x3D; q-&gt;next;</span><br><span class="line">	free(q);</span><br><span class="line">	q &#x3D;&#x3D; NULL;</span><br><span class="line">	printf(&quot;你已经成功删除了第%d个学生的信息!\n&quot;,pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SearchStudent(PNODE pHead)&#x2F;&#x2F;查找学生信息</span><br><span class="line">&#123;</span><br><span class="line">	char Name[10];</span><br><span class="line">	printf(&quot;请输入你需要查找的学生的姓名:&quot;);</span><br><span class="line">	scanf(&quot;%s&quot;,Name);</span><br><span class="line">	PNODE p &#x3D; pHead-&gt;next;&#x2F;&#x2F;p指向第一个节点 </span><br><span class="line">	while(p)</span><br><span class="line">	&#123;</span><br><span class="line">		if(0 &#x3D;&#x3D; strcmp(Name,p-&gt;st.Name))</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;%s %d %g %g %g %g %g\n&quot;,p-&gt;st.Name, p-&gt;st.No, p-&gt;st.Score[0], p-&gt;st.Score[1], p-&gt;st.Score[2], p-&gt;st.Total, p-&gt;st.Ave);</span><br><span class="line">		&#125;</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ChangeStudent(PNODE pHead)&#x2F;&#x2F;修改学生信息</span><br><span class="line">&#123;</span><br><span class="line">	char Name[10];</span><br><span class="line">	printf(&quot;请输入你需要修改的学生的姓名:&quot;);</span><br><span class="line">	scanf(&quot;%s&quot;,&amp;Name);</span><br><span class="line">	PNODE p &#x3D; pHead-&gt;next;&#x2F;&#x2F;定义一个指针用于遍历学生信息</span><br><span class="line">	while(p)</span><br><span class="line">	&#123;</span><br><span class="line">		if(0 &#x3D;&#x3D; strcmp(Name, p-&gt;st.Name))</span><br><span class="line">		&#123;	</span><br><span class="line">			printf(&quot;姓名 年龄  学号  语文  数学  英语  总分 平均分\n&quot;);			</span><br><span class="line">			printf(&quot;修改前的学生信息!\n&quot;);</span><br><span class="line">			printf(&quot;%s %d %g %g %g %g %g\n&quot;,p-&gt;st.Name, p-&gt;st.No, p-&gt;st.Score[0], p-&gt;st.Score[1], p-&gt;st.Score[2], p-&gt;st.Total, p-&gt;st.Ave);</span><br><span class="line">			system(&quot;pause&quot;);</span><br><span class="line">			system(&quot;cls&quot;);&#x2F;&#x2F;清屏</span><br><span class="line">			printf(&quot;请输入新的学生姓名:&quot;);</span><br><span class="line">			scanf(&quot;%s&quot;, p-&gt;st.Name);</span><br><span class="line">			printf(&quot;请输入新的学生学号:&quot;);</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;p-&gt;st.No);</span><br><span class="line">			printf(&quot;请输入新的学生的语文成绩:&quot;);</span><br><span class="line">			scanf(&quot;%f&quot;, &amp;p-&gt;st.Score[0]);</span><br><span class="line">			printf(&quot;请输入新的学生的数学成绩:&quot;);</span><br><span class="line">			scanf(&quot;%f&quot;, &amp;p-&gt;st.Score[1]);		</span><br><span class="line">			printf(&quot;请输入新的学生的英语成绩:&quot;);</span><br><span class="line">			scanf(&quot;%f&quot;, &amp;p-&gt;st.Score[2]);</span><br><span class="line">						</span><br><span class="line">			p-&gt;st.Total &#x3D; p-&gt;st.Score[0] + p-&gt;st.Score[1] + p-&gt;st.Score[2];&#x2F;&#x2F;计算总分		</span><br><span class="line">			p-&gt;st.Ave &#x3D; p-&gt;st.Total &#x2F; 3.0f;	&#x2F;&#x2F;计算平均分</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	  p &#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ScortByChinese(PNODE pHead)&#x2F;&#x2F;对学生的语文成绩排序</span><br><span class="line">&#123;</span><br><span class="line">	PNODE p, q;&#x2F;&#x2F;定义两个指针	</span><br><span class="line">	NODE temp;</span><br><span class="line">	for(p&#x3D;pHead-&gt;next; NULL !&#x3D; p; p&#x3D;p-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		for(q&#x3D;p-&gt;next; NULL !&#x3D;q; q&#x3D;q-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			if(p-&gt;st.Score[0] &lt; q-&gt;st.Score[0])&#x2F;&#x2F;当前一个学生的语文成绩小于后一个学生的语文成绩时</span><br><span class="line">			&#123;</span><br><span class="line">				temp.st  &#x3D; p-&gt;st;&#x2F;&#x2F;交换学生的位置</span><br><span class="line">				p-&gt;st &#x3D;  q-&gt;st;</span><br><span class="line">				q-&gt;st &#x3D; temp.st;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ScortByMath(PNODE pHead)&#x2F;&#x2F;对学生的数学成绩排序</span><br><span class="line">&#123;</span><br><span class="line">	PNODE p, q;&#x2F;&#x2F;定义两个指针	</span><br><span class="line">	NODE temp;</span><br><span class="line">	for(p&#x3D;pHead-&gt;next; NULL !&#x3D; p; p&#x3D;p-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		for(q&#x3D;p-&gt;next; NULL !&#x3D;q; q&#x3D;q-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			if(p-&gt;st.Score[1] &lt; q-&gt;st.Score[1])&#x2F;&#x2F;当前一个学生的数学成绩小于后一个学生的数学成绩时</span><br><span class="line">			&#123;</span><br><span class="line">				temp.st  &#x3D; p-&gt;st;&#x2F;&#x2F;交换学生的位置</span><br><span class="line">				p-&gt;st &#x3D;  q-&gt;st;</span><br><span class="line">				q-&gt;st &#x3D; temp.st;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ScortByEnglish(PNODE pHead)&#x2F;&#x2F;对学生的英语成绩排序</span><br><span class="line">&#123;</span><br><span class="line">	PNODE p, q;&#x2F;&#x2F;定义两个指针	</span><br><span class="line">	NODE temp;</span><br><span class="line">	for(p&#x3D;pHead-&gt;next; NULL !&#x3D; p; p&#x3D;p-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		for(q&#x3D;p-&gt;next; NULL !&#x3D;q; q&#x3D;q-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			if(p-&gt;st.Score[2] &lt; q-&gt;st.Score[2])&#x2F;&#x2F;当前一个学生的英语成绩小于后一个学生的英语成绩时</span><br><span class="line">			&#123;</span><br><span class="line">				temp.st  &#x3D; p-&gt;st;&#x2F;&#x2F;交换学生的位置</span><br><span class="line">				p-&gt;st &#x3D;  q-&gt;st;</span><br><span class="line">				q-&gt;st &#x3D; temp.st;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ScortByTotal(PNODE pHead)&#x2F;&#x2F;对学生的总分排序</span><br><span class="line">&#123;</span><br><span class="line">	PNODE p, q;&#x2F;&#x2F;定义两个指针	</span><br><span class="line">	NODE temp;</span><br><span class="line">	for(p&#x3D;pHead-&gt;next; NULL !&#x3D; p; p&#x3D;p-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		for(q&#x3D;p-&gt;next; NULL !&#x3D;q; q&#x3D;q-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			if(p-&gt;st.Total &lt; q-&gt;st.Total)&#x2F;&#x2F;当前一个学生的总分小于后一个学生的总分时</span><br><span class="line">			&#123;</span><br><span class="line">				temp.st  &#x3D; p-&gt;st;&#x2F;&#x2F;交换学生的位置</span><br><span class="line">				p-&gt;st &#x3D;  q-&gt;st;</span><br><span class="line">				q-&gt;st &#x3D; temp.st;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h1><p>后插法得到的如下：<br><img src="https://img-blog.csdnimg.cn/20190702123004642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>前插法得到的如下：<br><img src="https://img-blog.csdnimg.cn/20190702123503260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上面可以看出前插法与后插法得到的顺序相反。</p>
<p><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
<h1 id="顺序表与链表的比较"><a href="#顺序表与链表的比较" class="headerlink" title="顺序表与链表的比较"></a>顺序表与链表的比较</h1><p><img src="https://img-blog.csdnimg.cn/20190702125922405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="#topAnchor" style="position:fixed;right:0;bottom:0">回到目录</a></p>
]]></content>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构概述</title>
    <url>/2019/07/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是第一次开始写博客，目的是为了记录自己复习数据结构的情况。从这开始，会陆续将数据结构的知识整理一遍。</p>
<h1 id="数据结构简述"><a href="#数据结构简述" class="headerlink" title="数据结构简述"></a>数据结构简述</h1><p><strong>数据：</strong> 数据是信息的载体，是计算机程序加工的“原材料”。<br><strong>数据元素：</strong> 是数据的基本单位。一个数据元素可以由若干数据项组成。<br><strong>数据项：</strong> 是组成数据元素的最小单位。<br>例如：一条学生信息就是一个数据元素，学生学号、姓名等都是数据项。<br><strong>数据结构：</strong> 数据结构指的是数据之间的相互关系，即数据的组织形式。</p>
<p><strong>数据结构包括三个方面的内容：</strong> <em>数据的逻辑结构、数据的存储结构、数据的运算。</em></p>
<ul>
<li>数据的逻辑结构 <ol>
<li>线性结构<br>●线性结构是非空集；<br>●线性结构有且仅有一个开始节点和一个终端节点；<br>●线性结构的所有节点最多只有一个直接前驱和一个直接后继。 </li>
</ol>
 <strong><em>线性表、栈、队列和串等都是线性结构。</em></strong><ol start="2">
<li>非线性结构<br>●非线性结构是非空集；<br>●非性结构的一个节点可能有多个直接前驱和直接后继。 </li>
</ol>
</li>
</ul>
<p><strong><em>在实际应用中，数组、广义表、树结构和图结构等都是非线性结构。</em></strong><br><strong><em>类、结构体、枚举、数组是四种复合类型</em></strong></p>
<ul>
<li>数据的存储结构 <ol>
<li>顺序存储结构<br>●顺序存储方式就是在一块连续的存储区域一个接着一个地存放数据；<br>●把逻辑上相邻的节点存储在物理位置上相邻的存储单元里；<br>●节点间的逻辑关系由存储单元的邻接关系体现。  </li>
</ol>
</li>
</ul>
<p><strong><em>一般采用数组来描述。</em></strong><br>    2. 链式存储结构<br>●节点间的逻辑关系由附加的指针域（引用）表示；<br>●指针域指向下一节点的存储位置。<br>    3. 索引存储<br>    4. 散列存储</p>
<ul>
<li>数据的运算</li>
</ul>
<p><strong><em>最常用的运算：增、删、改、查。</em></strong></p>
<p><strong>注意：</strong> 同一逻辑结构可以有不同的存储结构。例如，如果线性表采用顺序存储方式，这种数据结构就是顺序表；如果线性表采用连式存储方式，这种数据结构就是链表；如果线性表采用散列存储方式，这种数据结构就是散列表；</p>
<h1 id="常用的数据结构"><a href="#常用的数据结构" class="headerlink" title="常用的数据结构"></a>常用的数据结构</h1><ol>
<li>数组</li>
<li>链表</li>
<li>栈</li>
<li>队列</li>
<li>树</li>
<li>图</li>
<li>堆</li>
<li>散列表</li>
</ol>
<p><strong><em>后续将分模块，详细整理这些数据结构的具体操作实现。</em></strong></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序表--学生信息管理</title>
    <url>/2019/07/01/%E9%A1%BA%E5%BA%8F%E8%A1%A8--%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="顺序表结构"><a href="#顺序表结构" class="headerlink" title="顺序表结构"></a>顺序表结构</h1><ul>
<li>逻辑结构：线性表</li>
<li>存储结构：顺序存储</li>
<li>基本运算：<ol>
<li>初始化</li>
<li>查找节点</li>
<li>插入节点</li>
<li>删除节点<h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int Status;</span><br><span class="line"></span><br><span class="line">typedef struct		</span><br><span class="line">&#123;</span><br><span class="line">	char name[20];		 &#x2F;&#x2F; 姓名</span><br><span class="line">    char stuId[8]; 		&#x2F;&#x2F; 学号</span><br><span class="line"></span><br><span class="line">&#125;student;</span><br><span class="line"></span><br><span class="line">typedef student ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct		</span><br><span class="line">&#123;</span><br><span class="line">	ElemType *elem; 	&#x2F;&#x2F; 存储空间的基地址 </span><br><span class="line">	int length; 	&#x2F;&#x2F; 当前长度 </span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2>分配内存，此时长度设为0。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Status InitList(SqList *L)   &#x2F;&#x2F; 初始化 </span><br><span class="line">&#123; </span><br><span class="line"> L-&gt;elem&#x3D;(ElemType *)malloc(sizeof(ElemType)*MAXSIZE);</span><br><span class="line"> if(!L-&gt;elem)  exit(-1); </span><br><span class="line"> L-&gt;length&#x3D;0; </span><br><span class="line"> printf(&quot;初始化成功\n\n&quot;);</span><br><span class="line"> return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int FindByStuId(SqList &amp;L) &#x2F;&#x2F; 根据学号查找，返回该同学在顺序表中的编号 </span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;请输入要查找的学生学号:&quot;);	</span><br><span class="line">	char s[20];	</span><br><span class="line"></span><br><span class="line">	scanf(&quot;%s&quot;,s);</span><br><span class="line">	</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;L.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(strcmp(L.elem[i].stuId,s)&#x3D;&#x3D;0)</span><br><span class="line">		</span><br><span class="line">			return i;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2></li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Status ListInsert(SqList &amp;L,int i,ElemType data) &#x2F;&#x2F; 在 i位置插入</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	if((i&lt;1)||(i&gt;L.length+1))	&#x2F;&#x2F;序号不正确 </span><br><span class="line">	</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	if(L.length&gt;&#x3D;MAXSIZE)	&#x2F;&#x2F;已经达到最大值 </span><br><span class="line">		</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	for(int j&#x3D;L.length;j&gt;&#x3D;i;j--)</span><br><span class="line">	&#123;</span><br><span class="line">		L.elem[j+1]&#x3D;L.elem[j];		&#x2F;&#x2F;元素后移 </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	L.elem[i]&#x3D;data;</span><br><span class="line"></span><br><span class="line">	L.length++;</span><br><span class="line"></span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Status ListDelete(SqList &amp;L,int i) &#x2F;&#x2F; 		删除 i位置的学生信息 </span><br><span class="line">&#123;</span><br><span class="line">	if((i&lt;1)||(i&gt;L.length))		&#x2F;&#x2F;序号不正确 </span><br><span class="line">		</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	for(int j&#x3D;i;j&lt;&#x3D;L.length;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		L.elem[j]&#x3D;L.elem[j+1];		&#x2F;&#x2F;元素前移 </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	L.length--;</span><br><span class="line"></span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总的代码如下："><a href="#总的代码如下：" class="headerlink" title="总的代码如下："></a>总的代码如下：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define MAXSIZE 10</span><br><span class="line"></span><br><span class="line">int num;</span><br><span class="line"></span><br><span class="line">typedef int Status;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	char name[20];		 &#x2F;&#x2F; 姓名</span><br><span class="line">    char stuId[8]; 		&#x2F;&#x2F; 学号</span><br><span class="line"></span><br><span class="line">&#125;student;</span><br><span class="line"></span><br><span class="line">typedef student ElemType;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	ElemType *elem; 	&#x2F;&#x2F; 存储空间的基地址 </span><br><span class="line">	int length; 	&#x2F;&#x2F; 当前长度 </span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">Status InitList(SqList *L) 		&#x2F;&#x2F; 初始化 </span><br><span class="line">&#123;	</span><br><span class="line">	L-&gt;elem&#x3D;(ElemType *)malloc(sizeof(ElemType)*MAXSIZE);</span><br><span class="line">	if(!L-&gt;elem)  exit(-1); </span><br><span class="line">	L-&gt;length&#x3D;0;	</span><br><span class="line">	printf(&quot;初始化成功\n\n&quot;);</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GetElem(SqList &amp;L,int i) 		&#x2F;&#x2F; 访问顺序表</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;学号:%-10s\t姓名:%-20s\n&quot;,L.elem[i].stuId,L.elem[i].name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Input(ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;姓名:&quot;);	</span><br><span class="line">	scanf(&quot;%s&quot;,e-&gt;name);</span><br><span class="line"></span><br><span class="line">	printf(&quot;学号:&quot;);	</span><br><span class="line">	scanf(&quot;%s&quot;,e-&gt;stuId);</span><br><span class="line">	</span><br><span class="line">	printf(&quot;输入完成\n\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Input(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;请输入要录入学生的人数:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line">	</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;num;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;第%d个学生:\n&quot;,i);</span><br><span class="line">		Input(&amp;L.elem[i]);</span><br><span class="line">	&#125;	</span><br><span class="line">	L.length&#x3D;num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Output(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;num;i++)</span><br><span class="line">	&#123;					</span><br><span class="line">		GetElem(L,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FindByStuId(SqList &amp;L) &#x2F;&#x2F; 根据学号查找，返回该同学在顺序表中的编号 </span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;请输入要查找的学生学号:&quot;);	</span><br><span class="line">	char s[20];	</span><br><span class="line"></span><br><span class="line">	scanf(&quot;%s&quot;,s);</span><br><span class="line">	</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;L.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(strcmp(L.elem[i].stuId,s)&#x3D;&#x3D;0)</span><br><span class="line">		</span><br><span class="line">			return i;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElemType FindByNum(SqList &amp;L) &#x2F;&#x2F; 根据序号查找，返回该同学的信息 </span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;请输入要查询的位置:&quot;);</span><br><span class="line">	int n;</span><br><span class="line">	</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	GetElem(L,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status ListInsert(SqList &amp;L,int i,ElemType data) &#x2F;&#x2F; 在 i位置插入</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	if((i&lt;1)||(i&gt;L.length+1))	&#x2F;&#x2F;序号不正确 </span><br><span class="line">	</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	if(L.length&gt;&#x3D;MAXSIZE)	&#x2F;&#x2F;已经达到最大值 </span><br><span class="line">		</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	for(int j&#x3D;L.length;j&gt;&#x3D;i;j--)</span><br><span class="line">	&#123;</span><br><span class="line">		L.elem[j+1]&#x3D;L.elem[j];		&#x2F;&#x2F;元素后移 </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	L.elem[i]&#x3D;data;</span><br><span class="line"></span><br><span class="line">	L.length++;</span><br><span class="line"></span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ListInsert(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">	printf (&quot;请输入要插入的位置:&quot;);</span><br><span class="line"></span><br><span class="line">	int id;	</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;id);</span><br><span class="line">	</span><br><span class="line">	printf(&quot;请输入学生信息:\n&quot;);</span><br><span class="line">	ElemType temp;</span><br><span class="line">	Input(&amp;temp);</span><br><span class="line">	</span><br><span class="line">	if(ListInsert(L,id,temp))</span><br><span class="line">	&#123;</span><br><span class="line">		num++;</span><br><span class="line">		printf(&quot;插入成功\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;插入失败\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status ListDelete(SqList &amp;L,int i) &#x2F;&#x2F; 		删除 i位置的学生信息 </span><br><span class="line">&#123;</span><br><span class="line">	if((i&lt;1)||(i&gt;L.length))		&#x2F;&#x2F;序号不正确 </span><br><span class="line">		</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	for(int j&#x3D;i;j&lt;&#x3D;L.length;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		L.elem[j]&#x3D;L.elem[j+1];		&#x2F;&#x2F;元素前移 </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	L.length--;</span><br><span class="line"></span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ListDelete(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;请输入要删除的位置:&quot;);</span><br><span class="line">	</span><br><span class="line">	int id;	</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;id);</span><br><span class="line">	</span><br><span class="line">	if(ListDelete(L,id))</span><br><span class="line">	&#123;</span><br><span class="line">		num--;</span><br><span class="line">		printf(&quot;删除成功\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;删除失败\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void menu()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;\n********************************\n\n&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;1. 录入信息\n&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;2. 显示信息\n&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;3. 按学号查找学生\n&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;4. 按序号查找学生\n&quot;); </span><br><span class="line"></span><br><span class="line">	printf(&quot;5. 在指定位置插入学生信息\n&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;6. 在指定位置删除学生信息\n&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;7. 学生总数\n&quot;);</span><br><span class="line">	</span><br><span class="line">	printf(&quot;\n********************************\n\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	menu();</span><br><span class="line">	</span><br><span class="line">	SqList L;		</span><br><span class="line"></span><br><span class="line">	ElemType a,b,c,d;</span><br><span class="line">	</span><br><span class="line">	int num,choose;</span><br><span class="line">	</span><br><span class="line">	if(InitList(&amp;L))&#123;</span><br><span class="line">	 </span><br><span class="line">		while(1)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;请输入选择,其他键退出:&quot;);</span><br><span class="line">			</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;choose);</span><br><span class="line">			</span><br><span class="line">			switch(choose)</span><br><span class="line">			&#123;</span><br><span class="line">				case 1:	Input(L); 						break;	</span><br><span class="line">				case 2:	Output(L); 						break;	</span><br><span class="line">				case 3:	GetElem(L,FindByStuId(L));		break;	</span><br><span class="line">				case 4:	FindByNum(L);					break;	</span><br><span class="line">				case 5:	ListInsert(L);					break;		</span><br><span class="line">				case 6:	ListDelete(L);					break;</span><br><span class="line">				case 7:</span><br><span class="line">					printf(&quot;已录入的学生个数为:%d\n\n&quot;,L.length);</span><br><span class="line">					break;						</span><br><span class="line">				default:	</span><br><span class="line">					exit(1);</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;初始化失败！&quot;);</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p><img src="https://img-blog.csdnimg.cn/2019070117093545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190701171109316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019070117121362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nvbmdzb25nTA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong><em>注意：此程序没有太在意数据校验，乱输入可能有bug。</em></strong></p>
]]></content>
      <tags>
        <tag>顺序表</tag>
      </tags>
  </entry>
</search>
